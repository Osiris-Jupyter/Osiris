"fig, (ax1, ax2) = plot_td_and_fd(t, nr, frequencies, nrtilde);

ax1.set_xlim(xmax=18.0)  # Zoom in a little to see mostly signal
ax1.set_title('')  # Remove the 'Time domain' title, because it gets in the way

def nr_frequency_string(time, position):  # Format the frequency as a string in the plot ticks
    if time>16.45:
        return ''
    return '{0:.1f}'.format(abs(nr_frequency_interpolator([time])[0]))
ax3 = ax1.twiny()  # Make a copy of the first plot, but use a different x axis
ax3.xaxis.set_major_formatter(FuncFormatter(nr_frequency_string))  # Use our tick formatter
ax3.plot([t[0], t[-1]], [0, 0], 'x', alpha=0.0)  # Plot some data occupying same span of time
ax3.set_xlabel('GW Frequency (Hertz)')  # Set the upper x label
ax3.set_xlim(ax1.get_xlim());  # Make sure we have the same zoom"
"fig, (ax1, ax2) = plot_td_and_fd(t, h, frequencies, htilde);"
"# Set up the frequency bins we'll use for our graphic equalizer
log2_sampling_rate = int(np.log2(sampling_rate/2))
frequency_bin_upper_ends = np.logspace(3, log2_sampling_rate,
                                       num=2*(log2_sampling_rate-3)+1, base=2)

# This is some code to set up some interactive sliders for our graphic equalizer
gap_filler = widgets.Label("""", layout=widgets.Layout(flex='1 1 auto'))
separator = widgets.VBox([], border='1px solid #ccc', width='0px')
use_equalizer = widgets.Checkbox(description='Use equalizer', value=True)
labels = widgets.VBox([widgets.Label(""Frequency (Hz)""), gap_filler,
                       use_equalizer, gap_filler,
                       widgets.Label(""Amplitude (dB)"")], width='110px')
sliders = [widgets.FloatSlider(min=-200.0, max=200.0, step=0.5, value=0.0,
                               height='auto', width='45px', padding=6,
                               readout_format='+.1f', orientation='vertical',
                               description=str(int(freq)))
           for freq in frequency_bin_upper_ends]
equalizer = widgets.HBox(children=[labels, separator]+sliders+[separator], height='200px')
display(equalizer)

# We might also want to add specific little ""notch"" filters to get rid of
# noise sources like the 60 Hz hum from the power lines
notch_filters = widgets.VBox([], width='450px')
add_notch_filters = widgets.Button(description=""Add notch filter"")
add_notch_filters.on_click(lambda change: add_notch_filter(notch_filters, gap_filler))
display(add_notch_filters)
display(notch_filters)

# It sometimes gets confusing to see the original data plotted behind the filtered data,
# so add a checkmark to remove it
hide_original_time_domain = widgets.Checkbox(description='Hide raw t. d. data', value=False)

# Add a button to re-make the plot and audio for the current settings
recalculate_button = widgets.Button(description='Recalculate')
def recalculate_button_on_click(change):
    clear_output(wait=True)
    display(equalizer)
    display(add_notch_filters)
    display(notch_filters)
    display(recalculate)
    filter_and_plot(h, t, htilde, sampling_rate, sliders, notch_filters, use_equalizer,
                    frequencies, frequency_bin_upper_ends, hide_original_time_domain)
recalculate_button.on_click(recalculate_button_on_click)
recalculate = widgets.HBox([recalculate_button, hide_original_time_domain])
display(recalculate)

filter_and_plot(h, t, htilde, sampling_rate, sliders, notch_filters, use_equalizer, frequencies,
                frequency_bin_upper_ends, hide_original_time_domain)"
"plt.close()
plt.loglog(frequencies, np.abs(htilde), label='Raw data')
plt.loglog(f_noise, noise_spectral_density, label='Noise estimate')
plt.xlim(1, 0.6*sampling_rate)
plt.xlabel('Frequency (Hertz)')
plt.ylabel('Noise spectrum and strain Fourier transform (seconds)')
plt.grid()
plt.legend();"
"# We simply divide htilde by the noise estimate to ""equalize"" the data in the frequency domain
htilde_equalized = htilde / noise_spectral_density_interpolator(frequencies)

# Now we transform back to the time domain, and smoothly fade on and off to get rid of loud clicks
h_equalized = fade(sampling_rate * np.fft.irfft(htilde_equalized))

# Finally we can plot and listen to the data
plot_td_and_fd(t, h_equalized, frequencies, htilde_equalized, h=h, htilde=1e21*htilde);"
"notch_locations_and_sizes = [
    (35.1, 37.1, 0.25), (35.7, 36., 0.8), (36.6, 36.8, 1.3), (40.9, 41.0, 2), # Gremlins
    (59.9, 60.1, 4), (119.9, 120.1, 3), (179.9, 180.1, 4),  # Line noise
    (299.47, 299.7, 2), (303.2, 303.35, 2), (310., 327., 0.25), (331.7, 332.2, 2), # Violin modes
    (500.5, 503.1, 1.0), (504.7, 504.9, 1.5), (507.0, 508.7, 1.5), # Violin modes
    (991.2, 992.8, 4), (993.7, 997.0, 4), (997.5, 999.5, 4), (1003.7, 1005.4, 4)]  # Harmonics

h_notched = fade(notch_data(h, sampling_rate, notch_locations_and_sizes))
htilde_notched = dt * np.fft.rfft(h_notched)

# Finally we can plot and listen to the notched data
plot_td_and_fd(t, h_notched, frequencies, htilde_notched, htilde=dt*np.fft.rfft(fade(h)));"
"# Now we'll estimate the noise spectrum again
number_of_chunks = 8
points_per_chunk = 2**int(np.log2(len(h_notched)/number_of_chunks))
f_noise, noise_welch = scipy.signal.welch(h_notched, sampling_rate, nperseg=points_per_chunk)
noise_spectral_density = np.sqrt(2 * len(h_notched) * noise_welch / sampling_rate)
noise_spectral_density_interpolator = InterpolatedUnivariateSpline(f_noise,noise_spectral_density)

# And we'll filter the data using this new estimate
htilde_notched_equalized = htilde_notched / noise_spectral_density_interpolator(frequencies)
h_notched_equalized = fade(sampling_rate * np.fft.irfft(htilde_notched_equalized))

plot_td_and_fd(t, h_notched_equalized, frequencies, htilde_notched_equalized, htilde=1e21*htilde);"
"h_filtered = bandpass(h_notched_equalized, sampling_rate, lower_end=35.0, upper_end=265.0)
h_filtered_tilde = dt * np.fft.rfft(h_filtered)

plot_td_and_fd(t, h_filtered, frequencies, h_filtered_tilde, htilde=1e22*htilde);"
"# Load the raw data from LIGO Livingston
with h5py.File('Data/L-L1_LOSC_4_V1-1126259446-32.hdf5') as f:
    l = f['strain/Strain'][:]  # Time of event is 16.4

# Now Fourier transform the raw data
ltilde = dt * np.fft.rfft(l)

# Filter it using our function
l_filtered = filter_signal(l, sampling_rate)

# Now Fourier transform the filtered data
l_filtered_tilde = dt * np.fft.rfft(l_filtered)

# Finally plot and play it
plot_td_and_fd(t, l_filtered, frequencies, l_filtered_tilde, h=l, htilde=1e22*ltilde);"
"plt.close()
plt.plot(t+0.0072, -l_filtered, label='Livingston')
plt.plot(t, h_filtered, label='Hanford')
plt.xlim(16.2, 16.5)
plt.xlabel('Time (seconds)')
plt.ylabel('Detector strain $h$ (dimensionless)')
plt.title('Filtered detector data from the GW150914 event')
plt.grid()
plt.legend();

# Here, we'll play the sounds with Livingston in the left ear and Hanford in the right
display(Audio(data=np.vstack((np.roll(-l_filtered, int(0.0072*sampling_rate)), h_filtered)),
              rate=sampling_rate))"
"plt.close()
plt.plot(t+0.0072, -l_filtered, label='Livingston')
plt.plot(t, h_filtered, label='Hanford')
plt.plot(t-0.002, 8e21*nr, label='Simulated')
plt.xlim(16.0, 16.5)
plt.xlabel('Time (seconds)')
plt.ylabel('Detector strain $h$ (dimensionless)')
plt.title('Filtered detector data and simulated signal')
plt.grid()
plt.legend(loc='upper left');

# Here, we'll play the sounds with Livingston in the left ear, Hanford in the right,
# and NR in the center.  We ""roll"" the Livingston and simulated data as a simple way
# of shifting them in time.
display(Audio(data=np.vstack((np.roll(-l_filtered, int(0.0072*sampling_rate)),
                              h_filtered,
                              np.roll(8e21*nr, int(-0.002*sampling_rate)))),
              rate=sampling_rate))"
"# Filter and rescale arbitrarily to match amplitude of data
nr_filtered_h = 0.55 * filter_signal(nr, sampling_rate, noisy_signal=h)
nr_filtered_h_tilde = dt * np.fft.rfft(nr_filtered_h)
nr_filtered_l = 0.55 * filter_signal(nr, sampling_rate, noisy_signal=l)
nr_filtered_l_tilde = dt * np.fft.rfft(nr_filtered_l)

# Now, plot and play the *filtered* NR data on top of the filtered detector data
plt.close()
plt.plot(t+0.0072, -l_filtered, label='Livingston')
plt.plot(t, h_filtered, label='Hanford')
plt.plot(t-0.002, nr_filtered_h, label='Simulated and filtered')
plt.xlim(16.1, 16.5)
plt.xlabel('Time (seconds)')
plt.ylabel('Detector strain $h$ (dimensionless)')
plt.title('Filtered detector data and simulated signal')
plt.grid()
plt.legend(loc='upper left');
display(Audio(data=np.vstack((np.roll(-l_filtered, int(0.0072*sampling_rate)),
                              h_filtered,
                              np.roll(nr_filtered_h, int(-0.002*sampling_rate)))),
              rate=sampling_rate))"
"# Add small time offsets to the filtered detector data, to align the measured data to the model,
# and evaluate the correlation.  (The precise time offsets will be derived below.)
l_correlation = np.roll(-l_filtered, 37) * nr_filtered_h
h_correlation = np.roll(+h_filtered,  7) * nr_filtered_l

# Integrate the correlation functions over time
c_l = scipy.integrate.simps(l_correlation, t)
c_h = scipy.integrate.simps(h_correlation, t)
display(Latex(r'$c_{{\mathrm{{Livingston}}}} = {0:.4f}$'.format(c_l)))
display(Latex(r'$c_{{\mathrm{{Hanford}}}} = {0:.4f}$'.format(c_h)))

# Plot the correlation functions as functions of time
plt.close()
plt.plot(t, l_correlation, label='Livingston')
plt.plot(t, h_correlation, label='Hanford')
plt.grid()
plt.xlim(16.25, 16.5)
plt.xlabel('Time (seconds)')
plt.ylabel('Correlation between data and simulated signal')
plt.legend();"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('bmh')
%matplotlib inline

plt.figure(figsize = (12, 6))
for i in range(10):
    x = np.arange(i * 10, i * 10 + 10)
    y_var1 = np.random.randint(1, 5, 10)
    y_var2 = np.random.randint(5, 8, 10)
    plt.plot(x, y_var1, color = 'k', label = 'variable1')
    plt.plot(x, y_var2, color = 'g', label = 'variable2')
    plt.legend()
    plt.ylim(0, 9)"
"plt.figure(figsize = (12, 6))
for i in range(10):
    x = np.arange(i * 10, i * 10 + 10)
    y_var1 = np.random.randint(1, 5, 10)
    y_var2 = np.random.randint(5, 8, 10)
    plt.plot(x, y_var1, color = 'k', label = 'variable1' if i == 0 else ""_esto_no_se_pintará"")
    plt.plot(x, y_var2, color = 'g', label = 'variable2' if i == 0 else ""_esto_tampoco"")
    plt.legend()
    plt.ylim(0, 9)"
"## Dictionary
example_dictionary = {""A"": ""Adenine"", 
                      ""C"": ""Cytosine"", 
                      ""G"": ""Guanine"", 
                      ""T"": ""Thymine""}
print('A dictionary:', example_dictionary)
print('Value associated to key C:', example_dictionary['C'])"
"def PR(nd, na):
    return na/(na + nd)

PR(nd, na)"
"def FRET(nd, na, gamma):
    return na / (na + gamma*nd)

FRET(nd, na, gamma)"
"ns_a_as_func_na = na + Lk*nd + n_dir
ns_a_as_func_na"
"Er_sym = sympy.factor(PR(nd, ns_a).subs(ns_a, ns_a_as_func_na).subs(n_dir, d_exT*(nd*gamma + na)))
Er_sym"
"E_func_Er = sympy.factor(FRET(nd, na, gamma).subs(nd, solve(Er_sym - Er, nd)[0])).collect(Er)
E_func_Er"
E_func_Er
"E_func_Er.subs(Lk, 0).subs(d_exT, 0)"
"sympy.collect(E_func_Er.subs(gamma, 1).subs(d_exT, 0), Er)"
"sympy.collect(E_func_Er.subs(gamma, 1).subs(Lk, 0), Er)"
"sympy.collect(Er_func_E, E)"
"Er_func_E.subs(Lk, 0).subs(d_exT, 0)"
"sympy.collect(Er_func_E.subs(gamma, 1).subs(d_exT, 0), Er)"
"sympy.collect(Er_func_E.subs(gamma, 1).subs(Lk, 0), Er)"
"def StoichRaw(nd, na, naa):
    return (na + nd)/(na + nd + naa)

StoichRaw(nd, na, naa)"
"def Stoich(nd, na, naa, gamma):
    return (na + gamma*nd)/(na + gamma*nd + naa)

Stoich(nd, na, naa, gamma)"
"ns_a_as_func_na = na + Lk*nd + n_dir
ns_a_as_func_na"
"Sr_sym = sympy.factor(
    StoichRaw(nd, ns_a, naa).subs(ns_a, ns_a_as_func_na).subs(n_dir, d_exT*(na + gamma*nd))
    )
Sr_sym"
"S_sym = Stoich(nd, na, naa, gamma)
S_sym"
"S_func_Sr_nx = S_sym.subs(na, solve(Sr_sym - Sr, na)[0]).factor()
S_func_Sr_nx"
"E_sym = FRET(nd, na, gamma)
E_sym"
"na_func_Sr = solve(Sr_sym - Sr, na)[0]
na_func_Sr"
"E_func_Sr = E_sym.subs(na, na_func_Sr).factor()
E_func_Sr"
"nd_func_E_Sr = solve(E_func_Sr - E, nd)[0]
nd_func_E_Sr"
"S_func_E_Sr = S_func_Sr_nx.replace(nd, nd_func_E_Sr).factor()
S_func_E_Sr"
ns_a_as_func_na
"Er_sym = PR(nd, ns_a).subs(ns_a, ns_a_as_func_na).subs(n_dir, d_exT*(nd*gamma + na))
Er_sym"
"E_func_Er = FRET(nd, na, gamma).subs(nd, solve(Er_sym - Er, nd)[0]).factor()
E_func_Er"
"S_func_Er_Sr = S_func_E_Sr.replace(E, E_func_Er).factor()
S_func_Er_Sr "
"S_func_E_Spr = (S_func_E_Sr.replace(Lk, 0).replace(d_exT, 0)
                .replace(Sr, Spr).replace(Er, Epr))
S_func_E_Spr"
"S_func_Epr_Spr = (S_func_Er_Sr.replace(Lk, 0).replace(d_exT, 0)
                  .replace(Sr, Spr).replace(Er, Epr))
S_func_Epr_Spr"
S_func_Er_Sr
"Sr_func_Er_S = solve(S_func_Er_Sr - S, Sr)[0]
Sr_func_Er_S"
"plt.plot(S_corr[idx], 'o')"
"plt.hist(t.ravel(), bins=50);"
"plt.hist(d1.ravel(), bins=40, histtype='step');
plt.yscale('log')
plt.title('$\{d_i\}\quad$ Mean = %.3e  Std.Dev. = %.3e ' % (d1.mean(), d1.std()));"
"kws = dict(bins=np.arange(0, 4, 0.05), histtype='step', lw=1.5, normed=True)
print('{:>8} {:>6} {:>8} {:>8}  {:>8}  {:>8} {:>8}'
      .format('c', 'n', 'Mean', 'Std', 'MSE', 'Median', '% > λ'))
for c in (-1, 0, 1/3, 1, 2, 3):
    r_hc = (n - c)  / d1.sum(axis=1) / λ
    r_hc_err_rms = np.sqrt(np.mean(((r_hc - 1)**2)))
    plt.hist(r_hc, **kws, label = 'c = %.1f' % c);
    print('%8.2f %6d %8.5f %8.2f%% %8.3f%% %8.3f %8.2f%%' % 
          (c, n, r_hc.mean(), r_hc.std()*100, r_hc_err_rms*100, np.median(r_hc),
           (r_hc > 1).sum() * 100 / num_iter))
    
r_hm = 1/np.median(d1, axis=1) / λ
r_hm_err_rms = np.sqrt(np.mean(((r_hm - 1)**2)))
plt.hist(r_hm, **kws, label = 'median');
print('%8s %6d %8.5f %8.2f%% %8.3f%% %8.3f %8.2f%%' % 
      ('median', n, r_hm.mean(), r_hm.std()*100, r_hm_err_rms*100, np.median(r_hm),
       (r_hm > 1).sum() * 100 / num_iter))
plt.xlabel('Normalized Rate')
plt.axvline(1, color='k');
plt.legend()
plt.text(0.35, 0.75, r'$\Lambda_{n,c} = \frac{n - c}{T_n}$',
         fontsize=24, transform=plt.gcf().transFigure);"
"kws = dict(bins=np.arange(0, 4, 0.05), histtype='step', lw=1.5, normed=True)
print('{:>6} {:>8} {:>8}  {:>8}  {:>8} {:>8}'
      .format('n', 'Mean', 'Std', 'Err.RMS', 'Median', '% > 1/λ'))
d_h = np.mean(d1, axis=1) * λ
d_h_err_rms = np.sqrt(np.mean(((d_h - 1)**2)))
plt.hist(d_h, **kws, label = r'$\hat\tau$');
print('%6d %8.5f %8.2f%% %8.3f%% %8.3f %8.2f%%' % 
      (n, d_h.mean(), d_h.std()*100, d_h_err_rms*100, np.median(d_h),
      (d_h > 1).sum() * 100 / num_iter))
plt.legend(fontsize=18)
plt.xlabel('Normalized Delays')
plt.axvline(1, color='k');"
"rate_t = 1 / ((d1.mean(axis=1)).cumsum() / np.arange(1, num_iter+1)) / λ

plt.plot(rate_t[100:])
plt.ylim(0.98, 1.02)
plt.axhline(1, color='k');"
"rate_t2 = ((n - 1) / d1.sum(axis=1)).cumsum() / np.arange(1, num_iter+1) / λ

plt.plot(rate_t2[100:])
plt.ylim(0.98, 1.02)
plt.axhline(1, color='k');"
"def show_bar(P):
    plt.figure(figsize=(9,7));
    # Wall.
    plt.axvline(0, color='g', lw=13);
    # Distance matrix.
    D = dist(P)
    # We plot the springs.
    for i, j in zip(I, J):
        # The color depends on the spring tension, which
        # is proportional to the spring elongation.
        c = D[i,j] - L[i,j]
        plt.plot(P[[i,j],0], P[[i,j],1], 
                 lw=2, color=plt.cm.copper(c*150));
    # We plot the masses.
    plt.plot(P[[I,J],0], P[[I,J],1], 'ok',);
    # We configure the axes.
    plt.axis('equal');
    plt.xlim(P[:,0].min()-e/2, P[:,0].max()+e/2);
    plt.ylim(P[:,1].min()-e/2, P[:,1].max()+e/2);
    plt.xticks([]); plt.yticks([]);

show_bar(P0);
plt.title(""Initial configuration"");"
energy(P0.ravel())
"show_bar(P1);
plt.title(""Equilibrium configuration"");"
"import warnings
warnings.filterwarnings('ignore')
import random
z = random.randint(1,42)
print(z)
"
ziehung()
"import warnings
warnings.filterwarnings('ignore')
from math import *
from scipy import optimize
import matplotlib.pyplot as plt
%matplotlib inline 
import numpy as np

def func2d(x):
    f = cos(14.5 * x[0] - 0.3) + (x[1] + 0.2) * x[1] + (x[0] + 0.2) * x[0]
    df = np.zeros(2)
    df[0] = -14.5 * sin(14.5 * x[0] - 0.3) + 2. * x[0] + 0.2
    df[1] = 2. * x[1] + 0.2
    return f, df

delta = 0.01
x = np.arange(-3.0, 3.0, delta)
y = np.arange(-2.0, 2.0, delta)
X, Y = np.meshgrid(x, y)
dim = X.shape

X_ = X.reshape(dim[0]*dim[1],1)
Y_ = Y.reshape(dim[0]*dim[1],1)



Z_ = []
for i in range(len(X_)):
    v = [X_[i],Y_[i]]
    y,dy = func2d(v)
    Z_.append(y)

Z = np.array(Z_).reshape(dim)
plt.figure(figsize=(20,10)) 
CS = plt.contour(X, Y, Z)

"
"from scipy.optimize import basinhopping
minimizer_kwargs = {""method"":""L-BFGS-B"", ""jac"":True}
x0 = [1.0, 1.0]
ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs, niter=200)

print(""global minimum: x = [%.4f, %.4f], f(x0) = %.4f"" % (ret.x[0], ret.x[1], ret.fun))
"
""
dir(random)
"import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline 

N = 2000000

X = np.random.random(N)
Y = np.random.random(N)
plt.figure(figsize=(9,9))
plt.ylim([0.1,0.2])
plt.xlim([0.1,0.2])
plt.plot(X,Y,'.')"
"import random

N = 2000000
X=[]
Y=[]
for i in range(N):
    X.append(random.random())
    Y.append(random.random())
    
plt.figure(figsize=(9,9))
plt.ylim([0.1,0.2])
plt.xlim([0.1,0.2])
plt.plot(X,Y,'.')
    "
"N = 20000
X=[]
Y=[]
for i in range(N):
    X.append(lcg())
    Y.append(lcg())
    
plt.figure(figsize=(9,9))
plt.ylim([0,1])
plt.xlim([0,1])
plt.plot(X,Y,'.')"
"from math import pi,sqrt,exp

N = 100

def f(x,sigma=0.15,mu=0.5):
    return 1/sigma/sqrt(2*pi)*exp(-1*(x-mu)**2/(2*sigma*sigma))

#print(1/sigma/sqrt(2*pi))
X = np.random.uniform(0.,1.,N)

Y = [] 
for i in range(len(X)):
    Y.append(f(X[i]))
plt.plot(X,Y,'.')"
"import random

N = 1000000

sigma = 0.15
X=[]

for i in range(N):
    x_ = random.random()
    scale = 1/sigma/sqrt(2*pi)
    s_ = scale*random.random()
    v = f(x_)
    if v > s_:
        X.append(x_)

    
    
plt.figure(figsize=(9,9))
#plt.ylim([0,1])
#plt.xlim([0,1])
plt.hist(X,100)"
"import warnings
warnings.filterwarnings('ignore')
from math import sin
import matplotlib.pyplot as plt
import numpy as np
%matplotlib inline

def f(x):
    return np.sin(x)-3*x**2+3.4*x**3-x**4

X = np.arange(0,1,0.02)
Y = f(X) 
plt.plot(X,Y)"
"np.random.seed(123)
n = 2000000
X = np.random.random(n)
Z = np.random.standard_normal(n)
Y = f(X)
res = sum(Y)/n
print('n:',n)
print('int:',res)


E = Y-res
E2 = E*E
sf = sum(E2)/(n-1)



print('sf:',sf)"
"plt.hist(Z,200)"
""
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
#%matplotlib qt

from pylab import rcParams
rcParams['figure.figsize'] = (10.0, 8.0) # set default size of plots
rcParams['image.interpolation'] = 'nearest'
rcParams['image.cmap'] = 'gray'

%load_ext autoreload
%autoreload 2"
"plt.plot(spending)
months = np.arange(len(spending))
ps = np.polyfit(months, spending, 1)
plt.plot(months, np.sum([p*months**(1-i) for i,p in enumerate(ps)], axis=0))"
ps
"def generate_tiles(level, start=0, end=1024):
    n = 2 ** level
    width = 1024 // n
    height = width
    indices = np.linspace(start, end, num=n, endpoint=False, dtype=int)
    for i, x0 in enumerate(indices):
        for j, y0 in enumerate(indices):
            yield i, j, width, height, x0 + 300, y0
        
for level in [0, 1, 2]:
    for tile in generate_tiles(level):
        i, j, width, height, x0, y0 = tile
        print(tile)
        filename = 'cat_{level}_{i}_{j}.mp4'.format(**locals())
        crop = ""crop={width}:{height}:{x0}:{y0}"".format(**locals())
        ! ffmpeg -y -i 6FUmapkqPn0.mp4 -filter:v ""$crop, scale=256:256"" -b 100000  -ss 00:01:40 -t 00:00:30 -an $filename

    "
"v = 1
periods = 2
frames_per = 50
Npoints = 100

x = np.linspace(-1,1,Npoints)
y = np.linspace(-1,1,Npoints)
X,Y = np.meshgrid(x,y)

def k(m,n):
    # jn_zeros(n, nt): Compute nt zeros of the Bessel function Jn(x).
    return jn_zeros(n,m)[m-1] # m is 0-indexed here

def generate(X, Y, t, n, m, v, f1, f2):
    theta = arctan2(Y,X) # This does arctan(Y/X) but gets the sign right.
    R = sqrt(X**2 + Y**2)
    # We know z = J_n(k*r)*cos(n*theta)*cos(k*v*t)
    # 
    f1 = {'sin':sin,'cos':cos}[f1]
    f2 = {'sin':sin,'cos':cos}[f2]

    result = jn(n,k(m,n)*R)*f1(n*theta)*f2(k(m,n)*v*t)
    result[R>1] = 0  # we plot points from the square, but physically require this.
    return result


def plot_frame(n=0,m=1,t=0,
              f1='cos',f2='cos',
              elev=20,azim=60,
              alpha=0.9):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    Z = generate(X,Y,t=t,n=n,m=m,v=v,f1=f1,f2=f2)
    #ax.plot_surface(X, Y, Z, rstride=4, cstride=4, alpha=0.3, cmap=cm.viridis, vmin=-1, vmax=1)
    ax.plot_surface(X, Y, Z, cmap=cm.viridis, vmin=-1, vmax=1, alpha=alpha)
    if n == 0:
        ax.set_zlim(-1,1)
    else:
        ax.set_zlim(-0.5,0.5)
    ax.view_init(elev=elev, azim=azim)
    plt.show()
_ = interact(plot_frame,t=(0,periods,periods/frames_per),
             n=(0,10),m=(1,10),
             f1=['sin','cos'],f2=['sin','cos'],
             elev=(-180,180,1),azim=(-180,180,1),
             alpha=(0,1,0.1),
            )"
"v = 1
periods = 2
frames_per = 50
Npoints = 100

x = np.linspace(-1,1,Npoints)
y = np.linspace(-1,1,Npoints)
X,Y = np.meshgrid(x,y)


def plot_frame2(t=0,nmax=1,mmax=2):
    # one period is 2*pi/jn_zeros(n,m)[m-1]
    #t = t*2*pi/jn_zeros(n,m)[m-1]
    ns = list(range(0,nmax))
    ms = list(range(1,mmax))
    fig = plt.figure(figsize=(6*len(ms),2*(len(ns))))
    
    axs = {}
    rows, cols = len(ns), 2*len(ms)

    idx = 1
    for m in ms:
        axs[m] = {}
        for n in ns:
            axs[m][n] = (fig.add_subplot(rows,cols,idx, projection='3d'),
                        fig.add_subplot(rows,cols,idx+1))
            idx += 2

    
    for m in ms:
        for n in ns:
            Z = generate(X, Y, t, n, m, v, 'cos', 'cos')
            axs[m][n][0].plot_surface(X, Y, Z, alpha=0.9, 
                                      cmap=cm.viridis, vmin=-0.7,vmax=0.7,)

            if n == 0:
                axs[m][n][0].set_zlim(-0.7,.7)
                axs[m][n][1].imshow(Z,vmin=-0.7,vmax=0.7, cmap=cm.viridis)
            else:
                axs[m][n][0].set_zlim(-0.5,0.5)
                axs[m][n][1].imshow(Z,vmin=-0.5,vmax=0.5, cmap=cm.viridis)
            # The funny business with levels here is because you won't
            # get a contour exactly at zero that necessarily tracks
            # around both sides of the circle due to the fact that
            # we've discretized things.
            levels = [-0.000000001,0.0,0.000000001]
            axs[m][n][1].contour(Z, levels, colors='k',
                                 linestyles='solid', linewidths=2)
    plt.show()
_ = interact(plot_frame2,t=(0,periods,periods/frames_per),
             nmax=(1,5),mmax=(2,5),
            )"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np, matplotlib as mpl, pandas as pd, seaborn as sns
from matplotlib import pyplot as plt
%matplotlib inline"
"atmos, terrestrial, ocean = 750, 600, 1000
a_t, a_o, t_o, o_a = 110, 40, 110, 150

time = 0
dt = 0.01

def evolve_system(time,dt,atmos,terrestrial,ocean,a_t,a_o,t_o,o_a):
    atmos, terrestrial, ocean = atmos - a_t - a_o + o_a, terrestrial - t_o + a_t, ocean - o_a + a_o + t_o
    return atmos, terrestrial, ocean

system_state = []
for step in range(1000):
    time = time + dt
    atmos, terrestrial, ocean = evolve_system(time,dt,atmos,terrestrial,ocean,a_t, a_o, t_o, o_a)
    system_state.append((time,atmos,terrestrial,ocean))

time = [i[0] for i in system_state]
atmos = [i[1] for i in system_state]
terrestrial = [i[2] for i in system_state]
ocean = [i[3] for i in system_state]

plt.plot(time,atmos,label='atmospheric carbon')
plt.plot(time,terrestrial,label='terrestrial carbon')
plt.plot(time,ocean,label='oceanic carbon')
plt.ylim([500,1100])
plt.legend()"
"atmos, terrestrial, ocean = 750, 600, 1000
a_t_rate, a_o_rate, t_o_rate, o_a_rate = 110/750, 40/750, 110/600, 150/1000

time = 0
dt = 1 # This is in years, based on what I've done above. You want dt in something smaller than years. How do you handle that?

def evolve_system(dt,atmos,terrestrial,ocean,a_t_rate,a_o_rate,t_o_rate,o_a_rate):
    a_t = a_t_rate * atmos * dt
    a_o = a_o_rate * atmos * dt
    t_o = t_o_rate * terrestrial * dt
    o_a = o_a_rate * ocean * dt
    atmos, terrestrial, ocean = atmos - a_t - a_o + o_a, terrestrial - t_o + a_t, ocean - o_a + a_o + t_o
    return atmos, terrestrial, ocean

system_state = []
for step in range(30):
    time = time + dt
    atmos, terrestrial, ocean = evolve_system(dt,atmos,terrestrial,ocean,a_t, a_o, t_o, o_a)
    system_state.append((time,atmos,terrestrial,ocean))

time = [i[0] for i in system_state]
atmos = [i[1] for i in system_state]
terrestrial = [i[2] for i in system_state]
ocean = [i[3] for i in system_state]

plt.plot(time,atmos,label='atmospheric carbon')
plt.plot(time,terrestrial,label='terrestrial carbon')
plt.plot(time,ocean,label='oceanic carbon')
#plt.ylim([500,1100])
plt.legend()"
plotit(dt=.1)
plotit(dt=.01)
plotit(dt=.001)
"x = np.linspace(0,100,1000)
y1 = 0.2*x + np.random.rand(1000)
y2 = 0.4*x + np.random.rand(1000)
y3 = 500*x + np.random.rand(1000)
plt.plot(x,y1,label='y1')
plt.plot(x,y2,label='y2')
plt.plot(x,y3,label='y3')
plt.legend()"
"x = np.linspace(0,100,1000)
y1 = 0.2*x + np.random.rand(1000)
y2 = 0.4*x + np.random.rand(1000)
y3 = 500*x + np.random.rand(1000)

fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)

ax1.plot(x,y1,label='y1')
ax1.plot(x,y2,label='y2')
ax2.plot(x,y3,label='y3')
plt.legend()"
"x = np.linspace(0,100,1000)
y1 = 0.2*x + np.random.rand(1000)
y2 = 0.4*x + np.random.rand(1000)
y3 = 500*x + np.random.rand(1000)

fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)

ax2.plot(x,y1,label='y1',color='blue')
ax2.plot(x,y2,label='y2',color='green')
ax1.plot(x,y3,label='y3',color='#aaef12')
ax1.legend()
ax2.legend()"
"dt = 0.01
atmos0, terrestrial0, ocean0 = 750, 600, 1000
a_t_rate, a_o_rate, t_o_rate, o_a_rate = dt*0.147, dt*0.053, dt*0.183, dt*0.15

from scipy import integrate

def simplemodel():
    # We make a vector X containing [atmos, terrestrial, ocean]
    # Here are our initial values
    init = [atmos0,terrestrial0,ocean0]
    def derivX(X,t):
        # Note that we have to take in `t` as a parameter, even though we don't use it.
        atmos, terrestrial, ocean = X
        a_t = a_t_rate * atmos
        a_o = a_o_rate * atmos
        t_o = t_o_rate * terrestrial
        o_a = o_a_rate * ocean
        # Just the derivatives here. Compare to the previous code!
        datmos = - a_t - a_o + o_a
        dterrestrial = - t_o + a_t
        docean = - o_a + a_o + t_o
        return np.array([atmos, terrestrial, ocean])

    # Look up the difference between np.arange and np.linspace
    time = np.arange(0,1,dt) 

    # Let scipy.integrate.odeint do all the work for us!
    X = integrate.odeint(derivX,init,time)
    atmos, terrestrial, ocean = X[:,0], X[:,1], X[:,2]

    plt.plot(time,atmos,label='atmospheric carbon')
    plt.plot(time,terrestrial,label='terrestrial carbon')
    plt.plot(time,ocean,label='oceanic carbon')
    plt.legend()
simplemodel()"
"t = np.linspace(0,100,1000)
alpha = 0.2
x = alpha*t
plt.plot(t,x)"
"x = linspace(0,L,100)
plt.plot(x,f(x,1.0))
plt.show()"
"interact(plotspread,sigma=(0.01,100.1,1),L=(0.1,10,.1),kappa=(0,50,.1),h0=(0,10,.2))"
"plt.plot(x,xfact,label='our def')
plt.plot(x,sp.special.gamma(x+1),label='gamma')
plt.legend()"
"plt.plot(x,xfact,label='our def')
plt.plot(x,sp.special.gamma(x+1),label='gamma')
plt.legend()

plt.xlim((8.9,9.1))
plt.ylim((250000,500000))"
"plt.plot(x,xfact - sp.special.gamma(x+1),label='diff')
plt.legend()

#plt.xlim((9.5,10))"
"x = np.linspace(1,10,20000)
xfact = [fact(i) for i in x]
plt.plot(x,np.log(xfact),label='our def')
plt.plot(x,np.log(sp.special.gamma(x+1)),label='gamma')
plt.legend()"
"_ = interact(T,N=(1,20,1),x=(0,10,0.1),y=(0,30,0.1))"
"def plotX(N=0,y=0):
    x = np.linspace(0,10,100)
    plt.plot(T(N,x,y))
    plt.show()
_ = interact(plotX,N=(1,20,1),y=(0,30,0.1))"
"def plotY(N=0,x=0):
    y = np.linspace(0,30,300)
    plt.plot(T(N,x,y))
    plt.show()
_ = interact(plotY,N=(1,20,1),x=(0,10,0.1))"
"x = np.linspace(0,10,100)
y = np.linspace(0,30,300)
X,Y = np.meshgrid(x,y)
fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(X,Y,T(10,X,Y))
plt.show()"
"degree_step = 1
def plotT3D(N=1,elev=0,ymax=30,azim=0):
    x = np.linspace(0,10,100)
    y = np.linspace(0,ymax,300)
    X,Y = np.meshgrid(x,y)
    fig = plt.figure()
    ax = fig.gca(projection='3d')
    surf = ax.plot_surface(X,Y,T(N,X,Y))
    ax.view_init(elev=elev,azim=azim)    
    plt.show()
_ = interact(plotT3D,N=(0,200,1),ymax=(10,30,1),azim=(0,360,degree_step),elev=(0,360,degree_step))"
"# Number of points
N = 600
# sample spacing
T = 1.0/800.0
# linspace gives N evenly spaced points between the start and stop values.
x = np.linspace(0.0,N*T,N)
# That returns a numpy array.
print(x[:10]) # here are the first 10 points"
"plt.plot(x,y)
plt.xlabel('$x$')
plt.ylabel('$\sin(50 \\times 2 \pi x) + 0.5\sin(80\\times 2\pi x)$')"
"# Now take the FFT
yf = fft(y)
# You should understand the spacing here. 
# As far as why you only want half of the points, see the documentation.
# No, really, see the documentation. Maybe even `fftshift`.
xf = np.linspace(0.0, 1.0/(2.0*T), N//2)
plt.plot(xf, 2.0/N * np.abs(yf[0:N//2]))
# Question for you: what should the axis labels be?"
print(data)
"# you'll have to read the docs to figure out what `rate` is, 
# but here's me plotting the signal directly.
plt.plot(data)"
"dt = 0.0005
t = np.arange(0.0, 20.0, dt)
s1 = np.sin(2*np.pi*100*t)
s2 = 2*np.sin(2*np.pi*400*t)

# create a transient ""chirp""
mask = np.where(np.logical_and(t > 10, t < 12), 1.0, 0.0)
s2 = s2 * mask

# add some noise into the mix
nse = 0.01*np.random.random(size=len(t))

x = s1 + s2 + nse  # the signal
NFFT = 1024       # the length of the windowing segments
Fs = int(1.0/dt)  # the sampling frequency

# Pxx is the segments x freqs array of instantaneous power, freqs is
# the frequency vector, bins are the centers of the time bins in which
# the power is computed, and im is the matplotlib.image.AxesImage
# instance

ax1 = plt.subplot(211)
plt.plot(t, x)
plt.subplot(212, sharex=ax1)
Pxx, freqs, bins, im = plt.specgram(x, NFFT=NFFT, Fs=Fs, noverlap=900,
                                cmap=plt.cm.gist_heat)
plt.grid(False) # Hard to interpret with the grid on. "
"dt = 0.0005
t = np.arange(0.0, len(data)*dt, dt)
s1 = np.sin(2*np.pi*100*t)
s2 = 2*np.sin(2*np.pi*400*t)

# create a transient ""chirp""
mask = np.where(np.logical_and(t > 10, t < 12), 1.0, 0.0)
s2 = s2 * mask

# add some noise into the mix
nse = 0.01*np.random.random(size=len(t))

x = s1 + s2 + nse  # the signal
NFFT = 1024       # the length of the windowing segments
Fs = int(1.0/dt)  # the sampling frequency

# Pxx is the segments x freqs array of instantaneous power, freqs is
# the frequency vector, bins are the centers of the time bins in which
# the power is computed, and im is the matplotlib.image.AxesImage
# instance

ax1 = plt.subplot(211)
plt.plot(t, data)
plt.subplot(212, sharex=ax1)
Pxx, freqs, bins, im = plt.specgram(data, NFFT=NFFT, Fs=Fs, noverlap=900,
                                cmap=plt.cm.gist_heat)
plt.grid(False) # Hard to interpret with the grid on. "
plt.plot(data[:1000])
"print('Exact',exact(1/2))
print('estimate',estimate(1/2))
print('error',error(1/2))"
"x = np.linspace(0,1,100)
plt.plot(x,error(x),label='actual error')
plt.plot(x,error_bound(x),label='14.3 bound')
plt.plot(x,error_bound2(x),label='14.4 bound')
plt.legend();"
"x = np.linspace(0,1/2,100)
plt.plot(x,error(x),label='actual error')
plt.plot(x,error_bound(x),label='14.3 bound')
plt.plot(x,error_bound2(x),label='14.4 bound')
plt.legend();"
"plt.plot(x,x,label='term 1')
plt.legend(fancybox=True);"
"plt.plot(x,x,label='term 1')
plt.plot(x,x-x**3/6,label='term 1 and 3')
plt.legend(fancybox=True);"
"plt.plot(x,x,label='term 1')
plt.plot(x,x-x**3/6,label='term 3')
plt.axis((-pi,pi,-4,4))
plt.legend(fancybox=True);"
"def showterms(n=0,xmax=4*pi):
    x = linspace(-xmax,xmax,2000)
    total = zeros_like(x)
    plt.clf()
    plt.plot(x,np.sin(x),'.-',linewidth=4,color='red',label='sin(x)')
    for i in range(n+1):
        this_term = ((-1)**i * x**(1+2*i))/factorial(1+2*i)
        plt.plot(x,this_term,label='Term {i}'.format(i=i))
        total = total + this_term
    plt.plot(x,total,'--',linewidth=2,color='black',label='Sum')
    plt.axis((-xmax,xmax,-4,4))
    plt.grid(True)
    plt.legend(fancybox=True,loc='upper left',framealpha=0.5)
interact(showterms,n=(0,8),xmax=fixed(2*pi));"
"x = np.linspace(0,2*np.pi,100)
xgas = np.random.rand(100,10)*2*np.pi

def plotit(t=1.5):
    k = 1
    w = 1
    displacement = np.sin(k*x)*np.cos(w*t)
    pressure = np.cos(k*x)*np.cos(w*t)
    plt.subplot(2,1,2)
    plt.ylim(-1.1,1.1)
    plt.plot(x,displacement,'k-',label='$\Delta x$')
    plt.plot(x,pressure,'r-',label='$\Delta p$')
    plt.legend()
    plt.subplot(2,1,1)
    ygas = np.linspace(-1,1,xgas.shape[-1]) * np.ones_like(xgas)
    displacement = (np.pi/2)*np.sin(k*xgas)*np.cos(w*t)
    plt.scatter(xgas,ygas,facecolors='none')
    plt.scatter(xgas + displacement,ygas)
    plt.xlim(-.5,1.1*2*np.pi)
interact(plotit,t=(0,10,0.1))"
"def plot_airy1(n=1):
    a0 = 1
    x = np.linspace(-12,5,10000)
    y = np.zeros_like(x)
    for i,coeff in enumerate(get_y1_coeffs(n)):
        y = y + (x**i)*coeff
    plt.plot(x,y,'k--',label=""First {n} terms"".format(n=n))
    #plt.plot(x,sp.special.airy(x)[2]+sp.special.airy(x)[3],label=""full solution (ish)"")
    #plt.plot(x,sp.special.airy(x)[0],label='0')
    #plt.plot(x,sp.special.airy(x)[1],label='1')
    #plt.plot(x,sp.special.airy(x)[2],label='2')
    #plt.plot(x,sp.special.airy(x)[3],label='3')
    plt.axis([-12,5,-3,3])
    
    plt.legend()

interact(plot_airy1,n=(0,100));"
"def plot_airy1(n=1):
    a0 = 1
    x = np.linspace(-12,5,10000)
    y = np.zeros_like(x)
    for i,coeff in enumerate(get_y1_coeffs(n)):
        y = y + (x**i)*coeff
    plt.plot(x,y,'k--',label=""First {n} terms"".format(n=n))
    #plt.plot(x,sp.special.airy(x)[2]+sp.special.airy(x)[3],label=""full solution (ish)"")
    #plt.plot(x,sp.special.airy(x)[0],label='0')
    #plt.plot(x,sp.special.airy(x)[1],label='1')
    #plt.plot(x,sp.special.airy(x)[2],label='2')
    #plt.plot(x,sp.special.airy(x)[3],label='3')
    plt.axis([-12,5,-3,3])
    
    plt.legend()

interact(plot_airy1,n=(0,100))"
"nep = 1.21e-12
BW = 260e3
gain = 2.38e4
responsivity = 0.5
pmin = nep * np.sqrt(BW)
volts_min = pmin * responsivity * gain
print(volts_min)"
"# resolvable power:
pmin * scope_floor_factor"
"nep = 0.2e-12
BW = 50e6
gain = 50000
responsivity = 25
pmin = nep * np.sqrt(BW)
volts_min = pmin * responsivity * gain
print(volts_min)
scope_floor_factor = 0.010/volts_min

# resolvable power:
pmin * scope_floor_factor"
"# Enter the specs of the detector
nep = 2.34e-12  # in Watts per root hz
BW = 10e6  # Bandwidth in Hz
gain = 0.75e4  # gain in V/A
responsivity = 0.5  # Amps per Watt (assume 800 nm)
pmin = nep * np.sqrt(BW)
volts_min = pmin * responsivity * gain
print(""voltage generated by p_min:"",volts_min)"
"# the power has to be scope_floor_factor times larger in order to generate 10mV:
pmin * scope_floor_factor"
"import warnings
warnings.filterwarnings('ignore')
%matplotlib notebook
import pandas as pd  
import matplotlib.pyplot as plt  
from ipywidgets import *  
from IPython.display import display  
import ipywidgets  
plt.style.use('ggplot')

NUMBER_OF_PINGS = 4

#displaying the text widget
text = widgets.Text(description=""Domain to ping"", width=200)  
display(text)

#preparing the plot 
data = pd.DataFrame()  
x = range(1,NUMBER_OF_PINGS+1)  
plots = dict()  
fig, ax = plt.subplots()  
plt.xlabel('iterations')  
plt.ylabel('ms')  
plt.xticks(x)  
plt.show()

#preparing a container to put in created checkbox per domain
checkboxes = []  
cb_container = widgets.HBox()  
display(cb_container)

#add button that updates the graph based on the checkboxes
button = widgets.Button(description=""Update the graph"")

#function to deal with the added domain name
def handle_submit(sender):  
    #a part of the magic inside python : pinging
    res = !ping -c {NUMBER_OF_PINGS} {text.value}
    print(res)
    hits = res.grep('64 bytes').fields(-2).s.replace(""time="","""").split()
    if len(hits) == 0:
        print(""Domain gave error on pinging"")
    else:
         #rebuild plot based on ping result
        data[text.value] = hits
        data[text.value] = data[text.value].astype(float)
        plots[text.value], = ax.plot(x, data[text.value], label=text.value)
        plt.legend()
        plt.draw()
        #add a new checkbox for the new domain
        checkboxes.append(widgets.Checkbox(description = text.value, value=True, width=90))
        cb_container.children=[i for i in checkboxes]
        if len(checkboxes) == 1:
            display(button)

#function to deal with the checkbox update button       
def on_button_clicked(b):  
    for c in cb_container.children:
        if not c.value:
            plots[c.description].set_visible(False)
        else:
            plots[c.description].set_visible(True)
    plt.legend()
    plt.draw()

button.on_click(on_button_clicked)  
text.on_submit(handle_submit)  
plt.show()  "
"import numpy as np
from scipy.special import gamma
import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 22})

x = 1
ns = []; errs = [];
for n in range(30):
    ns.append(n)
    errs.append(abs(np.exp(x) - myexp(x, n)))
ns = np.array(ns)

plt.figure(figsize=(18, 10))
plt.semilogy(ns, errs, 'k.', ms=16)
plt.semilogy(ns, max(1, np.exp(x)) * x**ns / gamma(ns+1), 'r', lw=3)
plt.ylim([1e-18, 1])
plt.xlabel('$n$')
plt.ylabel('$\\varepsilon$')
plt.title('Error for $e^{%g}$' % x)
plt.show()"
"from scipy.special import loggamma
ns = []; errs = [];
x = -30
for n in range(0, 150, 5):
    ns.append(n)
    errs.append(abs(np.exp(x) - myexp(x, n)))
ns = np.array(ns)
plt.figure(figsize=(18, 10))
plt.semilogy(ns, errs, 'k.', ms=16)
plt.semilogy(ns, max(1, np.exp(x)) * np.exp(ns * np.log(abs(x)) \
                            - np.real(loggamma(ns+1))), 'r-', lw=3)
plt.ylim([1e-16, 1e12])
plt.title('Error for $e^{%g}$' % x)
plt.xlabel('$n$')
plt.ylabel('$\\varepsilon$')
plt.show()"
"hs = np.logspace(-16, 0, num=50) # h = 1e-16 ... 1
errs1 = []
errs2 = []
for h in hs:
    errs1.append(abs(diff1(np.sin, 1, h) - np.cos(1)))
    errs2.append(abs(diff2(np.sin, 1, h) - np.cos(1)))

M2 = M3 = 1
plt.figure(figsize=(18, 10))
plt.loglog(hs, errs1, 'k.', ms=16)
plt.loglog(hs, errs2, 'r.', ms=16)
plt.loglog(hs, M2 * hs / 2, 'k-', label='First order', lw=3)
plt.loglog(hs, M3 * hs**2 / 6, 'r-', label='Second order', lw=3)
plt.ylim(1e-14, 1)
plt.xlabel('$h$')
plt.ylabel('$\\varepsilon$')
plt.legend(loc='upper center')
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
from numpy.linalg import norm, inv

def nu(A, b, kind = np.inf):
    return norm(inv(A), kind) * norm(b, kind) / norm(inv(A).dot(b), kind)

eps = 0.0001
A = np.array([[1, 2], [2, 4 + eps]])
b = np.array([1, 2])
print('nu_inf(A, b) =', nu(A, b, np.inf))
print('nu_1(A, b) =', nu(A, b, 1))
print('nu_E(A, b) =', nu(A, b, 2))"
"def mu(A, kind = np.inf):
    return norm(inv(A), kind) * norm(A, kind)

eps = 0.0001
A = np.array([[1, 2], [2, 4 + eps]])
print('mu_inf(A) =', mu(A, np.inf))
print('mu_1(A) =', mu(A, 1))
print('mu_E(A) =', mu(A, 2))"
"from scipy.linalg import solve_banded

a =  np.array([0, 1, 1, 1, 1, 1, 1, 1])
b = -np.array([2, 2, 2, 2, 2, 2, 2, 2])
c =  np.array([1, 1, 1, 1, 1, 1, 1, 0])
f = -np.array([1, 1, 1, 1, 1, 1, 1, 1])
x = solve_tdm(a, b, c, f)
print('TDM solver: x=', x)

G = np.zeros((3, len(a)))
G[0, 1:]  = c[:-1]
G[1, :]   = b
G[2, :-1] = a[1:]
x_scipy = solve_banded((1, 1), G, f)
print('SciPy banded solver: x=', x_scipy)"
"from scipy.linalg import lu, solve_triangular
def lu_solve(A, f):
    P, L, U = lu(A) # A = P L U
    y = solve_triangular(L, P.T.dot(f), lower=True, unit_diagonal=True)
    x = solve_triangular(U, y, lower=False, unit_diagonal=False)
    return x

n = 4
x0 = np.ones(n)
A = np.random.rand(n, n)
f = A.dot(x0)
x = lu_solve(A, f)
print('x = ', x)
lu(A)"
"import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 22})

A = np.array([[1, 2, 3], [2, 5, 7], [3, 7, 15]])
xstar = np.array([1, 2, 3])
f = A.dot(xstar)
x0 = np.array([0, 0, 0])

print('lambda(A) =', np.linalg.eigvalsh(A))

tau = 0.12
print('tau =', tau)
x, res = simple_iteration(A, f, x0, tau)
plt.figure(figsize=(12,8))
plt.semilogy(res)
plt.xlabel('$k$')
plt.ylabel('$\|r_k\|$')
plt.show()"
"print('lambda(A) =', np.linalg.eigvalsh(A))

tau = 0.1
print('tau =', tau)
x, res = simple_iteration(A, f, x0, tau, maxit=10000)
plt.figure(figsize=(12,8))
plt.semilogy(res)
plt.xlabel('$k$')
plt.ylabel('$\|r_k\|$')
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 18})

lmin = 1
lmax = 5
lamA = np.linspace(lmin, lmax, 20)
tau_opt = 2 / (lmin + lmax)
tau_max = 2 / lmax
taus = [tau_opt / 2, tau_opt, tau_max, 1.1 * tau_max]
q_opt = (lmax - lmin) / (lmax + lmin)
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111)
for tau in taus:
    ax.plot([0, lmax+1], [1, 1 - tau * (lmax+1)], 'k')
    ax.plot(lamA, 1 - tau * lamA, lw=3, label = '$\\tau = %g$' % tau)
ax.plot([0, lmax+1], [1, 1], 'r-')
ax.plot([0, lmax+1], [-1, -1], 'r-')
ax.plot([lmin, lmin], [-1.1, 1.1], 'k--')
ax.plot([lmax, lmax], [-1.1, 1.1], 'k--')
ax.plot([0, lmax+1], [q_opt, q_opt], 'g-')
ax.plot([0, lmax+1], [-q_opt, -q_opt], 'g-')
ax.annotate('$q_\\operatorname{opt}$', (0.05, q_opt-0.1))
ax.annotate('$-q_\\operatorname{opt}$', (0.05, -q_opt-0.1))
ax.annotate('$\\lambda_\\operatorname{min}$', (lmin+0.05, -1.05))
ax.annotate('$\\lambda_\\operatorname{max}$', (lmax+0.05, -1.05))

ax.set_xlim([0, lmax+1])
ax.set_ylim([-1.1, 1.1])
ax.set_xlabel('$\\lambda(A)$')
ax.set_ylabel('$\\lambda(B)$')
ax.legend(bbox_to_anchor=(1.5, 1))
plt.show()"
"n = 10
A = np.random.rand(n, n) # берем случаную матрицу
A = A + np.diag(A.sum(axis=1)) # и делаем ей диагональное преобладание
x = np.ones(n) # точное решение
f = A.dot(x)
x0 = np.zeros_like(x)
xres, it = jacobi(A, f, x0)
print('Done in %d iterations' % it)
print('||x - x_res|| =', np.linalg.norm(xres - x))"
"n = 10
A = np.random.rand(n, n)
# Делаем случайную симметричную матрицу
A = A.T.dot(A) 
# Добавим немного единичной матрицы для лучшей обусловленности A
A = 0.1 * np.eye(n) + A

x = np.ones(n)
f = A.dot(x)
x0 = np.zeros_like(x)
xres, it = seidel(A, f, x0)
print('Done in %d iterations' % it)
print('||x - x_res|| =', np.linalg.norm(xres - x))"
"n = 30
A = np.diag(2.001 * np.ones(n)) - np.diag(np.ones(n-1), k=-1) - np.diag(np.ones(n-1), k=1)
D = np.diag(np.diag(A))
B_J = np.linalg.solve(D, A - D)
rho_B_J = np.abs(np.linalg.eigvals(B_J)).max()
omega = 2 / (1 + np.sqrt(1 - rho_B_J**2))

x = np.ones(n)
f = A.dot(x)
x0 = np.zeros_like(x)
xres, it = seidel(A, f, x0)
xres2, it2 = sor(A, f, x0, omega)
print('Seidel done in %d iterations' % it)
print('SOR done in %d iterations' % it2)
print('Seidel ||x - x_res|| =', np.linalg.norm(xres - x))
print('SOR ||x - x_res|| =', np.linalg.norm(xres2 - x))"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 14})

x = np.linspace(0, 5, 21)
y = 3*x+5 + 0.5*np.random.randn(len(x))
A = np.zeros((len(x), 2))
A[:, 0] = x
A[:, 1] = 1
f = y
a,b = np.linalg.solve(A.T.dot(A), A.T.dot(f))
plt.plot(x, y, '.')
plt.plot(x, a*x+b, '-')
plt.title('$%g + %g x$' % (a,b))
plt.show()"
"n = 21
x = np.linspace(0, 5, n)
y = 2 + 3 * x + 0.5 * x**2 + 0.2 * np.random.randn(len(x))
A = np.zeros((n, 3))
A[:, 0] = 1
A[:, 1] = x
A[:, 2] = x**2
f = y
a,b,c = np.linalg.solve(A.T.dot(A), A.T.dot(f))
plt.plot(x, y, '.')
plt.plot(x, a+b*x+c*x**2, '-')
plt.title('$%g + %g x + %g x^2$' % (a,b,c))
plt.show()"
"from scipy.integrate import quad
a = 0; b = 4; n = 8
def func(x): return np.sin(np.pi * x)
G = np.zeros((n, n))
g = np.zeros(n)
for i in range(n):
    for k in range(n):
        G[i, k], _ = quad(lambda x: x**(i+k), a, b)
    g[i], _ = quad(lambda x: x**i * func(x), a, b)

c = np.linalg.solve(G, g)
X = np.linspace(a, b, 100)
fig = plt.figure(figsize=(12, 5))
ax = fig.add_subplot(121)
ax.plot(X, func(X), 'r', lw=2)
ax.plot(X, np.array([c[i]*X**i for i in range(n)]).sum(axis=0), 'b', lw=2)
ax.set_title('$f(x), P_{%d}(x)$' % (n-1))
ax = fig.add_subplot(122)
ax.plot(X, func(X) - np.array([c[i]*X**i for i in range(n)]).sum(axis=0), 'g', lw=3)
ax.set_title('$f(x) - P_{%d}(x)$' % (n-1))
plt.show()"
"from scipy.linalg import hilbert, svdvals
def cond2(A):
    s = svdvals(A);
    return s[0] / s[-1]
for n in range(5, 31, 5):
    H = hilbert(n)
    print('n = %d, mu_2(H_n) = %e' % (n, cond2(H)))"
"from scipy.special import legendre
x = np.linspace(-1, 1, 1000)
for k in range(6):
    plt.plot(x, legendre(k)(x), label='$P_{%d}(x)$' % k, lw=2)
plt.title('Legendre polynomials')
plt.ylim(-1.1, 1.1)
plt.legend(bbox_to_anchor=(1.4, 1.05))
plt.show()"
"a = -1; b = 1; n = 8
def func(x): return np.sin(2 * np.pi * x)
g = np.zeros(n)
A = np.zeros(n)
for k in range(n):
    g[k], _ = quad(lambda x: legendre(k)(x) * func(x), a, b)
    A[k] = 2 / (2*k+1)
c = g / A
X = np.linspace(a, b, 100)
fig = plt.figure(figsize=(12, 5))
ax = fig.add_subplot(121)
ax.plot(X, func(X), 'r', lw=2)
ax.plot(X, np.array([c[i]*legendre(i)(X) for i in range(n)]).sum(axis=0), 'b', lw=2)
ax.set_title('$f(x), P_{%d}(x)$' % (n-1))
ax = fig.add_subplot(122)
ax.plot(X, func(X) - np.array([c[i]*legendre(i)(X) for i in range(n)]).sum(axis=0), 'g', lw=3)
ax.set_title('$f(x) - P_{%d}(x)$' % (n-1))
plt.show()"
"from scipy.special import chebyt
x = np.linspace(-1, 1, 1000)
for k in range(5):
    plt.plot(x, chebyt(k)(x), label='$T_{%d}(x)$' % k, lw=2)
plt.title('Chebyshev polynomials')
plt.legend(bbox_to_anchor=(1.4, 1.05))
plt.ylim(-1.1, 1.1)
plt.show()"
"a = -1; b = 1; n = 8
def func(x): return np.sin(2 * np.pi * x)
g = np.zeros(n)
A = np.zeros(n)
for k in range(n):
    g[k], _ = quad(lambda x: chebyt(k)(x) * func(x) / np.sqrt(1 - x**2), a, b)
    A[k] = np.pi / 2 if k > 0 else np.pi
c = g / A
X = np.linspace(a, b, 100)
fig = plt.figure(figsize=(12, 5))
ax = fig.add_subplot(121)
ax.plot(X, func(X), 'r', lw=2)
ax.plot(X, np.array([c[i]*chebyt(i)(X) for i in range(n)]).sum(axis=0), 'b', lw=2)
ax.set_title('$f(x), P_{%d}(x)$' % (n-1))
ax = fig.add_subplot(122)
ax.plot(X, func(X) - np.array([c[i]*chebyt(i)(X) for i in range(n)]).sum(axis=0), 'g', lw=3)
ax.set_title('$f(x) - P_{%d}(x)$' % (n-1))
plt.show()"
"import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 14})
x = np.linspace(-2. + 0.001, 3, 1000);
plt.figure(figsize=(7,4))
plt.plot(x, x, 'r', label='$x$');
plt.plot(x, np.log(x + 2), 'g', label='$\ln(x+2)$');
plt.grid()
plt.legend(loc='upper left')
plt.ylim(-3, 3)
plt.show()"
"from scipy.optimize import fsolve

def phi(x):
    return np.log(x + 2)

x = 1.5
for i in range(10):
    x = phi(x)
    
[xtrue] = fsolve(lambda x: x - phi(x), 1.5, xtol=1e-20)
print('x =', x, ', x* =', xtrue)
print('x - x* =', x - xtrue)"
"x0 = -1.84140
x = x0
for i in range(10):
    x = phi(x)
    
[xtrue] = fsolve(lambda x: x - phi(x), x0, xtol=1e-20)
print('x =', x, ', x* =', xtrue)
print('x - x* =', x - xtrue)"
"def phi2(x):
    return np.exp(x) - 2

x0 = -1.45
x = x0
for i in range(10):
    x = phi2(x)
    
[xtrue] = fsolve(lambda x: x - phi2(x), x0, xtol=1e-20)
print('x =', x, ', x* =', xtrue)
print('x - x* =', x - xtrue)"
"def f(x):
    return (x-1)*(x+2)**2
def fprime(x):
    return 3 * x * (x+2)

x0 = 2.8
x = [x0]
n = 3
for i in range(n):
    x.append(x[-1] - f(x[-1]) / fprime(x[-1]))
    
X = np.linspace(0, 3, 1000)
plt.figure(figsize=(7, 4))
plt.plot(X, f(X), 'b')
plt.plot(X, 0*X, 'k')
for i in range(n):
    plt.plot([x[i], x[i]], [0, f(x[i])], 'g')
for i in range(n+1):    
    plt.annotate('$x_{%d}$' % i, xy=(x[i]-0.05, -3))
for i in range(n):
    plt.plot([x[i], x[i+1]], [f(x[i]), 0], 'r')

plt.grid()"
"def f(x):
    return (x-1)**2 * (x+2)
def fprime(x):
    return 3 * (x**2 - 1)

x0 = 2.8
x = [x0]
n = 4
for i in range(n):
    x.append(x[-1] - f(x[-1]) / fprime(x[-1]))
    
X = np.linspace(0, 3, 1000)
plt.figure(figsize=(7, 4))
plt.plot(X, f(X), 'b')
plt.plot(X, 0*X, 'k')
for i in range(n):
    plt.plot([x[i], x[i]], [0, f(x[i])], 'g')
for i in range(n+1):    
    plt.annotate('$x_{%d}$' % i, xy=(x[i]-0.05, -1))
for i in range(n):
    plt.plot([x[i], x[i+1]], [f(x[i]), 0], 'r')
plt.ylim(-3, 20)

plt.grid()"
"t = np.linspace(0, 1, 10)
plt.figure(figsize=(8, 6))
plt.plot(np.cos(t), t, 'r', label='$x = \cos(y)$', lw=2)
plt.plot(t, np.sin(t), 'b', label='$y = \sin(x)$', lw=2)
plt.xlabel('$x$')
plt.ylabel('$y$')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.axis('square')
plt.show()"
"def phi(x, y):
    return np.cos(y), np.sin(x)

x, y = 0.8, 0.8
for i in range(1, 91):
    x, y = phi(x, y)
    if i % 10 == 0: print('it =', i, 'x =', x, 'y =', y)"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 14})

n = 9
h = 0.2 + np.random.rand(n)
x = np.cumsum(h)
x -= x[0]
x /= x[-1]
a = 2 * np.pi
x = a * (2 * x - 1)

def f(x):
    return np.sin(x)
fv = f(x)

W = np.empty((n, n))
for k in range(n):
    W[:, k] = x**k
c = np.linalg.solve(W, fv)

X = np.linspace(-a, a, 1000)
P = lambda x: np.polyval(list(reversed(c)), x)

plt.plot(X, f(X), 'r', label='$f(x)$')
plt.plot(X, P(X), 'b', label='$P_{%d}(x)$' % (n-1))
plt.plot(x, fv, 'g.', ms=10, label='$f(x_k)$')
plt.axis([-a, a, -1.2, 1.2])
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.show()"
"def divided_differences(x, f):
    n = len(x);
    F = np.empty((n, n))
    F[:, 0] = f
    for k in range(1, n):
        F[0:n-k, k] = (F[1:n-k+1, k-1] - F[0:n-k, k-1]) / (x[k:] - x[:-k])
    return F # F[i, k] = f(x_i, x_{i+1}, ..., x_{i+k})

x = np.array([1, 2, 4, 5])
f = np.array([1, 3, 1, 3])
F = divided_differences(x, f)
print(F)"
"def evaluate(x, F, x0):
    n = len(x);
    P = 0;
    xprod = 1.0 # (x - x1) (x - x2) ... (x - xi)
    for i in range(n):
        P += F[0, i] * xprod
        xprod *= (x0 - x[i])
    return P

X = np.linspace(0.5, 5.5, 1000)
plt.plot(X, evaluate(x, F, X), 'r', lw=2, label='$P(x)$')
plt.plot(x, f, 'g.', ms=15, label='$f(x_i)$')
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"n = 5
x = np.cumsum(0.5 + np.random.rand(n))
X = np.linspace(x[0], x[-1], 1000)
for i in range(n):
    v = np.eye(n)[i]
    F = divided_differences(x, v)
    plt.plot(X, evaluate(x, F, X), label='$\ell_{%d}(x)$' % (i+1), lw=2)
    plt.plot(x, v, 'k.', ms=10)
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"def runge(x):
    return 1 / (1 + 25 * x**2)

X = np.linspace(-1, 1, 1000)

plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 5
x = np.linspace(-1, 1, n)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 10
x = np.linspace(-1, 1, n)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 15
x = np.linspace(-1, 1, n)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 20
x = np.linspace(-1, 1, n)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"X = np.linspace(-1, 1, 1000)
x = np.linspace(-1, 1, 10)
omega = (X - x[0]);
for i in range(1, len(x)):
    omega *= (X - x[i])
plt.plot(X, omega, 'b', lw=2, label='$\omega(x)$')
plt.plot(X, 0*X, 'k')
plt.grid()
plt.legend(loc='center left', bbox_to_anchor=(1,.5)); plt.show()"
"X = np.linspace(-1, 1, 1000)
x = np.cos((2*np.arange(10)+1) / 20 * np.pi)
omega = (X - x[0]);
for i in range(1, len(x)):
    omega *= (X - x[i])
plt.plot(X, omega, 'b', lw=2, label='$\omega(x)$')
plt.plot(X, 0*X, 'k')
plt.grid()
plt.legend(loc='center left', bbox_to_anchor=(1,.5)); plt.show()"
"def runge(x):
    return 1 / (1 + 25 * x**2)

X = np.linspace(-1, 1, 1000)

plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 5
x = np.cos((np.arange(n)*2+1) / (2*n) * np.pi)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 10
x = np.cos((np.arange(n)*2+1) / (2*n) * np.pi)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 15
x = np.cos((np.arange(n)*2+1) / (2*n) * np.pi)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"plt.figure(figsize=(10, 8))
plt.plot(X, runge(X), 'r', label='$f(x)$', lw=2)
n = 20
x = np.cos((np.arange(n)*2+1) / (2*n) * np.pi)
F = divided_differences(x, runge(x))
plt.plot(X, evaluate(x, F, X), label='$P_{%d}(x)$' % (n-1), lw=2)
plt.axis([-1, 1, -1, 2]); 
plt.legend(loc='center left', bbox_to_anchor=(1, .5)); plt.show()"
"def ell(i, x, xs):
    A = np.array([(x-xs[k])/(xs[i]-xs[k]) for k in range(len(xs)) if i != k])
    return np.prod(A, axis=0)

def L(x, xs):
    return np.sum([np.abs(ell(i, x, xs)) for i in range(len(xs))], axis=0)

X = np.linspace(-np.pi, np.pi, 1000)
x = np.linspace(-np.pi, np.pi, 9)

plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1);
plt.plot(X, L(X, x), lw=2)
plt.xlabel('$x$')
plt.ylabel('$L(x)$')
plt.xlim(-np.pi, np.pi)
plt.ylim(0, None)

fv = np.sin(x)
delta = 0.15
fvs = fv + delta * np.tanh(10 * np.random.rand(len(fv)) - 5)

plt.subplot(1, 2, 2);
F = divided_differences(x, fv)
Fs = divided_differences(x, fvs)
plt.plot(X, evaluate(x, F, X), 'b', label='$P(x)$', lw=2)
up = evaluate(x, F, X) + delta * L(X, x)
down = evaluate(x, F, X) - delta * L(X, x)
plt.fill_between(X, down, up, alpha = 0.5)
plt.plot(X, evaluate(x, Fs, X), 'r', label='$\\tilde P(x)$', lw=2)
plt.plot(x, fv, 'b.', label='$f(x_i)$', ms=10)
plt.plot(x, fvs, 'r.', label='$f(x_i) + \\Delta f(x_i)$', ms=10)
plt.xlim(-np.pi, np.pi)
plt.legend(loc='center left', bbox_to_anchor=(1, .5))

plt.show()"
"K = 20
x = np.linspace(0, 1, 1000)
plt.plot(x, ((1+K)**2*np.abs(x-1)*np.abs(x)+(K*np.abs(x-1)+np.abs(x))*np.abs(x-1+K*x))/K, lw=2)
Lv = 1 + 0.5 * K**2 / (1 + K)
plt.ylim(0, Lv+1)
plt.title('$K = %g,\\quad L = 1 + K^2 / (2K+2) \\approx %g$' % (K, Lv))
plt.grid()
plt.show()"
"x = np.linspace(0, 1, 1000)
xs = np.array([0, 0.15, 0.35, 0.65, 0.85, 1])
plt.plot(x, np.sin(2*np.pi*x), lw=2, label='$f(x)$')
plt.plot(xs, np.sin(2*np.pi*xs), lw=2, label='$s(x)$')
plt.legend(loc='center left', bbox_to_anchor=(1, .5))
plt.show()"
"xs = np.array([0, .3, .5, .7, 1.]); ys = np.sin(2*np.pi*xs)
m = cubic_spline(xs, ys)
plt.plot(np.linspace(0, 1, 1000), np.sin(np.linspace(0, 2*np.pi, 1000)), 'r', lw=2)
for i in range(1, len(m)):
    x = np.linspace(xs[i-1], xs[i])
    plt.plot(x, hermite(ys[i-1], m[i-1], ys[i], m[i], xs[i-1], xs[i], x), 'b', lw=2)
plt.plot(xs, ys, 'g.', ms=10)
plt.show()"
"import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
plt.rc('font', **{'size' : 14})

def f(x): return 4 / (1 + x*x)
exact = 4 * np.arctan(0.5)

ns = 6 + 3 * 2**np.arange(1, 12)
errs = []
for n in ns:
    x = np.linspace(0, 0.5, n+1)
    fv = f(x)
    I1 = rectangle(fv, x[1] - x[0])
    I2 = trapezoid(fv, x[1] - x[0])
    I3 = simpson(fv, x[1] - x[0])
    I4 = threeeights(fv, x[1] - x[0])
    errs.append([abs(I1-exact), abs(I2-exact), abs(I3-exact), abs(I4-exact)])

errs=np.array(errs)
    
plt.figure(figsize=(10, 7))
plt.loglog(ns, errs[:, 0], 'b.-', label='Rectangles', lw=2, ms=10)
plt.loglog(ns, errs[:, 1], 'g.-', label='Trapezoids', lw=2, ms=10)
plt.loglog(ns, errs[:, 2], 'r.-', label='Simpson''s', lw=2, ms=10)
plt.loglog(ns, errs[:, 3], 'm.-', label='3/8 rule', lw=2, ms=10)
plt.legend(loc='center left', bbox_to_anchor=(1, .5))
plt.xlabel('$n$')
plt.ylabel('$\\varepsilon$')
plt.xlim(ns[0], ns[-1])
plt.grid()
plt.show()"
"def f(x): return 4 / (1 + x*x)
exact = 4 * np.arctan(0.5)

ns = 2**np.arange(1, 10)
errs = []
for n in ns:
    fv = f(np.linspace(0, 0.5, n+1))
    Is = simpson(fv, 0.5/n)
    Ig = gauss2(f, 0, 0.5, n)
    errs.append([abs(Is-exact), abs(Ig-exact)])

errs=np.array(errs)
    
plt.figure(figsize=(10, 7))
plt.loglog(ns, errs[:, 0], 'b.-', label='Simpson''s', lw=2, ms=10)
plt.loglog(ns, errs[:, 1], 'r.-', label='Gaussian 2pt', lw=2, ms=10)
plt.legend(loc='center left', bbox_to_anchor=(1, .5))
plt.xlabel('$n$')
plt.ylabel('$\\varepsilon$')
plt.xlim(ns[0], ns[-1])
plt.grid()
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np

def difference_solution(N, eps=0):
    T = 1.0
    tau = T / N
    u = np.zeros(N+1)
    u[0] = 1 + eps * np.random.rand(1)
    for n in range(N):
        k1 = -np.sin(u[n])
        k2 = -np.sin(u[n] + tau/2 * k1)
        u[n+1] = u[n] + tau * k2 + tau * eps * np.random.rand(1)
    return u
# Проверяем устойчивость
for N in 2**np.arange(3, 10):
    u = difference_solution(N)
    v = difference_solution(N, 1e-6)
    print('N =', N, ' max |u_n - v_n| =', np.linalg.norm(u - v, np.inf))"
"import matplotlib.pyplot as plt
%matplotlib inline

def exact_solution(t): return 2 * np.arctan(np.exp(-t) * np.tan(0.5))
# Сравним численное решение с точным
plt.plot(np.linspace(0, 1, 1000), exact_solution(np.linspace(0, 1, 1000)))
for N in [10, 20, 40]:
    u = difference_solution(N)
    y = exact_solution(np.linspace(0, 1, N+1))
    plt.plot(np.linspace(0, 1, N+1), u, '.',
        label='N = %d, error = %e' % (N, np.linalg.norm(u - y, np.inf)))
plt.legend(); plt.show()"
"def unstable_method(N, eps=0):
    T = 1.0
    tau = T / N
    u = np.zeros(N+1)
    u[0] = 1 + eps * np.random.rand(1)
    u[1] = 1 - tau * np.sin(1) + eps * np.random.rand(1)
    for n in range(1, N):
        rhs = 0.9 * np.sin(u[n]) + 0.1 * np.sin(u[n-1])
        u[n+1] = 0.5*(3*u[n-1]-u[n] - 5*tau*rhs + 5*tau*eps*np.random.rand(1))
    return u
# Проверяем устойчивость
for N in 2**np.arange(3, 10):
    u = unstable_method(N)
    v = unstable_method(N, 1e-6)
    print('N =', N, ' max |u_n - v_n| =', np.linalg.norm(u - v, np.inf))"
"# Сравним численное решение с точным
plt.plot(np.linspace(0, 1, 1000), exact_solution(np.linspace(0, 1, 1000)))
for N in [5, 10, 20]:
    u = unstable_method(N)
    y = exact_solution(np.linspace(0, 1, N+1))
    plt.plot(np.linspace(0, 1, N+1), u, '.-',
        label='N = %d, error = %e' % (N, np.linalg.norm(u - y, np.inf)))
plt.legend(); plt.show()"
"def exact_solution(t): return 2 * np.arctan(np.exp(-t) * np.tan(0.5))
# Сравним численное решение методом РК4 с точным
plt.plot(np.linspace(0, 1, 1000), exact_solution(np.linspace(0, 1, 1000)))
for N in [5, 10, 20]:
    u = rk4(N)
    y = exact_solution(np.linspace(0, 1, N+1))
    plt.plot(np.linspace(0, 1, N+1), u, '.',
        label='N = %d, error = %e' % (N, np.linalg.norm(u - y, np.inf)))
plt.legend(); plt.show()"
"T, Y = adaptive_stepsize(aren, aren_init, aren_tmax, euler, 1e-4)
orbit_plot(Y, skip=20) # Отмечаем точкой каждый 20й шаг"
"T, Y = adaptive_stepsize(aren, aren_init, aren_tmax, midpoint, 1e-4)
orbit_plot(Y, skip=5) # Отмечаем точкой каждый 5й шаг"
"T, Y = adaptive_stepsize(aren, aren_init, aren_tmax, rk4, 1e-4)
orbit_plot(Y, skip=1) # Отмечаем точкой каждый шаг"
"T, Y = fixed_stepsize(aren, aren_init, aren_tmax, rk4, aren_tmax/5000)
orbit_plot(Y, skip=50) # Отмечаем точкой каждый 50й шаг"
"T, Y = adaptive_stepsize(chem, chem_init, chem_tmax, euler, 1e-2)
T2, Y2 = adaptive_stepsize(lambda t,u:-0.5*u, np.array([1]), chem_tmax, euler, 1e-2)
plt.figure(figsize=(14, 5))
plt.subplot(1,2,1); plt.plot(T, Y[:, 0], '.-'); plt.grid(); 
plt.subplot(1,2,2); plt.plot(T2, Y2[:, 0], '.-') # <<похожая>> задача
plt.grid(); plt.show()"
"T1, Y1 = adaptive_stepsize(chem, chem_init, 0.5, euler, 1e-2)
T2, Y2 = fixed_stepsize(chem, Y1[-1,:], chem_tmax-0.5, euler, 0.08)
plt.plot(T1, Y1[:, 0], '.-')
plt.plot(T2+0.5, Y2[:, 0], '.-')
plt.axis([0, 5, 0, 1])
plt.grid(); plt.show()"
"T, Y = adaptive_stepsize(chem, chem_init, chem_tmax, imeuler, 1e-2)
plt.plot(T, Y[:, 0], '.-')
plt.grid(); plt.show()"
"T, Y = adaptive_stepsize(chem, chem_init, chem_tmax, immidpoint, 1e-2)
plt.plot(T, Y[:, 0], '.-')
plt.grid(); plt.show()"
"T, Y = fixed_stepsize(chem, chem_init, chem_tmax, imeuler, 0.2)
plt.plot(T, Y[:, 0], '.-')
plt.ylim(0, 1)
plt.grid(); plt.show()"
"T, Y = fixed_stepsize(chem, chem_init, chem_tmax, immidpoint, 0.2)
plt.plot(T, Y[:, 0], '.-')
plt.ylim(0, 1)
plt.grid(); plt.show()"
"X,Y = np.meshgrid(np.linspace(-3, 3), np.linspace(-2, 2))
Z = X + 1j * Y
plt.figure(figsize=(14, 10))
plt.rc('font', size=22)
plt.contour(X, Y, np.abs(1 + Z), [1], colors='k')
plt.contourf(X, Y, np.abs(1 + Z), [0, 1], colors='gray')
plt.xlabel('${\\rm Re}\; z$')
plt.ylabel('${\\rm Im}\; z$')
plt.title('$r(z) = 1+z$')
plt.grid()"
"X1, u1 = solve_advection(step, g, upwind, M= 50, courant=0.5)
X2, u2 = solve_advection(step, g, upwind, M=100, courant=0.5)
X3, u3 = solve_advection(step, g, upwind, M=200, courant=0.5)
X4, u4 = solve_advection(step, g, upwind, M=400, courant=0.5)
plt.plot(X1, u1, label='M=50'); plt.plot(X2, u2, label='M=100');
plt.plot(X3, u3, label='M=200'); plt.plot(X4, u4, label='M=400')
plt.plot(X3, step(X3 - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.1); plt.legend(loc='lower left')
plt.title('Upwind, $\sigma = 0.5$'); plt.show()"
"X1, u1 = solve_advection(step, g, upwind, M= 50, courant=0.5)
X2, u2 = solve_advection(step, g, upwind, M=100, courant=0.25)
X3, u3 = solve_advection(step, g, upwind, M=200, courant=0.125)
X4, u4 = solve_advection(step, g, upwind, M=400, courant=0.0625)
plt.plot(X1, u1, label='M=50'); plt.plot(X2, u2, label='M=100');
plt.plot(X3, u3, label='M=200'); plt.plot(X4, u4, label='M=400')
plt.plot(X3, step(X3 - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.1); plt.legend(loc='lower left')
plt.title(r'Upwind, $\tau = 25h^2$'); plt.show()"
"X, u = solve_advection(step, g, upwind, courant=0.5, verbose=True)
plt.plot(X, u)
plt.plot(X, step(X - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.2)
plt.title('Upwind, $M = 200, \sigma=0.5$'); plt.show()"
"X, u = solve_advection(step, g, central, courant=0.5, verbose=True)
plt.plot(X, u)
plt.plot(X, step(X - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.2)
plt.title('Central, $M = 200, \sigma=0.5$'); plt.show()"
"# Схему с центральной разностью можно считать устойчивой при
# выполнении условия т=O(h^2), то есть при малых числах Куранта
X, u = solve_advection(step, g, central, courant=0.01, verbose=True)
plt.plot(X, u)
plt.plot(X, step(X - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.2)
plt.title('Central, $M = 200, \sigma=0.01$'); plt.show()"
"X, u = solve_advection(step, g, lax, courant=0.5, verbose=True)
plt.plot(X, u)
plt.plot(X, step(X - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.1)
plt.title('Lax, $M = 200$'); plt.show()"
"X1, u1 = solve_advection(step, g, lax, M= 50, courant=0.5)
X2, u2 = solve_advection(step, g, lax, M=100, courant=0.5)
X3, u3 = solve_advection(step, g, lax, M=200, courant=0.5)
X4, u4 = solve_advection(step, g, lax, M=400, courant=0.5)
plt.plot(X1, u1, label='M=50'); plt.plot(X2, u2, label='M=100');
plt.plot(X3, u3, label='M=200'); plt.plot(X4, u4, label='M=400')
plt.plot(X3, step(X3 - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.1); plt.legend(loc='lower left')
plt.title('Lax, $\sigma = 0.5$'); plt.show()"
"X1, u1 = solve_advection(step, g, lax, M= 50, courant=0.5)
X2, u2 = solve_advection(step, g, lax, M=100, courant=0.25)
X3, u3 = solve_advection(step, g, lax, M=200, courant=0.125)
X4, u4 = solve_advection(step, g, lax, M=400, courant=0.0625)
plt.plot(X1, u1, label='M=50'); plt.plot(X2, u2, label='M=100');
plt.plot(X3, u3, label='M=200'); plt.plot(X4, u4, label='M=400')
plt.plot(X3, step(X3 - 0.6), 'k', label='exact solution')
plt.ylim(-0.1, 1.1); plt.legend(loc='lower left')
plt.title(r'Lax, $\tau = 25h^2$'); plt.show()"
"p = 0.45 # probability for head
n = 100
heads = (np.random.random(n) < p).sum()

fig, ax = plt.subplots()
ax.bar([0, 1], [heads, n-heads])
ax.set_xticks((0,1))
ax.set_xticklabels(('Heads', 'Tails'))
ax.set_ylabel('Frequency')
sns.despine()"
"print(""P-value for two-sided biomial test for a fair coin: {:.2g}"".format(
    proportion.binom_test(heads, n, prop=0.5)
))
"
"min_heads, max_heads = proportion.binom_test_reject_interval(0.5, n, alpha=0.05)
min_heads, max_heads, heads"
"rv = stats.binom(n, 0.5)
max_freq = rv.pmf(n//2)
fig, ax = plt.subplots()
ax.fill_between([min_heads, max_heads], [max_freq*1.1]*2, alpha=0.2)
ax.plot(rv.pmf(np.arange(0, n+1)))
ax.axvline(heads, color='k', ls='--')
ax.annotate('rejection region', (0.4, 1.01), xycoords='axes fraction')
ax.annotate('observed', 
            (heads, 0.05), xytext=(-60, 0), 
            xycoords='data', textcoords='offset points',
            arrowprops=dict(arrowstyle='->')
)
ax.set(
    ylim=(0, max_freq*1.1),
    xlabel='Heads',
    ylabel='Probability'
)
sns.despine()"
"t = np.linspace(0, 12, 12)
R0s = np.array([0.05, 0.15, 0.3, 0.45, 0.6, 0.9, 1.4])
N0 = 0.1
h = 0.5
ε = 0.8
K = 0.2
rs = []

fig, axes = plt.subplots(2, 1, figsize=(10, 8), sharex=False, sharey=False)

ax = axes[1]
for R0 in R0s:
    y = monod_growth(t, R0, N0, h, ε, K)
    R, N = y[:,0], y[:,1]
    N += np.random.normal(0, 0.01)
#     ax.plot(t, R, '--', label='R')
    ax.plot(t, N, '--o', label=R0)
    rs.append( fit_expo(t, N) )

ax.set(
    xlabel='Time',
    ylabel='Concentration',
#     yscale='log'
)
ax.legend(title='R0', loc='center right', frameon=True)

axes[0].plot(R0s, R0s*ε*h/(R0s+K), 'o--', lw=3, label='Real')
axes[0].plot(R0s, rs, 'o--', label='Approx')
axes[0].set(xlabel='R', ylabel=r'$\frac{1}{N} \cdot \frac{dN}{dt}$')

fig.tight_layout()
sns.despine()"
"fig, ax = plt.subplots()
y = monod_growth(t, R0, N0, h, ε, K)
R, N = y[:,0], y[:,1]
ax.plot(t, R, '-', label='R')
ax.plot(t, N, '-', label='N')
ax.plot(t, ε*R+N, '-', label='M')
ax.legend()"
person_element.attrib
"# %load examples/csvdict.py
import csv
import os.path

csv_path = os.path.join('examples', 'persons.csv')
with open(csv_path, 'r', encoding='utf-8', newline='') as csv_file:
    for person in csv.DictReader(csv_file, delimiter=';'):
        print(person)
"
person_element.attrib
"import datetime

def log(message, level='INFO', **keywords):
    time_text = datetime.datetime.now().isoformat()
    message_to_log = time_text + ' ' + level + ': '
    for word in message.split():
        if word.startswith('$'):
            key = word[1:]
            message_to_log += keywords[key]
        else:
            message_to_log += word
        message_to_log += ' '
    print(message_to_log)

log('Hello world!')
log('Here we go, $name', name='Alice')
log('Cannot write $item to $path', level='ERROR', item='tax data', path='/tmp/tax.txt')"
alice.age()
"baerbel.date_of_birth = date(1991, 2, 15)
baerbel.age()"
baerbel
"class FailureAndErrorTest(unittest.TestCase):
    def test_error(self):
        with open('no_such_file.tmp', 'r', encoding='utf-8'):
            assertEqual(1, 0)

    def test_failure(self):
        self.assertEqual(1, 0)        

run_test_class(FailureAndErrorTest)"
"import os.path
import unittest

class TextFileTest(unittest.TestCase):
    def setUp(self):
        text_path = os.path.join('examples', 'der_rote_komet.txt')
        self._text_file = open(text_path, 'r', encoding='utf-8')

    def tearDown(self):
        self._text_file.close()

    def test_has_lines(self):
        line_count = len(list(self._text_file))
        self.assertGreater(line_count, 0)
        
    def test_has_line_with_umlaut_u(self):
        self.assertTrue(any('ü' in line for line in self._text_file))

run_test_class(TextFileTest)"
"date_of_birth = datetime.date(1987, 3, 28)
age = datetime.date.today() - date_of_birth
print(age.days)"
"import os
import datetime

some_txt_path = os.path.join('examples', 'some.txt')  # path to the file to examine

last_modified_timestamp = os.path.getmtime(some_txt_path)  # timestamp when last modified
datetime.datetime.fromtimestamp(last_modified_timestamp)  # ...converted to datetime"
"!grep "">"" data/Crassostrea_gigas.GCA_000297895.1.29.pep.all.fa | wc -l"
"!grep "">"" data/Crassostrea_gigas.GCA_000297895.1.29.pep.all.fa > analyses/pep.title"
"import warnings
warnings.filterwarnings('ignore')
import pandas as pd
pd.read_table('http://www.flightstats.com/go/FlightStatus/flightStatusByAirport.do')"
"fig, axes = plt.subplots(figsize=(7.2,4.8), dpi=100)

axes.plot(ONEE, epsb1w.imag, 'C3--', label=r'$\epsilon_{b}(\omega)$', lw=2)
axes.plot(ONEE, epsl1w.imag, 'C4', label=r'$\epsilon_{\ell}(\omega)$', lw=2)

axes.set_xlabel('One-photon energy (eV)')
axes.set_ylabel(r'Im$[\epsilon(\omega)]$')
axes.set_xlim([2.5, 10])
axes.set_ylim([0, 80])
axes.legend();"
"fig, axes = plt.subplots(figsize=(7.2,4.8), dpi=100)

axes.plot(2*ONEE, RsP, lw=2)
axes.set_xlabel('Two-photon energy (eV)')
axes.set_ylabel(r'$\mathcal{R}_{sP}\,\,(10^{-20}\times\,\mathrm{cm}^{2}/\mathrm{W})$')
axes.set_xlim([2.5, 5])
axes.set_ylim([0, 0.06]);"
pd?
"import warnings
warnings.filterwarnings('ignore')
import pandas as pd
%matplotlib inline

df = pd.DataFrame([1,2,4,8,16,32,64,128,256])
df.plot()"
"import numpy as np

x = np.array([0,1])
w = np.array([0.5, 0.5])
b = -0.7
print (""w*x = {0}"".format(w*x))
print (""np.sum(w*x) = {0}"".format(np.sum(w*x)))
print (""np.sum(w*x) + b = {0}"".format(np.sum(w*x) + b))

### AND
def AND(x1,x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    tmp = np.sum(w*x) + b
    if tmp <= 0:
        return 0
    else:
        return 1

print ('---AND---')
print (AND(0,0))
print (AND(1,0))
print (AND(0,1))
print (AND(1,1))

### NAND
def NAND(x1,x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])
    b = 0.7
    tmp = np.sum(w*x) + b
    if tmp <= 0:
        return 0
    else:
        return 1

print ('---NAND---')
print (NAND(0,0))
print (NAND(1,0))
print (NAND(0,1))
print (NAND(1,1))


### OR
def OR(x1,x2):
    x = np.array([x1, x2])
    w = np.array([0.9, 0.9])
    b = -0.5
    tmp = np.sum(w*x) + b
    if tmp <= 0:
        return 0
    else:
        return 1

print ('---OR---')
print (OR(0,0))
print (OR(1,0))
print (OR(0,1))
print (OR(1,1))
"
"csv_url = 'csv/H29-05-01.csv'
df = pd.read_csv(csv_url, encoding=""SHIFT-JIS"")
df"
"csv_url = 'csv/H29-05-01.csv'
df = pd.read_csv(csv_url, skiprows=4, encoding=""SHIFT-JIS"")
df"
"#df.plot.bar()
#df.title(u'平成29年5月1日現在の人口推計')
df.plot.bar()"
"import warnings
warnings.filterwarnings('ignore')
import scipy as sp
from scipy.integrate import fixed_quad
f = lambda x: 1/(1+x)
I = fixed_quad(f,0,1,n=4)
print(""A integral deu {}"".format(I))"
help(simps)
"A1 = tabelaFourier(4,3)
print(A1)
"
"D=np.dot(A2,A2.T)
D1=D[1:,1:]
print(D1)"
"y = np.array([2,-1,3, 4, 5])
E=np.dot(A2,y.T)
print(E[1:])"
"a = [D1[u,u]/E[u+1] for u in range(5)]
print(a)"
"%matplotlib inline
f0= lambda x: 1
f1= lambda x: np.cos(x)
f2= lambda x: np.sin(x)
f3= lambda x: np.cos(2*x)
f4= lambda x: np.sin(2*x)
f = lambda x: a[0]*f0(x)+ a[1]*f1(x) + a[2]*f2(x) + a[3]*f3(x)+a[4]*f4(x)
from matplotlib.pyplot import plot
t=np.linspace(-0.1,6.4,100)
x=A2[0,:]
plot(x,y,""ro"", t,f(t))"
two_kids & at_least_one_boy
"import random
random.sample(list(two_kids_w), 8)"
"random.sample(list(two_kids_wb), 5)"
"from collections import Counter

Counter(simulate_monty('switch') for _ in range(10 ** 5))"
Counter(simulate_monty('stick') for _ in range(10 ** 5))
"DK = ProbDist(GG=121801., GB=126840.,
              BG=127123., BB=135138.)
DK"
"%matplotlib inline 
import matplotlib.pyplot as plt

X = list(range(1000, 1000000, 10000))
plt.plot(X, [util(x) for x in X])
print('Y axis is util(x); x axis is in thousands of dollars.')"
"from collections import Counter

random.seed(123456)

c = Counter(simulate_st_pete() for _ in range(100000))
c"
"random.seed('running')

for i in range(10):
    plot_running_averages(simulate_st_pete, 100000);"
"def ellsburg():
    show('R', 'r')
    show('B', 'k')
    show('RY', 'r--')
    show('BY', 'k--')
    plt.xlabel('Number of black balls')
    plt.ylabel('Expected value of each gamble')
    
blacks = list(range(68))
urns   = [Counter(R=33, B=b, Y=67-b) for b in blacks]
    
def show(colors, line):
    scores = [score(colors, urn) for urn in urns]
    plt.plot(blacks, scores, line)
    
def score(colors, urn): return sum(urn[c] for c in colors)

ellsburg()"
"def ellsburg2():
    show2('R', 'r')
    show2('B', 'k')
    show2('RY', 'r--')
    show2('BY', 'k--')
    plt.xlabel('Different combinations of two urns')
    plt.ylabel('Expected value of each gamble')
    
def show2(colors, line):
    urnpairs = [(u1, u2) for u1 in urns for u2 in urns]
    urnpairs.sort(key=lambda urns: avgscore('B', urns))
    X = list(range(len(urnpairs)))
    plt.plot(X, [avgscore(colors, urns) for urns in urnpairs], line)
    
ellsburg2()"
"c = {
    '123': 0,
    '132': 0,
    '213': 0,
    '231': 0,
    '312': 0,
    '321': 0
}

for i in range(10000):
    c[naive('123')] += 1
    
print(c)"
"labels = list(sorted(c.keys()))
values = [c[x] for x in labels]
y_pos = np.arange(len(values))

plt.bar(y_pos, values, align='center', alpha=0.5, color='blue')
plt.xticks(y_pos, labels)
plt.title(""Naive Sort"")"
"c = {
    '123': 0,
    '132': 0,
    '213': 0,
    '231': 0,
    '312': 0,
    '321': 0
}

for i in range(10000):
    c[fisheryates('123')] += 1
    
print(c)"
"labels = list(sorted(c.keys()))
values = [c[x] for x in labels]
y_pos = np.arange(len(values))

plt.bar(y_pos, values, align='center', alpha=0.5, color='blue')
plt.xticks(y_pos, labels)
plt.title(""Fisher-Yates Sort"")"
"draw_de_bruijn_graph(create_de_bruijn_graph(2, 3))"
"res = de_bruijn_nx(10, 4)
res += res[:3]  # wrap around
print('Solution (overview): %s...%s' % (res[:50], res[-50:]))
print('Good solution?', check_solution(10, 4, res))"
"p = plot((f.subs(G,25),(t,0,1)),((f-25).subs(G,25),(t,1,2)),((f-50).subs(G,25),(t,2,3)), \
         ylabel = '$f = 25 t$ [V]', xlabel = '$t$ [sec]', xlim=(0,3), figsize=(10,8))"
"a[9], b[9]"
"fig,ax = plt.subplots(figsize=(10,8))
ax.bar(-.5+arange(1,10),c,alpha=.5)
ax.set_xticks([1,2,3,4,5,6,7,8,9,10])
ax.set_xlabel('$n$',fontsize=16)
ax.set_ylabel('Fourier coefficients $a_n^2 + b_n^2$',fontsize=16)"
"import warnings
warnings.filterwarnings('ignore')
%pylab inline
import matplotlib as mpl
mpl.rcParams['lines.linewidth']=2
mpl.rcParams['lines.color']='r'
mpl.rcParams['figure.figsize']=(12,8)
mpl.rcParams['font.size']=14
mpl.rcParams['axes.labelsize']=20"
"x = array([10.0,20.03,30.01,40.02,50.02,60.01,70.00,80.01])
y = array([1.62,2.04,4.05,2.85,3.84,3.81,4.86,5.02])
plot(x,y,'o')
xlim([0,90])
ylim([1,6])
xlabel('$x$'),ylabel('$y$')

# best fit seems to be linear
p = polyfit(x,y,1)
Y = polyval(p,x)
plot(x,Y,'--')
text(10,5,'Y = %4.3f x + %4.3f' % (p[0],p[1]))"
"n = len(x)
m = 1 # number of independent variables
nu = n - (m+1)
Syx = sqrt(sum((Y - y)**2)/nu)
print (Syx)"
"e = (Y-y)
plot(arange(1,n+1),e/Syx,'go')
plot([0,n+1],[-2,-2],'b-',[0,n+1],[2,2],'r-')
plot([3],e[2]/Syx,'rx',mfc='none',markersize=30)
xlim([0,n+1]),ylim([-3,3])
xlabel('$n$'),ylabel('$e/S_{yx}$')"
"u = numpy.ones(nx)      #numpy function ones()
u[int(.5 / dx):int(1 / dx + 1)] = 2  #setting u = 2 between 0.5 and 1 as per our I.C.s
print(u)"
"pyplot.plot(numpy.linspace(0, 2, nx), u);"
"pyplot.plot(numpy.linspace(0, 2, nx), u);"
"from IPython.display import YouTubeVideo
YouTubeVideo('iz22_37mMkk')"
YouTubeVideo('xq9YTcv-fQg')
YouTubeVideo('y2WaK7_iMRI')
linearconv(41) #convection using 41 grid points
linearconv(61)
linearconv(71)
linearconv(85)
linearconv(41)
linearconv(61)
linearconv(81)
linearconv(101)
linearconv(121)
"from IPython.display import YouTubeVideo
YouTubeVideo('Yw1YPBupZxU')"
"import warnings
warnings.filterwarnings('ignore')
import numpy                 #loading our favorite library
from matplotlib import pyplot    #and the useful plotting library
%matplotlib inline

nx = 41
dx = 2 / (nx - 1)
nt = 20    #the number of timesteps we want to calculate
nu = 0.3   #the value of viscosity
sigma = .2 #sigma is a parameter, we'll learn more about it later
dt = sigma * dx**2 / nu #dt is defined using sigma ... more later!


u = numpy.ones(nx)      #a numpy array with nx elements all equal to 1.
u[int(.5 / dx):int(1 / dx + 1)] = 2  #setting u = 2 between 0.5 and 1 as per our I.C.s

un = numpy.ones(nx) #our placeholder array, un, to advance the solution in time

for n in range(nt):  #iterate through time
    un = u.copy() ##copy the existing values of u into un
    for i in range(1, nx - 1):
        u[i] = un[i] + nu * dt / dx**2 * (un[i+1] - 2 * un[i] + un[i-1])
        
pyplot.plot(numpy.linspace(0, 2, nx), u);"
"from IPython.display import YouTubeVideo
YouTubeVideo('y2WaK7_iMRI')"
"x, nu, t = sympy.symbols('x nu t')
phi = (sympy.exp(-(x - 4 * t)**2 / (4 * nu * (t + 1))) +
       sympy.exp(-(x - 4 * t - 2 * sympy.pi)**2 / (4 * nu * (t + 1))))
phi"
"phiprime = phi.diff(x)
phiprime"
"ufunc = lambdify((t, x, nu), u)
print(ufunc(1, 4, 3))"
"from matplotlib import pyplot
%matplotlib inline

###variable declarations
nx = 101
nt = 100
dx = 2 * numpy.pi / (nx - 1)
nu = .07
dt = dx * nu

x = numpy.linspace(0, 2 * numpy.pi, nx)
un = numpy.empty(nx)
t = 0

u = numpy.asarray([ufunc(t, x0, nu) for x0 in x])
u"
"pyplot.figure(figsize=(11, 7), dpi=100)
pyplot.plot(x, u, marker='o', lw=2)
pyplot.xlim([0, 2 * numpy.pi])
pyplot.ylim([0, 10]);"
"pyplot.figure(figsize=(11, 7), dpi=100)
pyplot.plot(x,u, marker='o', lw=2, label='Computational')
pyplot.plot(x, u_analytical, label='Analytical')
pyplot.xlim([0, 2 * numpy.pi])
pyplot.ylim([0, 10])
pyplot.legend();"
"%%timeit
u = numpy.ones((ny, nx))
u[int(.5 / dy): int(1 / dy + 1), int(.5 / dx):int(1 / dx + 1)] = 2

for n in range(nt + 1): ##loop across number of time steps
    un = u.copy()
    row, col = u.shape
    for j in range(1, row):
        for i in range(1, col):
            u[j, i] = (un[j, i] - (c * dt / dx * 
                                  (un[j, i] - un[j, i - 1])) - 
                                  (c * dt / dy * 
                                   (un[j, i] - un[j - 1, i])))
            u[0, :] = 1
            u[-1, :] = 1
            u[:, 0] = 1
            u[:, -1] = 1"
"%%timeit
u = numpy.ones((ny, nx))
u[int(.5 / dy): int(1 / dy + 1), int(.5 / dx):int(1 / dx + 1)] = 2

for n in range(nt + 1): ##loop across number of time steps
    un = u.copy()
    u[1:, 1:] = (un[1:, 1:] - (c * dt / dx * (un[1:, 1:] - un[1:, 0:-1])) -
                              (c * dt / dy * (un[1:, 1:] - un[0:-1, 1:])))
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1"
"import warnings
warnings.filterwarnings('ignore')
from mpl_toolkits.mplot3d import Axes3D    ##New Library required for projected 3d plots

import numpy
from matplotlib import pyplot, cm
%matplotlib inline

###variable declarations
nx = 81
ny = 81
nt = 100
c = 1
dx = 2 / (nx - 1)
dy = 2 / (ny - 1)
sigma = .2
dt = sigma * dx

x = numpy.linspace(0, 2, nx)
y = numpy.linspace(0, 2, ny)

u = numpy.ones((ny, nx)) ##create a 1xn vector of 1's
un = numpy.ones((ny, nx)) ##

###Assign initial conditions

##set hat function I.C. : u(.5<=x<=1 && .5<=y<=1 ) is 2
u[int(.5 / dy):int(1 / dy + 1),int(.5 / dx):int(1 / dx + 1)] = 2 

###Plot Initial Condition
##the figsize parameter can be used to produce different sized images
fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')                      
X, Y = numpy.meshgrid(x, y)                            
surf = ax.plot_surface(X, Y, u[:], cmap=cm.viridis)

"
"u = numpy.ones((ny, nx))
u[int(.5 / dy):int(1 / dy + 1), int(.5 / dx):int(1 / dx + 1)] = 2

for n in range(nt + 1): ##loop across number of time steps
    un = u.copy()
    row, col = u.shape
    for j in range(1, row):
        for i in range(1, col):
            u[j, i] = (un[j, i] - (c * dt / dx * (un[j, i] - un[j, i - 1])) -
                                  (c * dt / dy * (un[j, i] - un[j - 1, i])))
            u[0, :] = 1
            u[-1, :] = 1
            u[:, 0] = 1
            u[:, -1] = 1

fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
surf2 = ax.plot_surface(X, Y, u[:], cmap=cm.viridis)"
"u = numpy.ones((ny, nx))
u[int(.5 / dy):int(1 / dy + 1), int(.5 / dx):int(1 / dx + 1)] = 2

for n in range(nt + 1): ##loop across number of time steps
    un = u.copy()
    u[1:, 1:] = (un[1:, 1:] - (c * dt / dx * (un[1:, 1:] - un[1:, :-1])) -
                              (c * dt / dy * (un[1:, 1:] - un[:-1, 1:])))
    u[0, :] = 1
    u[-1, :] = 1
    u[:, 0] = 1
    u[:, -1] = 1

fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
surf2 = ax.plot_surface(X, Y, u[:], cmap=cm.viridis)

    "
"from IPython.display import YouTubeVideo
YouTubeVideo('tUg_dE3NXoY')"
"fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)

ax.plot_surface(X, Y, u, cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$');"
"fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)

ax.plot_surface(X, Y, u, cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$');"
"fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
ax.plot_surface(X, Y, v, cmap=cm.viridis, rstride=2, cstride=2)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$');"
"from IPython.display import YouTubeVideo
YouTubeVideo('tUg_dE3NXoY')"
"fig = pyplot.figure()
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
surf = ax.plot_surface(X, Y, u, rstride=1, cstride=1, cmap=cm.viridis,
        linewidth=0, antialiased=False)

ax.set_xlim(0, 2)
ax.set_ylim(0, 2)
ax.set_zlim(1, 2.5)

ax.set_xlabel('$x$')
ax.set_ylabel('$y$');"
diffuse(10)
diffuse(14)
diffuse(50)
"from IPython.display import YouTubeVideo
YouTubeVideo('tUg_dE3NXoY')"
"###(plot ICs)
fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
ax.plot_surface(X, Y, u[:], cmap=cm.viridis, rstride=1, cstride=1)
ax.plot_surface(X, Y, v[:], cmap=cm.viridis, rstride=1, cstride=1)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$');"
"fig = pyplot.figure(figsize=(11, 7), dpi=100)
ax = fig.gca(projection='3d')
X, Y = numpy.meshgrid(x, y)
ax.plot_surface(X, Y, u, cmap=cm.viridis, rstride=1, cstride=1)
ax.plot_surface(X, Y, v, cmap=cm.viridis, rstride=1, cstride=1)
ax.set_xlabel('$x$')
ax.set_ylabel('$y$');"
"from IPython.display import YouTubeVideo
YouTubeVideo('tUg_dE3NXoY')"
"plot2D(x, y, p)"
"plot2D(x, y, p)"
"from IPython.display import YouTubeVideo
YouTubeVideo('ZjfxA3qq2Lg')"
"from IPython.display import YouTubeVideo
YouTubeVideo('iwL8ashXhWU')"
"plot2D(x, y, p)"
"from IPython.display import YouTubeVideo
YouTubeVideo('ZjfxA3qq2Lg')"
"%matplotlib inline

# plot the grid of points
width = 10.0
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.scatter(X, Y, s=5, color='#CD2305', marker='o')"
"# plot the streamlines
width = 10.0
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u_source, v_source,
                  density=2, linewidth=1, arrowsize=2, arrowstyle='->')
pyplot.scatter(x_source, y_source,
               color='#CD2305', s=80, marker='o');"
"# plot the streamlines
width = 10.0
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u_sink, v_sink,
                  density=2, linewidth=1, arrowsize=2, arrowstyle='->')
pyplot.scatter(x_sink, y_sink,
               color='#CD2305', s=80, marker='o');"
"# compute the velocity of the pair source/sink by superposition
u_pair = u_source + u_sink
v_pair = v_source + v_sink

# plot the streamlines of the pair source/sink
width = 10.0
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u_pair, v_pair,
                  density=2.0, linewidth=1, arrowsize=2, arrowstyle='->')
pyplot.scatter([x_source, x_sink], [y_source, y_sink], 
               color='#CD2305', s=80, marker='o');"
"# superposition of the source on the freestream
u = u_freestream + u_source
v = v_freestream + v_source
psi = psi_freestream + psi_source

# plot the streamlines
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.grid(True)
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u, v, density=2, linewidth=1, arrowsize=1, arrowstyle='->')
pyplot.scatter(x_source, y_source, color='#CD2305', s=80, marker='o')

# calculate the stagnation point
x_stagnation = x_source - strength_source / (2 * numpy.pi * u_inf)
y_stagnation = y_source

# display the stagnation point
pyplot.scatter(x_stagnation, y_stagnation, color='g', s=80, marker='o')

# display the dividing streamline
pyplot.contour(X, Y, psi, 
               levels=[-strength_source / 2, strength_source / 2], 
               colors='#CD2305', linewidths=2, linestyles='solid');"
"# superposition of a source and a sink on the freestream
u = u_freestream + u_source + u_sink
v = v_freestream + v_source + v_sink
psi = psi_freestream + psi_source + psi_sink

# plot the streamlines
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u, v,
                  density=2, linewidth=1, arrowsize=1, arrowstyle='->')
pyplot.scatter([x_source, x_sink], [y_source, y_sink],
               color='#CD2305', s=80, marker='o')
pyplot.contour(X, Y, psi,
               levels=[0.], colors='#CD2305', linewidths=2, linestyles='solid');"
"# compute the pressure coefficient field
cp = 1.0 - (u**2 + v**2) / u_inf**2

# plot the pressure coefficient field
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(1.1 * width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
contf = pyplot.contourf(X, Y, cp,
                        levels=numpy.linspace(-2.0, 1.0, 100), extend='both')
cbar = pyplot.colorbar(contf)
cbar.set_label('$C_p$', fontsize=16)
cbar.set_ticks([-2.0, -1.0, 0.0, 1.0])
pyplot.scatter([x_source, x_sink], [y_source, y_sink],
               color='#CD2305', s=80, marker='o')
pyplot.contour(X, Y, psi,
               levels=[0.], colors='#CD2305', linewidths=2, linestyles='solid');"
"# plot the streamlines
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u_vortex, v_vortex,
                  density=2, linewidth=1, arrowsize=1, arrowstyle='->')
pyplot.scatter(x_vortex, y_vortex, color='#CD2305', s=80, marker='o');"
"# superposition of the sink and the vortex
u = u_vortex + u_sink
v = v_vortex + v_sink
psi = psi_vortex + psi_sink

# plot the streamlines
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u, v, density=2, linewidth=1, arrowsize=1, arrowstyle='->')
pyplot.scatter(x_vortex, y_vortex, color='#CD2305', s=80, marker='o');"
"from IPython.display import YouTubeVideo
from datetime import timedelta

start=int(timedelta(hours=0, minutes=4, seconds=25).total_seconds())

YouTubeVideo(""loCLkcYEWD4"", start=start)"
"# plot the streamlines
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u, v, density=2, linewidth=1, arrowsize=1, arrowstyle='->')
pyplot.scatter(x_doublet, y_doublet, color='#CD2305', s=80, marker='o')

# calculate the cylinder radius and add the cylinder to the figure
R = math.sqrt(kappa / (2 * math.pi * u_inf))
circle = pyplot.Circle((0, 0), radius=R, color='#CD2305', alpha=0.5)
pyplot.gca().add_patch(circle)

# calculate the stagnation points and add them to the figure
x_stagn1, y_stagn1 = +math.sqrt(kappa / (2 * math.pi * u_inf)), 0.0
x_stagn2, y_stagn2 = -math.sqrt(kappa / (2 * math.pi * u_inf)), 0.0
pyplot.scatter([x_stagn1, x_stagn2], [y_stagn1, y_stagn2],
               color='g', s=80, marker='o');"
"# calculate the cylinder radius
R = math.sqrt(kappa / (2 * math.pi * u_inf))

# calculate the stagnation points
x_stagn1, y_stagn1 = (+math.sqrt(R**2 - (gamma / (4 * math.pi * u_inf))**2),
                      -gamma / (4 * math.pi * u_inf))
x_stagn2, y_stagn2 = (-math.sqrt(R**2 - (gamma / (4 * math.pi * u_inf))**2),
                      -gamma / (4 * math.pi * u_inf))

# plot the streamlines
width = 10
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end)
pyplot.streamplot(X, Y, u, v,
                  density=2, linewidth=1, arrowsize=1.5, arrowstyle='->')
circle = pyplot.Circle((0.0, 0.0), radius=R, color='#CD2305', alpha=0.5)
pyplot.gca().add_patch(circle)
pyplot.scatter(x_vortex, y_vortex, color='#CD2305', s=80, marker='o')
pyplot.scatter([x_stagn1, x_stagn2], [y_stagn1, y_stagn2],
               color='g', s=80, marker='o');"
"# calculate the surface tangential velocity on the cylinder
theta = numpy.linspace(0.0, 2 * math.pi, 100)
u_theta = -2 * u_inf * numpy.sin(theta) - gamma / (2 * math.pi * R)

# compute the surface pressure coefficient
cp = 1.0 - (u_theta / u_inf)**2

# if there was no vortex
u_theta_no_vortex = -2 * u_inf * numpy.sin(theta)
cp_no_vortex = 1.0 - (u_theta_no_vortex / u_inf)**2

# plot the surface pressure coefficient
size = 6
pyplot.figure(figsize=(size, size))
pyplot.grid(True)
pyplot.xlabel(r'$\theta$', fontsize=18)
pyplot.ylabel('$C_p$', fontsize=18)
pyplot.xlim(theta.min(), theta.max())
pyplot.plot(theta, cp,
            label='with vortex', color='#CD2305', linewidth=2, linestyle='-')
pyplot.plot(theta, cp_no_vortex,
            label='without vortex', color='g', linewidth=2, linestyle='-')
pyplot.legend(loc='best', prop={'size':16});"
"from IPython.display import YouTubeVideo
YouTubeVideo('POHre1P_E1k')"
"# plot the streamlines
width = 4
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.grid()
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.streamplot(X, Y, u, v,
                  density=2, linewidth=1, arrowsize=1, arrowstyle='->')
# plot the sources
pyplot.scatter(x_source, y_source,
               color='#CD2305', s=80, marker='o')
# compute the velocity magniture and indices of the stagnation point
# note: the stagnation point is approximated as the point with the smallest velocity magnitude
magnitude = numpy.sqrt(u**2 + v**2)
j_stagn, i_stagn = numpy.unravel_index(magnitude.argmin(), magnitude.shape)
# plot the stagnation point
pyplot.scatter(x[i_stagn], y[j_stagn],
               color='black', s=40, marker='D')
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end);"
"# plot the streamlines
width = 4
height = (y_end - y_start) / (x_end - x_start) * width
pyplot.figure(figsize=(width, height))
pyplot.grid()
pyplot.xlabel('x', fontsize=16)
pyplot.ylabel('y', fontsize=16)
pyplot.streamplot(X, Y, u, v,
                  density=2, linewidth=1, arrowsize=1, arrowstyle='->')
# plot the source sheet
pyplot.axvline(0.0,
               (y_min - y_start) / (y_end - y_start),
               (y_max - y_start) / (y_end - y_start),
               color='#CD2305', linewidth=4)
# compute the velocity magniture and indices of the stagnation point
# note: stagnation point approximated as point with smallest velocity magnitude
magnitude = numpy.sqrt(u**2 + v**2)
j_stagn, i_stagn = numpy.unravel_index(magnitude.argmin(), magnitude.shape)
# plot the stagnation point
pyplot.scatter(x[i_stagn], y[j_stagn],
               color='black', s=40, marker='D')
pyplot.xlim(x_start, x_end)
pyplot.ylim(y_start, y_end);"
"data = rnd.normal(loc=5, scale=2, size=100)  # Array with 100 values
print('mean of data: ', np.mean(data))
print('standard deviation of data: ', np.std(data))"
"data = rnd.normal(loc=6, scale=2, size=100)
hist_data = plt.hist(data)
plt.xlabel('bins')
plt.ylabel('number of data points')
print('number of data points in each bin:', hist_data[0])
print('limits of the bins:', hist_data[1])"
"hist_data = plt.hist(data, bins=12, range=(0, 12))
print('number of data points in each bin:', hist_data[0])
print('limits of the bins:', hist_data[1])
plt.xlabel('bins')
plt.ylabel('number of data points');"
"from scipy.stats import norm
a = plt.hist(data, bins=12, range=(0, 12), density=True)
x = np.linspace(0, 12, 100)
y = norm.pdf(x, loc=6, scale=2) # mu=6, sig=2
plt.plot(x, y, 'r')
plt.xlabel('value')
plt.ylabel('probability');"
"data = rnd.normal(loc=10, scale=2, size=100)
lower, median, upper = np.percentile(data, [2.5, 50, 97.5])
print('2.5 percentile:', lower)
print('50 percentile:', median)
print('97.5 percentile:', upper)
print('95% interval:', lower, ' to ', upper)"
"rnd.seed(10)
data = rnd.normal(loc=10, scale=2, size=500)
plt.boxplot(data);"
"data.hist(figsize=(10, 4), density=True, sharex=True, sharey=True);"
"data.test1[5] = np.nan  # Replace the value of test1 with index 5 to nan
data.hist(cumulative=True, sharex=True, figsize=(10, 4), density=True);"
data.boxplot();
"plt.figure(figsize=(10, 4))
ax1 = plt.subplot(121)
data.hist(column='test1', ax=ax1)  # Makes histogram of column test1
ax2 = plt.subplot(122)
data.boxplot(column='test2', ax=ax2);  # Makes boxplot of column test2"
"from scipy.stats import norm
mu = 100
sig = 10
data = rnd.normal(loc=mu, scale=sig, size=1000)
print('mean of data is:', np.mean(data))
print('standard deviation of data is:', np.std(data))
plt.subplot(211)
a = plt.hist(data, bins=20, range=(50, 150), density=True)
x = np.linspace(50, 150, 100)
y = norm.pdf(x, loc=mu, scale=sig)
plt.plot(x, y, 'r')
plt.xlim(50, 150)
plt.ylabel('probability')
plt.subplot(212)
b = plt.hist(data, bins=20, range=(50, 150), cumulative=True, \
             density=True, align='right')
y = norm.cdf(x, mu, sig)
plt.plot(x, y, 'r')
plt.xlim(50, 150)
plt.xlabel('bins')
plt.ylabel('probability');"
"mu = 20
sig = 4
p25, p75 = norm.ppf([0.25, 0.75], loc=mu, scale=sig)
print('IQR pdf:', p25, p75)
data = rnd.normal(loc=mu, scale=sig, size=100)
d25, d75 = np.percentile(data, [25, 75])
print('IQR of data ', d25, d75)
plt.hist(data, bins=20, cumulative=True, density=True, align='right')
plt.axvline(d25, color='r')
plt.axvline(d75, color='r')
plt.axvline(p25, color='k')
plt.axvline(p75, color='k')
plt.xlabel('bins')
plt.ylabel('cumulative number of data points');"
"print('mean moisture content: ', w.moisture.mean())
print('standard deviation of moisture content: ', w.moisture.std())
a = plt.boxplot(w.moisture)"
"plt.boxplot(w.moisture[w.moisture < 30])
plt.ylim(10.5, 17);"
"w.hist(column='bstrength', density=True)
plt.xlabel('bending strength (N/m$^2$)')
five = w.bstrength.quantile(0.05)
print('5 empirical percentile: ', five)
plt.axvline(five, color='r');"
"from scipy.stats import norm
w.hist(column='bstrength', density=True)
meanstrength = w.bstrength.mean()
stdstrength = w.bstrength.std()
x = np.linspace(0, 100, 100)
y = norm.pdf(x, loc=meanstrength, scale=stdstrength)
plt.plot(x, y, 'r')
plt.axvline(five, color='r')
plt.axvline(meanstrength - 1.64 * stdstrength, color='k');"
"for i in range(5):
    a = 2 * rnd.standard_normal(100) + 4
    print('mean a:', np.mean(a))"
"from scipy.stats import norm
xvalue_05 = norm.ppf(0.05)
xvalue_95 = norm.ppf(0.95)
print('5% limit:', xvalue_05)
print('95% limit:', xvalue_95)
print('check if it works for 5%:', norm.cdf(xvalue_05))
print('check if it works for 95%:', norm.cdf(xvalue_95))
# Next, specify a mean and standard deviation
xvalue_05_musig = norm.ppf(0.05, loc=20, scale=10) # mu = 20, sigma = 10
print('5% limit with mu=20, sig=10:', xvalue_05_musig)
print('check:', norm.cdf(xvalue_05_musig, loc=20, scale=10))"
"from scipy.stats import t
xvalue_05 = t.ppf(0.05, 39, loc=20, scale=2)
xvalue_95 = t.ppf(0.95, 39, loc=20, scale=2)
print('5% limit:  ',xvalue_05)
print('95% limit: ',xvalue_95)
print('check if it works for 5%:', t.cdf(xvalue_05, 39, loc=20, scale=2))
print('check if it works for 95%:', t.cdf(xvalue_95, 39, loc=20, scale=2))"
"print('95 percentile Standard Normal:  ',norm.ppf(0.95))
print('95 percentile t-dist with n=99: ',t.ppf(0.95,99)) 
x = np.linspace(-4,4,100)
y1 = norm.pdf(x)
y2 = t.pdf(x,99)
plt.plot(x,y1,'b',label='Normal')
plt.plot(x,y2,'r',label='t-dist')
plt.legend();"
"from scipy.stats import gamma
x = np.linspace(1e-6, 10, 100)
y = gamma.pdf(x, 2, scale=1)
plt.plot(x, y)
plt.axvline(2, color='r');"
"x = np.linspace(1e-6, 10, 100)
y = gamma.pdf(x, 2)
plt.plot(x, y)
plt.axvline(2, color='r')
data = gamma.rvs(2, size=1000)
plt.hist(data, bins=20, normed=True);"
"rnd.seed(22)
mean_of_data = np.mean(2 * rnd.standard_normal((1000, 100)) + 4, 1)
print('The mean of the means is:', np.mean(mean_of_data))
print('The standard deviation of the means is:', np.std(mean_of_data, ddof=1))
plt.figure()
plt.boxplot(mean_of_data)
plt.ylim(3, 5)
plt.figure()
plt.hist(mean_of_data, normed=True)
plt.xlim(3,5)"
"rnd.seed(22)
mean_of_data = np.mean(2 * rnd.standard_normal((1000, 1000)) + 4, 1)
print('The mean of the means is:', np.mean(mean_of_data))
print('The standard deviation of the means is:', np.std(mean_of_data, ddof=1))
plt.figure()
plt.boxplot(mean_of_data)
plt.ylim(3,5)
plt.figure()
plt.hist(mean_of_data)
plt.xlim(3, 5)"
"rnd.seed(2)
data = 4 * rnd.standard_normal(20) + 39
mu = np.mean(data)
sig = np.std(data, ddof=1)
sighat = np.std(data, ddof=1) / np.sqrt(20)
print('mean of the data:', mu)
print('std of the data:', sig)
print('std of the mean:', sighat)"
"x = np.linspace(37, 43, 100)
y = t.pdf(x, 19, loc=40, scale=sighat)
plt.plot(x, y)
perc025 = t.ppf(0.025, 19, loc=40, scale=sighat)
perc975 = t.ppf(0.975, 19, loc=40, scale=sighat)
plt.axvline(perc025, color='r')
plt.axvline(perc975, color='r')
plt.axvline(mu, color='k', lw=5)
plt.title('H0 cannot be rejected');"
"from pandas import read_csv
w = read_csv('douglas_data.csv', skiprows=[1], skipinitialspace=True)
mu20 = np.mean(w.bstrength[:20])
sig20 = np.std(w.bstrength[:20], ddof=1) / np.sqrt(20)
print('sample mean, standard deviation of sample mean: ', mu20, sig20)
x = np.linspace(30,70,100)
y = t.pdf(x, 19, loc=50, scale=sig20)
plt.plot(x,y)
perc025 = t.ppf(0.025, 19, loc=50, scale=sig20)
perc975 = t.ppf(0.975, 19, loc=50, scale=sig20)
plt.axvline(perc025, color='r')
plt.axvline(perc975, color='r')
plt.axvline(mu20, color='k', lw=4)
plt.title('H0 is rejected: mean is not 50 Pa');"
"from pandas import read_csv
w = read_csv('douglas_data.csv', skiprows=[1], skipinitialspace=True)
N = len(w.bstrength)
mu = np.mean(w.bstrength)
sig = np.std(w.bstrength, ddof=1) / np.sqrt(N)
print('sample mean, standard deviation of sample mean: ', mu, sig)
x = np.linspace(30, 70, 100)
y = t.pdf(x, N - 1, loc=50, scale=sig)
plt.plot(x, y)
perc025 = t.ppf(0.025, N - 1, loc=50, scale=sig)
perc975 = t.ppf(0.975, N - 1, loc=50, scale=sig)
plt.axvline(perc025, color='r')
plt.axvline(perc975, color='r')
plt.axvline(mu, color='k', lw=4)
plt.title('Not enough evidence to reject H0: mean may very well be 50');"
"from scipy.stats import norm, gamma
for N in [100, 1000, 10000]:
    data = gamma.rvs(2, size=(N, 20))
    mean_of_data = np.mean(data, 1)
    mu = np.mean(mean_of_data)
    sig = np.std(mean_of_data, ddof=1)
    plt.figure()
    plt.hist(mean_of_data, bins=20, normed=True)
    x = np.linspace(0, 4, 100)
    y = norm.pdf(x, loc=mu, scale=sig)
    plt.plot(x, y, 'r')
    plt.title('N=' + str(N))"
"def square_me(func, x):
    return func(x) ** 2
print('result of square_me function:', square_me(np.cos, 4))
print('directly taking the square  :', np.cos(4) ** 2)"
"def f(x):
    return 0.5 - np.exp(-x)

x = np.linspace(0, 4, 100)
y = f(x)
plt.plot(x, y)
plt.axhline(0, color='r', ls='--')"
"xzero = bisection(func=f, x1=0, x2=4, nmax=20)  
print('zero of function and function value: ', xzero, f(xzero))  "
"print('starting at x=1')
xzero = newtonsmethod(func=f, funcp=fp, xs=1)
print('xzero, f(xzero) ', xzero, f(xzero))

print('starting at x=4')
xzero = newtonsmethod(func=f, funcp=fp, xs=4, nmax=40)
print('xzero, f(xzero) ', xzero, f(xzero))"
"xzero = newtonsmethod(func=np.sin, funcp=np.cos, xs=1)
print('starting point is x=1')
print('xzero, sin(xzero):', xzero, np.sin(xzero))

xzero = newtonsmethod(func=np.sin, funcp=np.cos, xs=1.5)
print('starting point is x=1.5')
print('xzero, sin(xzero):', xzero, np.sin(xzero))
print('xzero / pi:', xzero / np.pi)"
"from scipy.optimize import fsolve
def h(x):
    return np.log(x ** 2) - 2

x0 = fsolve(h, 1)
print('x0, function value', x0, h(x0))"
"from scipy.optimize import fsolve
def g(x):
    return x + 2 * np.cos(x)
x = np.linspace(-2, 4, 100)
x0 = fsolve(g, 1)
plt.plot(x, g(x))
plt.plot(x0, g(x0), 'ro')
plt.axhline(y=0, color='r')"
"xp = np.array([-2, 1, 4])
yp = np.array([2, -1, 4])
A = np.zeros((3, 3))
rhs = np.zeros(3)
for i in range(3):
    A[i] = xp[i] ** 2, xp[i], 1  # Store one row at a time
    rhs[i] = yp[i]
print('Array A:')
print(A)
print('rhs:',rhs)"
"plt.plot(xp, yp, 'ro')
x = np.linspace(-3, 5, 100)
y = sol[0] * x ** 2 + sol[1] * x + sol[2]
plt.plot(x, y, 'b');"
"import scipy.sparse as sp
A = sp.diags([1 * np.ones(3), 
              2 * np.ones(4), 
              3 * np.ones(3)], 
             [-1, 0, 1], format='csc')
print('Sparse matrix A')
print(A) # Gives the way A is stored: row, column, value
print('Full matrix A as an array')
print(A.toarray())  # Returns the equivalent full array"
"from scipy.sparse.linalg import spsolve
print('type of A:', type(A))
b = np.arange(4)
x = spsolve(A,b)  # x is solution of Ax=b
print('right-hand-side defined as:', b)
print('verify A @ x gives same:', A @ x)"
"tp = np.array([0, 0.25, 0.5, 0.75])
yp = np.array([ 3, 1, -3, 1])
A = np.zeros((4, 4))
rhs = np.zeros(4)
for i in range(4):
    A[i] = np.cos(1 * np.pi * tp[i]), np.cos(2 * np.pi * tp[i]), \
           np.cos(3 * np.pi * tp[i]), np.cos(4 * np.pi * tp[i])  # Store one row at a time
    rhs[i] = yp[i]
sol = np.linalg.solve(A, rhs)
print('a,b,c,d: ',sol)

t = np.linspace(0, 1, 100)
y = sol[0] * np.cos(1 * np.pi * t) + sol[1] * np.cos(2 * np.pi * t) + \
    sol[2] * np.cos(3 * np.pi * t) + sol[3] * np.cos(4 * np.pi * t)
plt.plot(t, y, 'b', label='wave')
plt.plot(tp, yp, 'ro', label='data')
plt.legend(loc='best');"
"def fpoly(x, N):
    rv = np.zeros(N + 1)
    for n in range(N + 1):
        rv[n] = x ** n
    return rv

print(fpoly(2, 4))"
"x = np.linspace(-1,4,100)
y = fpolyeval(x, a)
plt.plot(xp, yp, 'ko', label='data')
plt.plot(x, y, label='fitted poly')
plt.legend(loc='best');"
"k = 10
D = 10
h1star = 20
h2star = 22
L = 1000
P = 0.001
N = 40

d0 = -2 * np.ones(N + 1)  # main diagonal
d0[0] = 1  # first value of main diagonal is 1
d0[-1] = 1 # last value of main diagonal is 1
dplus1 = np.ones(N) # diagonal right above main diagonal, position 1
dplus1[0] = 0    # first value of diagonal is 0
dmin1 = np.ones(N)  # diagonal right below main diagonal, position -1
dmin1[-1] = 0    # last value of diagonal is 0
A = np.diag(d0, 0) + np.diag(dplus1, 1) + np.diag(dmin1, -1)
# Right hand side
delx = L / N
rhs = -P * delx ** 2 / (k * D) * np.ones(N + 1)
rhs[0] = h1star
rhs[-1] = h2star
# Solve for the head and plot
h = np.linalg.solve(A, rhs)
x = np.linspace(0, L, N + 1)
plt.plot(x, h)
plt.xlabel('x (m)')
plt.ylabel('head (m)')
print('maximum head ', np.max(h))"
"cv = 1e-6  # m^2/s
h = 2  # m
N = 40
delt = 4e4  # seconds
#
delz = h / N
mu = delz ** 2 / (cv * delt)

d0 = -(2 + mu) * np.ones(N + 1)
d0[-1] = 1
dp1 = np.ones(N)
dp1[0] = 2
dm1 = np.ones(N)
dm1[-1] = 0
A = np.diag(d0) + np.diag(dp1, 1) + np.diag(dm1, -1)

p = np.ones(N + 1)
for i in range(5):
    for j in range(10):
        rhs = -mu * p
        rhs[-1] = 0
        p = np.linalg.solve(A, rhs)
    plt.plot(np.arange(0, h + 0.01, delz), p, label=str((i + 1) * 10) + ' timesteps')
    print('maximum value after', 10 * ( i + 1), 'timesteps is:', p[0])
plt.xlim(0, 2)
plt.legend(loc='best')
plt.xlabel('z')
plt.ylabel('p')
plt.yticks(np.linspace(0, 1, 11))
plt.title('Consolidation');"
"cv = 1e-6  # m^2/s
h = 2  # m
N = 40
delt = 4e4  # seconds
#
delz = h / N
mu = delz ** 2 / (cv * delt)

d0 = -(2 + mu) * np.ones(N + 1)
d0[-1] = 1
dp1 = np.ones(N)
dp1[0] = 2
dm1 = np.ones(N)
dm1[-1] = 0
A = np.diag(d0) + np.diag(dp1, 1) + np.diag(dm1, -1)
Ainv = np.linalg.inv(A)

p = np.ones(N + 1)
for i in range(5):
    for j in range(10):
        rhs = -mu * p
        rhs[-1] = 0
        p = Ainv @ rhs
    plt.plot(np.arange(0, h + 0.01, delz), p, label=str((i + 1) * 10) + ' timesteps')
    print('maximum value after', 10 * ( i + 1), 'timesteps is:', p[0])
plt.xlim(0, 2)
plt.legend(loc='best')
plt.xlabel('z')
plt.ylabel('p')
plt.yticks(np.linspace(0, 1, 11))
plt.title('Consolidation');"
"from scipy.sparse import diags
from scipy.sparse.linalg import spsolve 
k = 10
D = 10
h1star = 42
h2star = 40
L = 1000
P = 0.001
N = 10000
d0 = -2 * np.ones(N + 1)  # main diagonal
d0[0] = 1  # first value of main diagonal is 1
d0[-1] = 1 # last value of main diagonal is 1
dplus1 = np.ones(N) # diagonal right above main diagonal, position 1
dplus1[0] = 0    # first value of diagonal is 0
dmin1 = np.ones(N)  # diagonal right below main diagonal, position -1
dmin1[-1] = 0    # last value of diagonal is 0
A = diags([dmin1, d0, dplus1], [-1, 0, 1], format='csc')
# Right hand side
delx = L / N
rhs = -P * delx ** 2 / (k * D) * np.ones(N + 1)
rhs[0] = h1star
rhs[-1] = h2star
h = spsolve(A, rhs)
plt.plot(h)
plt.xlabel('node number')
plt.ylabel('head (m)');"
tran.plot();  # plot all columns
tran['bus'].plot(kind='bar');
"rain = read_csv('rotterdam_rainfall_2012.txt', skiprows=9,
                parse_dates=['YYYYMMDD'], index_col='YYYYMMDD',
                skipinitialspace=True)
rain.RH[rain.RH<0] = 0  # remove negative values
rain.RH = rain.RH * 0.1 # convert to mm/day
monthlyrain = rain.RH.resample('M', kind='period').sum()
display(monthlyrain)
monthlyrain.plot(kind='bar')
plt.ylabel('mm/month')
plt.xlabel('month');"
"rain['totalq'] = rain.precip * rain.area * 1e-3
#
print('Five countries with largest annual influx:')
rain.sort_values(by='totalq', ascending=False, inplace=True)
print(rain[:5])
#
rain.totalq[:10].plot(kind='bar');"
"rain = read_csv('rotterdam_rainfall_2012.txt', skiprows=9,
                parse_dates=['YYYYMMDD'], skipinitialspace=True)
# convert to mm/d
rain.iloc[:,2] = rain.iloc[:,2] * 0.1
# set negative values to zero
rain.loc[rain.RH < 0, 'RH'] = 0
rain.RH.plot()
plt.xlabel('day')
plt.ylabel('daily rainfall (mm/day)')
plt.xlim(0, 365)
print('Maximum daily rainfall', rain.RH.max())
print('Date of maximum daily rainfall', rain.YYYYMMDD[rain.RH.idxmax()])"
"monthlyrain = np.zeros(12)
for i in range(len(rain)):
    month = rain.iloc[i,1].month
    monthlyrain[month - 1] += rain.iloc[i, 2]
print(monthlyrain)
#
plt.bar(np.arange(12), monthlyrain, width=0.8)
plt.xlabel('month')
plt.ylabel('monthly rainfall (mm/month)')
plt.xticks(np.arange(12), ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']);"
"weather = read_csv('rotterdam_weather_2000_2010.txt', skiprows=11,
                parse_dates=['YYYYMMDD'], index_col='YYYYMMDD', skipinitialspace=True)
weather.TG = 0.1 * weather.TG
weather.RH = 0.1 * weather.RH
weather.EV24 = 0.1 * weather.EV24
weather.loc[weather.RH < 0, 'RH'] = 0
yearly_rain = weather.RH.resample('A', kind='period').sum()
yearly_evap = weather.EV24.resample('A', kind='period').sum()
yearly_temp = weather.TG.resample('A', kind='period').mean()
ax1 = yearly_rain.plot()
ax1 = yearly_evap.plot()
plt.ylabel('Rain/evap (mm/year)')
ax2 = yearly_temp.plot(secondary_y=True)
plt.xlabel('Year')
plt.ylabel('Mean yearly temperature (deg C)')
plt.legend(ax1.get_lines() + ax2.get_lines(),
           ['rain', 'evap', 'temp'], loc='best');"
"rnd.randint(0, 1+1, 10)"
"rnd.randint(0, 1+1, 10)"
"plt.bar(range(0, 3), number_of_tails)
plt.xticks(range(0, 3))
plt.xlabel('number of tails')
plt.ylabel('occurence in 100 trials');"
"plt.bar(range(0, 3), cum_prob, width=1)
plt.xticks(range(0, 3))
plt.xlabel('number of tails in two flips')
plt.ylabel('cumulative probability');"
"N = 1000
tails = np.sum(rnd.randint(0, 1+1, (5, 1000)), axis=0)
counttails = np.zeros(6, dtype='int')
for i in range(6):
    counttails[i] = np.count_nonzero(tails == i)
plt.bar(range(0, 6), counttails / N)
plt.xlabel('number of tails in five flips')
plt.ylabel('probability');"
"cumprob = np.cumsum(counttails / N)
print('cumprob:', cumprob)
plt.bar(range(0, 6), cumprob, width=1)
plt.xlabel('number of tails in five flips')
plt.ylabel('cumulative probability');"
"dice = rnd.randint(1, 6+1, (2, 1000))
highest_dice = np.max(dice, 0)
outcome = np.zeros(6)
for i in range(6):
    outcome[i] = np.sum(highest_dice == i+1) / 1000
plt.bar(np.arange(1, 7), height=outcome, width=1)
plt.xlabel('highest dice in two throws')
plt.ylabel('probability');"
"coins = data.coins()
edges = filters.sobel(coins)

plt.imshow(edges, cmap='gray');"
"# You can ignore the code below--it's just
# to make a pretty plot of the results.
fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(y, '-o', label='Image slice', linewidth=3)
ax.plot(seed_positions, np.zeros_like(seed_positions), 'r^',
        label='Seeds', markersize=15)

for n, label in enumerate(np.unique(result)):
    mask = (result == label)
    ax.bar(x[mask][:-1], result[mask][:-1],
           width=1, label='Region %d' % n,
           alpha=0.1)

ax.vlines(np.argwhere(np.diff(result)) + 0.5, -0.2, 4.1, 'm',
          linewidth=3, linestyle='--')

from scipy.interpolate import interp1d

#c = interp1d(x, y, kind='cubic')
#t = np.linspace(0, len(y) - 1, 100)
#ax.plot(t, c(t), 'g')

ax.legend(loc='upper left', numpoints=1)
ax.axis('off')
ax.set_ylim(-0.2, 4.1);"
"threshold = filters.threshold_otsu(edges)
print(threshold)
# Euclidean distance transform
# How far do we have to travel from a non-edge to find an edge?
non_edges = (edges < threshold)
distance_from_edge = ndi.distance_transform_edt(non_edges)

plt.imshow(distance_from_edge, cmap='viridis');"
"from skimage import feature

# -------------------------------------------------#
peaks = feature.peak_local_max(distance_from_edge, min_distance=10)
print(""Peaks shape:"", peaks.shape)
# -------------------------------------------------#

peaks_image = np.zeros(coins.shape, np.bool)
peaks_image[tuple(np.transpose(peaks))] = True
seeds, num_seeds = ndi.label(peaks_image)

plt.imshow(edges, cmap='gray')
plt.plot(peaks[:, 1], peaks[:, 0], 'ro');
plt.axis('image')"
"ws = watershed(edges, seeds)

from skimage import color
plt.imshow(color.label2rgb(ws, coins));"
"from skimage import segmentation
plt.imshow(segmentation.mark_boundaries(coins, seg_coins))"
"%matplotlib inline
sns.barplot(x=x1, y=y1)

"
"sns.barplot(x=x2, y=y2)"
"import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
import numpy as np

%matplotlib inline

x = np.arange(-5, 5.1, 0.1)

def sigmoid(vec):
    return 1/(1+np.exp(-x))
    
def tanh_activation(vec):
    return (np.exp(x) - np.exp(-x))/(np.exp(x) + np.exp(-x))

def rectlinear(vec):
    output = vec.copy()
    output[vec<0] = 0
    return output

plt.figure(figsize=(8,8))
plt.subplot(2,2,1)
plt.plot(x, x)
plt.subplot(2,2,2)
plt.plot(x, sigmoid(x))
plt.subplot(2,2,3)
plt.plot(x, tanh_activation(x))
plt.subplot(2,2,4)
plt.plot(x, rectlinear(x))
plt.show()"
"sigma = np.array([[0.14,-0.1],[-0.1,0.14]])
mu1 = np.array([-0.4,0.2])
mu2 = np.array([0.4,0.5])

d1 = np.random.multivariate_normal(mean=mu1, cov=sigma, size=200)
d2 = np.random.multivariate_normal(mean=mu2, cov=sigma, size=200)

x1 = np.concatenate((d1[:,0], d2[:,0]))
x2 = np.concatenate((d1[:,1], d2[:,1]))
labels = np.concatenate((['Positive']*d1.shape[0], 
                         ['Negative']*d2.shape[0]))

df = pandas.DataFrame(dict(x1=x1, x2=x2, y=labels))

df = df.reindex(np.random.permutation(df.index))

sns.lmplot(""x1"", ""x2"", hue=""y"", data=df, fit_reg=False)"
""
"import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
import math
%matplotlib inline

def idf1(N, df):
    return math.log10(1. * N / df)
def idf2(N, df):
    return math.log10(1. * (N - df) / df)

N = 1000000
dfs = range(1,100000)[::1000]
plt.figure()
idfs1 = [idf1(N, df) for df in dfs]
idfs2 = [idf2(N, df) for df in dfs]
plt.plot(dfs, [idf1(N, df) for df in dfs], 'bo-')
plt.plot(dfs, [idf2(N, df) for df in dfs], 'r.')
plt.show()
print(idfs1[:10] + idfs1[-10:])
print(idfs2[:10] + idfs2[-10:])"
"print(ngrams(1, ['a b c']))
print(ngrams(2, ['a b c']))
print(ngrams(3, ['a b c']))
print(ngrams(4, ['a b c']))"
"%pylab inline
# 1-grams, 1-grams + 2-grams, ...
x = [sum(sizes[:i]) for i in range(1,max_n)]
print(x)
plot(x)
xlabel('ngram size')
ylabel('number of terms')"
"def doc2model_smooth(doc, smooth_term, vocab):
    """"""Convert a document d into a language model M_d using Laplacian (+1) smoothing.""""""
    counts = Counter(doc)
    for term in vocab:
        counts[term] = (counts[term] + smooth_term) / (1. * len(doc) + smooth_term * len(vocab))
    return counts

vocab = ['the', 'united', 'states', 'won', 'nine', 'gold', 'medals', 'in', 'olympics']

m_d = doc2model_smooth(['the', 'united', 'states', 'won', 'nine', 'gold', 'medals',
                        'in', 'the', 'olympics'],
                       smooth_term=1, vocab=vocab)
m_d"
"# Use same function to create a query model.
m_q = doc2model_smooth(['the', 'olympics'], smooth_term=1, vocab=vocab)
m_q"
"def mse(m_q, m_d):
    terms = m_q.keys() | m_d.keys()
    return np.mean(([(m_q[t] - m_d[t])**2 for t in terms]))

mse(m_q, m_d)"
"def kl(m_q, m_d):
    return np.mean(([ m_q[t] * math.log2(m_q[t] / m_d[t]) for t in m_q]))
kl(m_q, m_d)"
"def entropy(p):
    return -sum(pi * math.log2(pi) for pi in p.values())

probs = np.arange(1,10) / 10
entropies = [entropy({'a': p, 'b': 1 - p}) for p in probs]
plt.figure()
plt.plot(probs, entropies)
plt.xlabel('P(a)', size=16)
plt.ylabel('H(P)', size=16)
plt.title('Entropy is maximized when P(a)=P(b)=.5', size=15)
plt.show()"
"# How do these different measures compare?

def plot_measures(m_q2):
    maes = []
    mses = []
    cosines = []
    kls = []

    # Loop over possible document distributions.
    probs = np.arange(1,10) / 10
    for pi in probs:
        m_d2 = {'a': pi, 'b': 1 - pi}
        print(m_d2)
        maes.append(mae(m_q2, m_d2))
        mses.append(mse(m_q2, m_d2))
        cosines.append(cosine(m_q2, m_d2))
        kls.append(kl(m_q2, m_d2))

    # plot.
    plt.figure(figsize=(10,5))
    plt.plot(probs, maes, label='mae')
    plt.plot(probs, mses, label='mse')
    plt.plot(probs, cosines, label='1-cosine')
    plt.plot(probs, kls, label='kl')
    plt.xlabel('$P(a|M_d)$', size=16)
    plt.ylabel('distance($M_q, M_d$)', size=16)
    plt.legend(loc='best')
    plt.show()
    
plot_measures({'a': .5, 'b': .5})"
"plot_measures({'a': .9, 'b': .1})"
"print(hash('dog'))
print(hash('cat'))
# See the Python's implementation of hash here: 
# http://stackoverflow.com/questions/2070276/where-can-i-find-source-or-algorithm-of-pythons-hash-function"
"# What's a defaultdict?
from collections import defaultdict
d = {}
# d['zebra'] # KeyError
# Adding default values is a bit of a pain...
if 'zebra' in d:
    d['zebra'] += 1
else:
    d['zebra'] = 0


# defaultdict does it for you:
d2 = defaultdict(lambda: 0)
d2['zebra'] = 10
d2['cat'] = 20
d2['dog']  # NB: Looking up a key inserts it in the default dict.
print('mouse=', d2['mouse'])
print(d2)

# value is the length of the dictionary
d3 = defaultdict(lambda: len(d3))
d3['zebra']
d3['cat']
d3['dog']  
print(d3)"
"# This is what linear looks like....
%pylab inline
plot([54 * x + 25 for x in range(20)])"
"import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
%matplotlib inline

plt.figure(figsize=(8,4))
plt.scatter([0,0], [0, 1], color='b')
plt.scatter([10,10], [0, 1], color='r', marker='^')
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.xlabel('term 1')
plt.ylabel('term 2')
plt.show()

plt.figure(figsize=(8,4))
plt.scatter([0,0], [0, 1], color='b')
plt.scatter([10,10], [0, 1], color='r', marker='^')
plt.annotate('$\mu_1$', xy=(5,1), size=20)
plt.scatter([5], [1], color='k')
plt.annotate('$\mu_2$', xy=(5,0), size=20)
plt.scatter([5], [0], color='k')
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.xlabel('term 1')
plt.ylabel('term 2')
plt.show()

plt.figure(figsize=(8,4))
plt.scatter([0,10], [1, 1], color='b')
plt.scatter([0,10], [0, 0], color='r', marker='^')
plt.annotate('$\mu_1$', xy=(5,1), size=20)
plt.scatter([5], [1], color='k')
plt.annotate('$\mu_2$', xy=(5,0), size=20)
plt.scatter([5], [0], color='k')
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.xlabel('term 1')
plt.ylabel('term 2')
plt.show()"
"# Here's an example. 
# Exercise: work out the means/cluster assignments
# until convergence.
def plot(points, cluster_assignments, means):
    plt.figure()
    for point, asg in zip(points, cluster_assignments):
        plt.scatter([point[0]], [point[1]], marker='o' if asg==1 else '^')
    for i, m in enumerate(means):
        plt.annotate('$\mu_%d$' % i, xy=m, size=20)
        plt.scatter([m[0]], [m[1]], color='k')
    plt.show()
    
plot([(0, 0), (0, 1), (2, 0), (3,1), (3,0)], [0,0,0,1,1], [(1,0), (4,0)])"
"import warnings
warnings.filterwarnings('ignore')
%pylab inline

# Compare arithmetic mean of precision and recall to F1 for fixed precision of 50%.

def arith_mean(p, r):
    return (p + r) / 2.0

def f1(p, r):
    return (2.0 * p * r) / (p + r)

p = .5
r = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1.0]

xlabel('recall')
ylabel('mean')
plot(r, [arith_mean(p, ri) for ri in r], label='arithmetic')
plot(r, [f1(p, ri) for ri in r], label='f1')
legend(loc='best')"
"xlabel('recall')
ylabel('precision')
plot([.2, .3], [.4, .3], 'bo')
xlim((0, .4))
ylim((0, 1.1))"
"# compute precision/recall at each sublist of size 1 to 10
xlabel('recall')
ylabel('precision')
precisions = [1, .5, .33, .5, .4, .5, .43, .375, .33, .3]
recalls = [.1, .1, .1, .2, .2, .3, .3, .3, .3, .3]
plot(recalls, precisions, 'bo')
xlim((0, .4))
ylim((0, 1.1))"
"# Interpolated precision: max of precisions to right of value
xlabel('recall')
ylabel('precision')
interpolated_pre = [max(precisions[i:]) for i in range(len(precisions))]
print(interpolated_pre)
step(recalls, interpolated_pre, 'bo')
xlim((0, .4))
ylim((0, 1.1))"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo

YouTubeVideo(""x4xegDME5C0"", width=560, height=315, list=""PLGBbVX_WvN7as_DnOGcpkSsUyXB1G_wqb"")"
help(np.linalg)
"from numpy.linalg import norm, det
norm"
np.dot
np.linalg.det(H)
"np.isclose(np.dot(Hinv, H), np.eye(6))"
"np.set_printoptions(precision=3)
print(np.dot(Hinv, H))"
np.linalg.cond(H)
"A = np.array([
    [1, 0, 0],
    [2, 1, 1],
    [-1, 0, 1]
])

np.linalg.eig(A)"
"M = np.arange(36, dtype=float).reshape(4, 9)
M"
"# De la segunda a la tercera fila, incluida
M[1:3]"
"# Hasta la tercera fila sin incluir y de la segunda a la quinta columnas saltando dos
M[:2, 1:5:2]
#M[1:2:1, 1:5:2]  # Equivalente"
"%matplotlib inline
import matplotlib.pyplot as plt

plt.matshow(tablero, cmap=plt.cm.gray_r)"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
#para ver la versión que tenemos instalada:
np.__version__"
np.empty(10)
"array = np.array([ 1, 1+2j, True, 'aerodinamica'])
array"
"print(id(lista))
lista.append('fluidos')
print(lista)
print(id(lista))"
"print(id(array))
array = np.append(array, 'fluidos')
print(array)
print(id(array))"
"%%timeit
sum(lista)"
"%%timeit
np.sum(array)"
"%%timeit
np.linspace(0,100,1000000)"
"%%timeit
my_linspace_FORTRAN(0,100,1000000)"
"%%timeit
my_linspace_PYTHONIC(0,100,1000000)"
"plt.figure(""Evolución temporal"", figsize=(8,5))
plt.title(""Evolución temporal"")
plt.plot(t, solucion[:, 0], label='presa')
plt.plot(t, solucion[:, 1], label='depredador')
plt.xlabel('tiempo')
plt.ylabel('población')
plt.legend()
# plt.savefig('evolucion_temporal.png')"
"plt.figure(""Presas vs depredadores"", figsize=(8,5))
plt.plot(solucion[:, 0], solucion[:, 1])
plt.xlabel('presas')
plt.ylabel('depredadores')
# plt.savefig('presas_vs_depredadores.png')"
"x_max = np.max(solucion[:,0]) * 1.05
y_max = np.max(solucion[:,1]) * 1.05

x = np.linspace(0, x_max, 25)
y = np.linspace(0, y_max, 25)

xx, yy = np.meshgrid(x, y)
uu, vv = df_dt((xx, yy), 0, a, b, c, d)
norm = np.sqrt(uu**2 + vv**2)
uu = uu / norm
vv = vv / norm

plt.figure(""Campo de direcciones"", figsize=(8,5))
plt.quiver(xx, yy, uu, vv, norm, cmap=plt.cm.gray)
plt.plot(solucion[:, 0], solucion[:, 1])
plt.xlim(0, x_max)
plt.ylim(0, y_max)
plt.xlabel('presas')
plt.ylabel('depredadores')
# plt.savefig('campo_direcciones.png')"
"n_max = np.max(solucion) * 1.10

fig, ax = plt.subplots(1,2)

fig.set_size_inches(12,5)

ax[0].quiver(xx, yy, uu, vv, norm, cmap=plt.cm.gray)
ax[0].plot(solucion[:, 0], solucion[:, 1], lw=2, alpha=0.8)
ax[0].set_xlim(0, x_max)
ax[0].set_ylim(0, y_max)
ax[0].set_xlabel('presas')
ax[0].set_ylabel('depredadores')

ax[1].plot(t, solucion[:, 0], label='presa')
ax[1].plot(t, solucion[:, 1], label='depredador')
ax[1].legend()
ax[1].set_xlabel('tiempo')
ax[1].set_ylabel('población')
# plt.savefig('campo_direcciones_ev_temporal.png')"
"x = np.linspace(0, x_max, 100)
y = np.linspace(0, y_max, 100)
xx, yy = np.meshgrid(x, y)
constant = C(xx, yy, a, b, c, d)

plt.figure('distintas_soluciones', figsize=(8,5))
plt.contour(xx, yy, constant, 50, cmap=plt.cm.Blues)
plt.xlabel('presas')
plt.ylabel('depredadores')
# plt.savefig('distintas_soluciones.png')"
"#n_max = np.max(solucion) * 1.10

fig, ax = plt.subplots(1,2)

fig.set_size_inches(12,5)

ax[0].plot(solucion[:, 0], solucion[:, 1], lw=2, alpha=0.8)
ax[0].scatter(c/d, a/b)
levels = (0.5, 0.6, 0.7, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.775, 0.78, 0.781)
ax[0].contour(xx, yy, constant, levels, colors='blue', alpha=0.3)
ax[0].set_xlim(0, x_max)
ax[0].set_ylim(0, y_max)
ax[0].set_xlabel('presas')
ax[0].set_ylabel('depredadores')

ax[1].plot(t, solucion[:, 0], label='presa')
ax[1].plot(t, solucion[:, 1], label='depredador')
ax[1].legend()
ax[1].set_xlabel('tiempo')
ax[1].set_ylabel('población')
# plt.savefig('distintas_soluciones_ev_temporal.png')"
"x_ = np.linspace(0,10)
plt.figure('función logística', figsize=(8,5))
plt.plot(x_, logistic_curve(x_, 1, m=10, n=100, tau=1))
# plt.savefig('funcion_logistica.png')"
"n_max = np.max(solucion) * 1.10

fig, ax = plt.subplots(1,2)

fig.set_size_inches(12,5)

x_max = np.max(solucion_logistic[:,0]) * 1.05
y_max = np.max(solucion_logistic[:,1]) * 1.05

x = np.linspace(0, x_max, 25)
y = np.linspace(0, y_max, 25)

xx, yy = np.meshgrid(x, y)
uu, vv = df_dt_logistic((xx, yy), 0, a, b, c, d, r)
norm = np.sqrt(uu**2 + vv**2)
uu = uu / norm
vv = vv / norm

ax[0].quiver(xx, yy, uu, vv, norm, cmap=plt.cm.gray)
ax[0].plot(solucion_logistic[:, 0], solucion_logistic[:, 1], lw=2, alpha=0.8)
ax[0].set_xlim(0, x_max)
ax[0].set_ylim(0, y_max)
ax[0].set_xlabel('presas')
ax[0].set_ylabel('depredadores')

ax[1].plot(t, solucion_logistic[:, 0], label='presa')
ax[1].plot(t, solucion_logistic[:, 1], label='depredador')
ax[1].legend()
ax[1].set_xlabel('tiempo')
ax[1].set_ylabel('población')
# plt.savefig('campo_direcciones_ev_temporal_caso2.png')"
from IPython.html.widgets import interact
"interact(solucion_temporal_interact,
         a=(0.01,0.5), b=(0.01,0.5),
         c=(0.01,0.5), d=(0.01,0.5),
         x0=(1,80), y0=(1,50),
         tf=(50,300));"
"interact(mapa_fases_interact,
         a=(0.01,0.5), b=(0.01,0.5),
         c=(0.01,0.5), d=(0.01,0.5),
         x0=(1,80), y0=(1,50),
         tf=(50,300));"
"help(my_dict)
"
"my_generator = get_person()

print(my_generator)"
print(next(my_generator))
"import random
def get_int(n):
    last_value = 0
    while True:
        new_value = random.randint(1, n)
        print(""Yielding 0"")
        yield 0
        last_value = new_value
        print(""Yielding new value"")
        yield new_value
        
times = 50

for x in get_int(500):
    print(x)
    times -= 1
    if times == 0:
        break"
w
"norder = 4
nsim = 10
nbasepoints = 100

discount = 0.6
C, beta, xmax = -30, 2, 10
keep_action, replace_action = 0, 1

weights = np.zeros((norder+1,))

rng = np.random.RandomState(1234)
basepoints = rng.uniform(0, 10, nbasepoints)
rewards_keep = -4.*basepoints
reward_replace = C

for i in range(40):
    next_states_keep = rng.exponential(beta, (nbasepoints, nsim)) + basepoints[:,np.newaxis]
    overbound_states = (next_states_keep > xmax)
    next_states_keep[overbound_states] = rng.exponential(beta, np.sum(overbound_states))
    v_keep = np.mean(rewards_keep[:, np.newaxis] + discount*np.dot(poly(next_states_keep, deg=norder), weights), axis=1)

    next_state_replace = rng.exponential(beta, (nbasepoints, nsim))
    v_replace = np.mean(reward_replace + discount*np.dot(poly(next_state_replace, deg=norder), weights), axis=1)
    vhat = np.max(np.column_stack((v_keep, v_replace)), axis=1)
    qhat = np.argmax(np.column_stack((v_keep, v_replace)), axis=1)

    weights = np.linalg.lstsq(poly(basepoints, deg=norder), vhat)[0]
    indices = np.argsort(basepoints)
    if i == 1 or i == 19:
        plt.plot(basepoints[indices], np.dot(poly(basepoints, deg=norder), weights)[indices])
        plt.scatter(basepoints, vhat, marker='.')
    
plt.axvline(4.867, linestyle='dotted', c='k')    
plt.axhline(-48.67, linestyle='dotted', c='k') 
plt.xlim(0, 10)
#plt.ylim(0, 10)
#plt.savefig('inventory.pdf')"
qhat[indices]
"X, Y = make_moons(n_samples=500, noise=0.3)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y)

plt.scatter(X_train[:, 0], X_train[:, 1], marker='o', c=Y_train, s=100, alpha=0.4)"
"C = 1.0
kernel_svc = svm.SVC(C=C, kernel='poly', degree=3)
kernel_svc.fit(X_train,Y_train)"
"Y_predict = kernel_svc.predict(X_test)
plt.scatter(X_test[:, 0], X_test[:, 1], marker='o', c=Y_predict, s=100, alpha=0.4)"
"h = 0.02
x_min, x_max = X[:, 0].min() - .5, X[:, 0].max() + .5
y_min, y_max = X[:, 1].min() - .5, X[:, 1].max() + .5
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
Z = kernel_svc.decision_function(np.c_[xx.ravel(), yy.ravel()]) # distancia al plano separador
Z = Z.reshape(xx.shape)

cm = plt.cm.RdBu
plt.contourf(xx, yy, -Z, cmap=cm, alpha=.8) # el signo menos viene por razones puramente esteticas del plot.

plt.scatter(X_test[:, 0], X_test[:, 1], marker='o', c=Y_test, s=100, alpha=0.5)"
"n_bad = 1.0 * len(Y_predict[Y_predict != Y_test])
n_total = 1.0 * len(Y_predict)
eff = n_bad / n_total
print(eff)"
"C = 1.0
gamma = 1.0
kernel_svc = svm.SVC(C=C, kernel='rbf', gamma=gamma)
kernel_svc.fit(X_train,Y_train)"
"h = 0.02
x_min, x_max = X[:, 0].min() - .5, X[:, 0].max() + .5
y_min, y_max = X[:, 1].min() - .5, X[:, 1].max() + .5
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
Z = kernel_svc.decision_function(np.c_[xx.ravel(), yy.ravel()]) # distancia al plano separador
Z = Z.reshape(xx.shape)

cm = plt.cm.RdBu
plt.contourf(xx, yy, -Z, cmap=cm, alpha=.8) # el signo menos viene por razones puramente esteticas del plot.

plt.scatter(X_test[:, 0], X_test[:, 1], marker='o', c=Y_test, s=100, alpha=0.5)"
"Y_predict = kernel_svc.predict(X_test)
plt.scatter(X_test[:, 0], X_test[:, 1], marker='o', c=Y_predict, s=100, alpha=0.4)"
"n_bad = 1.0 * len(Y_predict[Y_predict != Y_test])
n_total = 1.0 * len(Y_predict)
eff = n_bad / n_total
print(eff)"
"X, Y = make_circles(n_samples=500, noise=0.3, factor=0.4)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=.4)

plt.scatter(X_train[:, 0], X_train[:, 1], marker='o', c=Y_train, s=100, alpha=0.4)"
"C = 1.0
gamma = 1.0
kernel_svc = svm.SVC(C=C, kernel='rbf', gamma=gamma)
kernel_svc.fit(X_train,Y_train)"
"h = 0.02
x_min, x_max = X[:, 0].min() - .5, X[:, 0].max() + .5
y_min, y_max = X[:, 1].min() - .5, X[:, 1].max() + .5
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
Z = kernel_svc.decision_function(np.c_[xx.ravel(), yy.ravel()]) # distancia al plano separador
Z = Z.reshape(xx.shape)

cm = plt.cm.RdBu
plt.contourf(xx, yy, -Z, cmap=cm, alpha=.8) # el signo menos viene por razones puramente esteticas del plot.

plt.scatter(X_test[:, 0], X_test[:, 1], marker='o', c=Y_test, s=100, alpha=0.5)"
"from sklearn.model_selection import ShuffleSplit, GridSearchCV

gamma_range = np.logspace(-2, 2, 20)
print(gamma_range)
param_grid = dict(gamma=gamma_range)

cv = ShuffleSplit(n_splits=10, test_size=0.20)
grid = GridSearchCV(svm.SVC(kernel='rbf'), param_grid=param_grid, cv=cv)

grid.fit(X,Y)

print(""The best gamma={}, score={}"".format(grid.best_params_, grid.best_score_))"
"data = datasets.load_breast_cancer()
print(data.DESCR)"
"beta  = [0.1, 0.3, 0.4]
n_points = 100
x_1 = np.linspace(-1.0, 1.0, 100)
x_2 = -(x_1 * beta[1] -  beta[0])/beta[2] 
a = plt.plot(x_1,x_2, lw =10)
plt.quiver(beta[1], beta[2],angles='xy',scale_units='xy',scale=0.5)
a = plt.axis('equal')"
"X, Y = make_moons(n_samples=500, noise=0.3)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=.4)

plt.scatter(X_train[:, 0], X_train[:, 1], marker='o', c=Y_train, s=100, alpha=0.4)"
"C = 1.0
linear_svc = svm.SVC(C=C, kernel='linear')
linear_svc.fit(X_train,Y_train)"
"beta = linear_svc.coef_[0]
beta_0 = linear_svc.intercept_

l = - beta[0]/beta[1]

x_1 = np.linspace(X[:,0].min(), X[:,0].max(), 100)
x_2 = l * x_1 - beta_0 / beta[1]
a = plt.plot(x_1,x_2, lw =2)

plt.scatter(X_train[:, 0], X_train[:, 1], marker='o', c=Y_train, s=100, alpha=0.4)"
"distances = np.sum(linear_svc.support_vectors_*linear_svc.coef_[0], axis=1) + beta_0
dist_sort = np.argsort(distances)
plt.plot(distances[dist_sort])"
"x_1 = np.linspace(X_train[:,0].min(), X_train[:,0].max(), 100)
x_2 = l * x_1 - beta_0 / beta[1]
a = plt.plot(x_1,x_2, lw =2)

b = linear_svc.support_vectors_[dist_sort[0]]
x_2 = l * x_1 + (b[1] - l * b[0])
a = plt.plot(x_1,x_2, '--', color='black', lw =2)

b = linear_svc.support_vectors_[dist_sort[-1]]
x_2 = l * x_1 + (b[1] - l * b[0])
a = plt.plot(x_1,x_2, '--', color='black', lw =2)

plt.scatter(linear_svc.support_vectors_[:,0], linear_svc.support_vectors_[:,1], color='black')"
"n_bad = 1.0 * len(Y_predict[Y_predict != Y_test])
n_total = 1.0 * len(Y_predict)
eff = n_bad / n_total
print(eff)"
"h = 0.02
x_min, x_max = X[:, 0].min() - .5, X[:, 0].max() + .5
y_min, y_max = X[:, 1].min() - .5, X[:, 1].max() + .5
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
Z = linear_svc.decision_function(np.c_[xx.ravel(), yy.ravel()]) # distancia al plano separador
Z = Z.reshape(xx.shape)

cm = plt.cm.RdBu
plt.contourf(xx, yy, -Z, cmap=cm, alpha=.8) # el signo menos viene por razones puramente esteticas del plot.

plt.scatter(X_test[:, 0], X_test[:, 1], marker='o', c=Y_test, s=100, alpha=0.5)"
"plt.xlabel('$x$')
plt.title('finite element mesh')
plt.plot(mesh, np.zeros(len(mesh)), 'ro-');"
"plt.xlabel('$x$')
plt.ylabel('$u$')
plt.title('Finite element solution for the elastic bar')
plt.plot(mesh, u, 'ro-');"
"plt.xlabel('$x$')
plt.ylabel('$u$')
plt.title('Finite element solution for the elastic bar')
for u, mesh in solutions:
    plt.plot(mesh, u, 'o-', label=str(len(mesh)-1) + ' cells');
plt.legend(loc='upper left');"
"plt.xlabel('$x$')
plt.ylabel('$u$')
plt.title('Finite element solution for the elastic bar')
for u, mesh in solutions:
    plt.plot(mesh, u, 'o-', label=str(len(mesh)-1) + ' cells');
plt.legend(loc='upper left');"
"plt.plot(l_array, p_array/norm[0])
plt.xlabel('$\lambda$')
plt.ylabel('$P(\lambda|data)$')"
"l_walk_high_sigma = sample_metropolis_hastings(p_model_data, obs_data, 100000, 1000.0)
l_walk_low_sigma = sample_metropolis_hastings(p_model_data, obs_data, 100000, 0.001)
l_walk_mid_sigma = sample_metropolis_hastings(p_model_data, obs_data, 100000, 1.0)"
"plt.plot(x_high ,y_high)
plt.plot(l_array, p_array/norm[0])"
plt.plot(l_walk_high_sigma)
"plt.plot(x_mid ,y_mid)
plt.plot(l_array, p_array/norm[0])"
plt.plot(l_walk_mid_sigma)
"plt.plot(x_low ,y_low)
plt.plot(l_array, p_array/norm[0])"
plt.plot(l_walk_low_sigma)
"w_high, R_high = gelman_rubin(p_model_data, obs_data, sigma=1E3)
w_low, R_low = gelman_rubin(p_model_data, obs_data, sigma=1E-3)
w_mid, R_mid = gelman_rubin(p_model_data, obs_data, sigma=1.0)"
"plt.plot(R_high[500:], label='$\sigma=10^3$')
plt.plot(R_mid[500:], label='$\sigma=1.0$')
plt.plot(R_low[500:], label='$\sigma=10^{-3}$')
plt.loglog()
plt.legend()
plt.xlabel('Iteration Number')
plt.ylabel('$\hat{R}$')"
"sns.pairplot(data, x_vars=['Income', 'Limit'], y_vars='Balance', size=7, aspect=0.7, kind='reg')"
clf.intercept_
"clf.score(X_test, Y_test)"
"cross_val_score(clf, X, Y, cv=5)"
"scaler = preprocessing.StandardScaler().fit(X_test)
scaler"
"print(scaler.mean_)
print(scaler.scale_)"
"print(np.mean(scaler.transform(X_test), axis=0))
print(np.std(scaler.transform(X_test), axis=0))"
boston.keys()
print(boston['DESCR'])
plt.plot(boston['target'])
"plt.scatter(X[:,6], X[:,12])
plt.xlabel(boston.feature_names[6])
plt.ylabel(boston.feature_names[12])"
"rf = RandomForestClassifier(n_estimators=50)
rf.fit(X[:200], Y[:200])"
"prediction = rf.predict(X[200:])
plt.scatter(Y[200:], prediction)"
plt.plot(square_sum)
"ii = np.argsort(rf.feature_importances_)
for name, value in zip(boston.feature_names[ii], rf.feature_importances_[ii]):
    print(name, value)"
"t, x_t = solve_lorenz(angle=0, N=10)"
"w = interactive(solve_lorenz, angle=(0.,360.), N=(0,50), sigma=(0.0,50.0), rho=(0.0,50.0))
display(w)"
w.kwargs
"plt.hist(xyz_avg[:,0])
plt.title('Average $x(t)$')"
"plt.hist(xyz_avg[:,1])
plt.title('Average $y(t)$')"
"# Carry out anova

from scipy import stats
f_val, p_val = stats.f_oneway(*data)
p_val"
"# This is how to deal with the nans

data = [df[col].dropna() for col in df]
f_val, p_val = stats.f_oneway(*data)
p_val"
"# Let us create a nice plot with a regression line fitted to the median of the samples

import numpy as np  # For the median
import matplotlib.pyplot as plt  # For the plot
import seaborn
%matplotlib inline

# Fit line to median of distributions
x = range(1, len(data) + 1)
y = [np.median(sample) for sample in data]
slope, intercept, r_val, p_val, slope_std_error = stats.linregress(x, y)

def line(x):
    """"""The regression line""""""
    return slope * x + intercept

plt.figure()
plt.violinplot(data);
x1, x2 = plt.xlim()
plt.plot((x1, x2), (line(x1), line(x2)), '--',
         label=""$y = {:.2f}x + {:.2f}$ ($p={:.2f}$)"".format(slope, intercept, p_val),
         ),
plt.legend(loc=4);
# plt.savefig(""../assets/images/regression_anova.svg"");  # Save to your path"
"# reflectivity plots
plt.figure(1,figsize=(9,6))
plt.plot(v_theta*1.8e2/np.pi,v_r_s,'k',linewidth=2.0)
plt.plot(v_theta*1.8e2/np.pi,v_r_p,'r',linewidth=2.0)


# labels
plt.xlabel(r'$\Theta^{\circ}$',fontsize=f_size+10)
plt.ylabel('R',fontsize=f_size+10)

# ticks
plt.xticks(fontsize=f_size)
plt.yticks(fontsize=f_size)

# grids
plt.grid()

#legends
plt.legend(['TE (s)','TM (p)'],loc='lower right',fontsize=f_size,fancybox=True);"
"# field plots
plt.figure(figsize=(9,6))

# plot
plt.plot(v_z,v_field_s,'k',linewidth=2.0)
plt.plot(v_z,v_field_p,'r',linewidth=2.0)
for n_d,d in enumerate(d_list):
    plt.axvline(d_list[0:n_d].sum(),color='gray',linestyle='dashed',linewidth=2.0)    

# labels
plt.ylabel(r'$|E_{\mathrm{y,TE}}|,|H_{\mathrm{y,TM}}|$',fontsize=f_size+10)
plt.xlabel(r'z (nm)',fontsize=f_size+5)

# ticks
plt.xticks(fontsize=f_size)
plt.yticks([5,10,15,20],fontsize=f_size)

# grids
plt.grid(color='gray',axis='y')

# legend
plt.legend(['TE (s)','TM (p)'],loc='upper left',fontsize=f_size,fancybox=True);"
"# reflectivity plots
plt.figure(1,figsize=(15,10))
plt.plot(v_theta*1.8e2/np.pi,v_r_p,'k',linewidth=2.0)

# labels
plt.xlabel(r'$\Theta^{\circ}$',fontsize=f_size+10)
plt.ylabel('R',fontsize=f_size+10)

# ticks
plt.xticks(fontsize=f_size)
plt.yticks(fontsize=f_size)

# grids
plt.grid()

#legends
plt.legend(['55 nm Au film reflectance at 633 nm'],loc='upper right',fontsize=f_size,frameon=False);"
"# field plots
plt.figure(figsize=(9,7.5))

# transverse magnetic field modulues
plt.subplot(2,2,1)

# plot
plt.plot(v_z,v_field,'k',linewidth=3.0)
plt.axvline(d_list[0],color='gray',linestyle='dashed',linewidth=2.0)
plt.axvline(d_list[1],color='gray',linestyle='dashed',linewidth=2.0)

# labels
plt.ylabel(r'$|H_{\mathrm{y}}|$',fontsize=f_size+10)

# ticks
plt.xticks([0,200,400],fontsize=f_size)
plt.yticks([0,2,4,6,8],fontsize=f_size)

# grids
plt.grid(color='gray')


# local absorbed power
plt.subplot(2,2,2)

# plot
plt.plot(v_z,v_abs,'k',linewidth=3.0)
plt.axvline(d_list[0],color='gray',linestyle='dashed',linewidth=2.0)
plt.axvline(d_list[1],color='gray',linestyle='dashed',linewidth=2.0)

# labels
plt.ylabel(r'Abs power (a.u.)',fontsize=f_size+5)

# ticks
plt.xticks([0,200,400],fontsize=f_size)
plt.yticks(fontsize=f_size)

# grids
plt.grid(color='gray')


# Sx component of the Poynting vector
plt.subplot(2,2,3)

# plot
plt.plot(v_z,v_S[:,0],'k',linewidth=3.0)
plt.axvline(d_list[0],color='gray',linestyle='dashed',linewidth=2.0)
plt.axvline(d_list[1],color='gray',linestyle='dashed',linewidth=2.0)

# labels
plt.xlabel(r'z (nm)',fontsize=f_size+10)
plt.ylabel(r'$S_{\mathrm{x}}$',fontsize=f_size+5)

# ticks
plt.xticks([0,200,400],fontsize=f_size)
plt.yticks(fontsize=f_size)

# grids
plt.grid(color='gray')


# Sz component of the Poynting vector
plt.subplot(2,2,4)

# plot
plt.plot(v_z,v_S[:,2],'k',linewidth=3.0)
plt.axvline(d_list[0],color='gray',linestyle='dashed',linewidth=2.0)
plt.axvline(d_list[1],color='gray',linestyle='dashed',linewidth=2.0)

# labels
plt.xlabel(r'z (nm)',fontsize=f_size+10)
plt.ylabel(r'$S_{\mathrm{z}}$',fontsize=f_size+5)

# ticks
plt.xticks([0,200,400],fontsize=f_size)
plt.yticks(fontsize=f_size)

# grids
plt.grid(color='gray')


plt.tight_layout()"
"# cmd plot
fg2=plt.figure(num=2,figsize=(15,10))
plt.plot(v_wl,1e4*(v_A_r-v_A_l)/(v_A_r).max(),'r-',
         v_wl,1e4*v_mcd,'ko',
         markersize=10,linewidth=3);

#-----ticks------
fsize=15;
plt.xticks(fontsize=fsize+10);plt.yticks(fontsize=fsize+10);

#------axis labels------
plt.xlabel(r'Wavelength (nm)',fontsize=fsize+15);
plt.ylabel(r'$\Delta$A\(A$_{\mathrm{max}}*$B)(T$^{-1}*10^{4}$)',fontsize=fsize+15);

#------plot legend------
plt.legend(('Tensorial','Scalar'), fontsize=fsize+15,loc='upper right',frameon=False);"
"# python reuses small integer objects within its runtime.
x = None
print(sys.getrefcount(0))"
"x = 0
print(sys.getrefcount(0))"
"# bigger objects are not cached and created one off.
sys.getrefcount(257)
print (256 + 1 is 256 + 1)"
"import warnings
warnings.filterwarnings('ignore')
## make imports
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
%matplotlib inline
sns.set(style=""ticks"", color_codes=True)

## load the iris data
iris = sns.load_dataset(""iris"")
g = sns.pairplot(iris)"
"g = sns.pairplot(iris, hue=""species"",palette=""husl"")"
"## make a histogram the matplotlib way
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(1,1,1)
ax.hist(iris['sepal_length']);"
"## make a histogram the pandas way
ax = iris[""sepal_length""].plot(kind='hist')
ax.set_title(""my title"");"
"t, x_t = solve_lorenz(angle=0, N=10)"
"w = interactive(solve_lorenz, angle=(0.,360.), N=(0,50), sigma=(0.0,50.0), rho=(0.0,50.0))
display(w)"
w.kwargs
"plt.hist(xyz_avg[:,0])
plt.title('Average $x(t)$')"
"plt.hist(xyz_avg[:,1])
plt.title('Average $y(t)$')"
"plt.figure(figsize=(10,10))
#plt.plot(coords[:3], 'x', )
for (i,party) in enumerate(party_names):
    plt.annotate(party, coords[i])
plt.xlim(-5,5)
plt.ylim(-5,5)
plt.title('PCA of party statements for kieswijzer 2017')"
coalitions[~coalitions.has_pvv].sort_values(by='stress').head(10)
plt.plot(v1)
plt.plot(v2)
plt.plot(v3)
plt.plot(v4)
"%timeit compute_method1(x, pars)"
"%timeit compute_method2(x, pars)"
"%timeit compute_method3(x, pars)"
"%timeit compute_method4(x, pars)"
"ax = Emean_vs_A.plot(x='Mass Number', y='binding energy per nucleus',
          legend=False, color=(0.3,0.3,0.3,0.5), marker='o', alpha=0.7)
ax.set_xlabel('Mass number A (number of nucleons)', fontsize=16)
ax.set_ylabel('Average binding energy per nucleons [MeV]', fontsize=16)
ax.grid(True)
ax.tick_params(size=14)
plt.tight_layout()"
"ax2 = data.plot(x='Mass Number', y='binding energy per nucleus',
          legend=False, kind='scatter', color=(0.8,0.8,0.8,1))
ax2.set_xlabel('Mass number A (number of nucleons)', fontsize=16)
ax2.set_ylabel('Binding energy per nucleons [MeV]', fontsize=16)
ax2.grid(True)
ax2.tick_params(size=14)
ax2.set_xlim(0,260)
ax2.set_ylim(0, 9)
plt.tight_layout()"
"# Import cross-section data from http://home.earthlink.net/~jimlux/nuc/sigma.htm
data_DT=pd.read_csv('http://home.earthlink.net/~jimlux/nuc/tdn.txt', skiprows=16, delimiter='\t', 
                 names=('Energy [keV]','Sigma [Barns]'))
data_DD=pd.read_csv('http://home.earthlink.net/~jimlux/nuc/ddn.txt', skiprows=16, delimiter='\t', 
                 names=('Energy [keV]','Sigma [Barns]'))
Barn_to_msquare = 1e-28

ax=data_DT.plot(x='Energy [keV]', y='Sigma [Barns]', logy=True, logx=True, label='D-T', lw=2)
data_DD.plot(x='Energy [keV]', y='Sigma [Barns]', logy=True, logx=True, label='D-D', lw=2, ax=ax)
ax.set_ylim(10e-3, 10)
ax.set_xlim(1, 10e3)
ax.set_ylabel('$\sigma$ [barns]')
ax.grid(True, which='minor')
ax.set_title('Cross sections for D-T and D-D fusion reactions \n vs deuteron energy')"
"T = np.logspace(-2,3) # keV
sigmav = sigmav_avg(T) # m^-3 /s

fig,ax = plt.subplots()
ax.plot(T, sigmav)
ax.set_xscale('log')
ax.set_yscale('log')
ax.set_xlabel('T [keV]')
ax.set_ylabel('$<\sigma v>$ [$m^3/s$]')
ax.set_xlim(1, 1e3)
ax.set_ylim(1e-25, 1e-21)
ax.grid(True, which='minor', axis='both')
ax.set_title('Volumetric reaction rates of D-T reaction')"
"# Taken from Eqs.(4.18) J.Freidberg
def S_alpha_over_p(T):
    ""T in keV""
    #E_alpha = 3.5 # MeV
    #return 1/16*(E_alpha*1e6/e)/(T/e*k_B)**2*sigmav_avg(T/1e3)
    return 1.37*sigmav_avg(T)/1e-22/T**2
    
def S_B_over_p(T, Z_eff=1):
    ""T in keV""
    return 0.052/T**(3/2)

T = np.logspace(0,3) # keV
S_a = S_alpha_over_p(T) 
S_B = S_B_over_p(T)


fig, ax = plt.subplots()
ax.plot(T, S_a, label='$S_{alpha}/p^2$')
ax.plot(T, S_B, label='$S_B/p^2$')
ax.set_ylim(0, 0.03)
ax.set_xlim(1, 100)
ax.set_xscale('log')
ax.set_xlabel('T [keV]')
ax.set_ylabel('Power Density [$MW/m^3/atm^2$]')
ax.legend()
fig.tight_layout()"
"# setup a figure
fig = plt.figure()
ax = fig.add_axes([0,0,1,1], projection='3d')
# setup dummy lines and points to be filled after
lines = ax.plot([], [], color='r')[0]
pts = ax.plot([], [], color='r')[0]

plt.plot(x,y,z)
min(y)"
"x,y,z,vx,vy,vz = u_num.T
ax.plot(x,y,z, lw=2)
"
"fig=plt.figure()
axe=fig.add_axes([0,0,1,1], projection='3d')
axe.plot(x, y, z, color='r', lw=2)
axe.plot(x[-2:-1], y[-2:-1], z[-2:-1], marker='.', markersize=20, color='r') # particle point
axe.axis('on')
#axe.tick_params(axis='x', which='both',  labelbottom='off')
axe.view_init(30,60)"
"fig=plt.figure()
axe=fig.add_subplot(111, projection='3d')
axe.plot(x, y, z, color='r', lw=2)
axe.plot(x[-2:-1], y[-2:-1], z[-2:-1], marker='.', markersize=20, color='r') # particle point"
"map(compose(factors, triangle_num), range(1, 11))"
"import warnings
warnings.filterwarnings('ignore')
from IPython.core.display import HTML
def css_styling():
    styles = open(""./styles/custom.css"", ""r"").read  ()
    return HTML(styles)
css_styling()

%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import os
print(os.getcwd())"
"#Quick visualize data
plt.grid(True)
plt.xlim([-100,5000])
dummy = plt.hist(X[:,0],label = 'col1')
dummy = plt.hist(X[:,1],label = 'col2')
dummy = plt.hist(X[:,2],label = 'col3')
plt.title('Clearly we need feature normalization.')
plt.xlabel('Column Value')
plt.ylabel('Counts')
dummy = plt.legend()"
"#Quick visualize the feature-normalized data
plt.grid(True)
plt.xlim([-5,5])
dummy = plt.hist(Xnorm[:,0],label = 'col1')
dummy = plt.hist(Xnorm[:,1],label = 'col2')
dummy = plt.hist(Xnorm[:,2],label = 'col3')
plt.title('Feature Normalization Accomplished')
plt.xlabel('Column Value')
plt.ylabel('Counts')
dummy = plt.legend()"
"#print ""Final result theta parameters: \n"",theta
print('Check of result: What is price of house with 1650 square feet and 3 bedrooms?')
ytest = np.array([1650.,3.])
#To ""undo"" feature normalization, we ""undo"" 1650 and 3, then plug it into our hypothesis
ytestscaled = [(ytest[x]-stored_feature_means[x+1])/stored_feature_stds[x+1] for x in range(len(ytest))]
ytestscaled.insert(0,1)
print(h(theta, ytestscaled))"
"print('Normal equation prediction for price of house with 1650 square feet and 3 bedrooms')
print(h(normEqtn(X,y),[1,1650.,3]))"
"import warnings
warnings.filterwarnings('ignore')
from IPython.core.display import HTML
def css_styling():
    styles = open(""./styles/custom.css"", ""r"").read  ()
    return HTML(styles)
css_styling()

%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import os
print(os.getcwd())"
"r = np.exp(np.log(1.0 + 1.0)/ 5.0) - 1
print (r)"
"r = np.exp(np.log(1.0 + 1.0)/ 20.0) - 1
print(r)"
"import warnings
warnings.filterwarnings('ignore')
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

def drawPolygon (n):
    """"""Draw an n-sided polygon centered at the origin.""""""
    theta = np.linspace (0, 2 * np.pi, n, endpoint=False)
    plt.fill (np.cos (theta), np.sin (theta))
    plt.axis ('equal')

def drawCircle (samples=100, r=1):
    """"""Draw a circle centered at the origin.""""""
    theta = np.linspace (0, 2 * np.pi, samples, endpoint=False)
    plt.plot (np.cos (theta), np.sin (theta))
    plt.axis ('equal')

drawCircle ()
drawPolygon (4)"
"drawCircle ()
drawPolygon (8)
drawPolygon (4)"
"plt.fill ((-1, 0, 1), (0, 1, 0));
plt.text (-0.55, 0.55, 'l')
plt.plot ((0, 0), (0, 1), 'w:')
plt.text (0.1, 0.4, 'h', color='w')
plt.plot ((-1, 0, 1), (0, -1, 0))
plt.axis ('equal');"
"def polygonFromTriangles (n):
    """"""Draw a polygon composed of Isosceles triangles.""""""
    theta = 2 * np.pi / n
    for i in range (n):
        plt.fill ((0, np.cos (theta * i), np.cos (theta * (i + 1))),
                 (0, np.sin (theta * i), np.sin (theta * (i + 1))))
    plt.axis ('equal')

# Draw a square
polygonFromTriangles (4)"
polygonFromTriangles (17)
"drawCircle ()
drawPolygon (8)
drawPolygon (4)
plt.plot ((0, 0, 1), (1, 0, 0), 'w-')
plt.plot ((0, np.cos (np.pi/4)), (0, np.sin (np.pi/4)), 'w--');"
"plt.plot ((0, 0.5, 1, 0), (0, 0.5, 0, 0))
plt.plot ((0.5, np.cos (np.pi/4), 1), (0.5, np.sin (np.pi/4), 0))
plt.axis ('equal')
plt.grid ()
plt.text (0.3, 0.35, '$h_4$')
plt.text (0.65, 0.25, '$b_4/2$')
plt.text (0.9, 0.3, '$b_8$')
plt.text (0.55, 0.65, '$r - h_4$');"
"def polyPi (n, b):
    """"""Compute area of n-sided regular polygon inscribed on unit circle with sides length b.""""""
    ia, h = isoscelesArea (b, 1)
    return n * ia, h

def polyPiLoop (n=None, epsilon=0.001):
    """"""Compute a polygon approximation to Pi.""""""

    # Start with a square
    sides = 4
    base = np.sqrt (2)
    previous = 0.0
    current, h = polyPi (sides, base)
    while current - previous > epsilon:
        previous = current
        base = doublePolygon (base, h)
        sides *= 2
        current, h = polyPi (sides, base)

    return current, sides, base

print (polyPiLoop ())
print (polyPiLoop (epsilon=1.0e-12))
print (polyPiLoop (epsilon=1.0e-30))"
"def convergence (n=25):
    """"""Return a vector of estimated values for pi at each iteration.""""""
    sides = 4
    base = np.sqrt (2)
    estimates = np.zeros (n, dtype=float)
    for i in range (n):
        current, h = polyPi (sides, base)
        estimates[i] = current
        base = doublePolygon (base, h)
        sides *= 2
        
    return estimates

estimates = convergence ()
f, a = plt.subplots (2, 1, sharex=True)
a[0].plot (estimates)
a[0].set_ylabel ('Estimated value of $\\pi$')
a[1].semilogy (np.pi - estimates)
a[1].set_xlabel ('Number of iterations')
a[1].set_ylabel ('Difference from $\\pi$');"
"plt.plot (np.cumsum (tosses))
plt.grid ()
# plt.lines ((0, 0), (tosses, tosses))
plt.show ()"
"bins = 1000
theta = np.linspace (0, 1, bins)
prior = np.ones (bins)
plt.plot (theta, prior)
plt.show ()"
"likelihood = np.linspace (0, 2, bins)
plt.plot (theta, likelihood, label='heads')
plt.plot (theta, 2 - likelihood, label='tails')
plt.xlabel ('$\Theta$')
plt.legend ()
plt.show ()"
"plt.plot (theta, posterior (prior, likelihood), label='1head,0tail')
plt.plot (theta, posterior (prior, likelihood * (2 - likelihood)), label='1head,1tail')
plt.plot (theta, posterior (prior, likelihood**2 * (2 - likelihood)**2), label='2heads,2tails')
plt.legend ()
plt.show ()"
"estimates = np.matmul (likelihood.reshape ((-1, 1)), tosses.reshape ((1, -1)))
estimates += np.matmul (2 - likelihood.reshape ((-1, 1)), ~tosses.reshape ((1, -1)))
estimates = np.cumprod (estimates, 1)
plt.pcolormesh (estimates)
plt.plot (np.argmax (estimates, 0))
plt.show ()"
"heatmapper (estimates, heads)
plt.show ()"
"plot(x,u_initial)"
"plot(x, u_initial)
plot(x, u_past)
plot(x, u_present)
plt.xlabel('x')
plt.ylabel('u')"
"plot(x, u_initial)
plot(x, u_present)
plt.xlabel('x')
plt.ylabel('u')"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import VimeoVideo
VimeoVideo(48756378)"
"b = BloomFilter(15000, 20)

def fill(B, n_test=1000, upper=1e9, exact=False):
    if exact:
        exact_ = set()

    for n in range(n_test):
        r = np.random.randint(upper)
        B.add(r)
        if exact:
            exact_.add(r)
            
    if exact:
        return exact_
    
exact = fill(b, exact=True)

n_true = 0
for e in exact:
    if e in b:
        n_true += 1

def fakes(B, n_test=1000, upper=1e9):
    n_fake = 0
    for e in np.random.randint(upper, size=n_test):
        if int(e) in B:
            n_fake += 1
            
    return n_fake / n_test
        
print('True positive rate: %.3f False positive rate: %.3f.' % (n_true / len(exact),
                                                               fakes(b)))"
"sizes = np.arange(5000, 40000, step=2000)

for n_test in (1500, 3000, 4500):
    fake_rate = []
    for size in sizes:
        b = BloomFilter(size, 20)
        fill(b, n_test=n_test)
        fake_rate.append(fakes(b, n_test=10000))

    plt.plot(sizes, fake_rate, label='%i (%f.1) entries' % (n_test, b.entries()))

plt.legend(loc='best')
plt.xlabel('Bloom filter size [bits]')
plt.ylabel('False positive rate')"
"for n_test in (2500, 3000, 3500):
    hash_funs = np.arange(1, 20)
    fake_rate = []
    for k in hash_funs:
        b = BloomFilter(22000, k)
        fill(b, n_test=n_test)
        fake_rate.append(fakes(b, n_test=3000))

    plt.plot(hash_funs, fake_rate, label='%i entries' % n_test)

plt.legend(loc='best')
plt.xlabel('Number of hash functions $k$')
plt.ylabel('False positive rate')"
"cms = CountMinSketch(100, 300)

words = {}
for n in range(1000):
    word = ''.join([random.choice(string.ascii_lowercase) for _ in range(10)])
    count = np.random.randint(50)
    words[word] = count
    for _ in range(count):
        cms.update(word)

for n,word in enumerate(words):
    print(words[word], cms.query(word))
    if n > 20:
        break"
"# how many distinct elements in a stream of 100000
# random numbers?
hyperloglog((np.random.randint(0, int(1e9)) for i in range(100000)), b=8)"
"pythonic_mines(9,9,40)"
"b = np.zeros((9, 9))
N = 100
n_mines = 20
for n in range(N):
    b += pythonic_mines(*b.shape, n_mines)
    
b /= N
average = n_mines/float(b.shape[0]*b.shape[1])

f, (ax1, ax2) = plt.subplots(1, 2, figsize=(9.1,4))

im = ax1.imshow(b, interpolation='nearest', cmap=plt.cm.bwr)
divider1 = make_axes_locatable(ax1)
cax1 = divider1.append_axes(""right"", size=""10%"", pad=0.05)
plt.colorbar(im, cax=cax1)

ax2.hlines(average, xmin=0, xmax=b.shape[0]*b.shape[1])
ax2.plot(b.ravel())
ax2.set_xlim(0, b.shape[0]*b.shape[1])

y = b.ravel()
(m, b), _ = fit(range(y.shape[0]), y)
x = np.linspace(0, y.shape[0], 100)
ax2.plot(x, m*x + b)

f.tight_layout()

print('Average should be: %.3f'%(average))"
"t, x_t = solve_lorenz(angle=0, N=10)"
"w = interactive(solve_lorenz, angle=(0.,360.), N=(0,50), sigma=(0.0,50.0), rho=(0.0,50.0))
display(w)"
w.kwargs
"plt.hist(xyz_avg[:,0])
plt.title('Average $x(t)$')"
"plt.hist(xyz_avg[:,1])
plt.title('Average $y(t)$')"
"# define distribution function

def gauss(x, mu, sigma):
    return 1./sqrt(2*pi*sigma**2)*exp(-(x-mu)**2/(2*sigma**2))

def P(x):
    mu1, sigma1 = 0.1, 0.1
    mu2, sigma2 = 0.5, 0.07
    return gauss(x, mu1, sigma1)*0.3 + gauss(x, mu2, sigma2)*0.7

x = linspace(-1,1, 200)
plot(x, P(x)) "
"def step(x, stepsize = 0.1):
    return x + random.normal(0, stepsize)

def plot_path():
    figure()
    ax1 = gcf().add_axes([.15, .15, .55, .8])
    ax2 = gcf().add_axes([.70, .15, .25, .8])
    #ax2 = subplot(122)
    ax2.axes.yaxis.set_ticklabels([])
    ax2.axes.xaxis.set_ticklabels([])
    ax1.plot(path)
    ax2.hist(path, bins=linspace(-1,1,100), normed=1, orientation=""horizontal"", histtype=""stepfilled"", color=""#DDDDDD"")
    ax2.set_ylim([-0.4, 0.8])
    ax1.set_ylim([-0.4, 0.8])
    ax1.set_title(""stepsize = %.3f, acceptance = %.3f"" % (stepsize, acceptance))

    x = linspace(-1,1, 200)
    ax2.plot(P(x),x,""r"", lw=2)

random.seed(12)
for stepsize in [0.01, 0.1, 2.]:
    path, acceptance = metropolis(0., step, 1000, P, stepsize=stepsize)
    plot_path()
pass"
"def E(x):
    return x**2 - cos((cos(x*4)**8-1)*20)
    
    #return x**2-cos(x*gauss(x, 0, 0.3)*200)*gauss(x, 0, 0.5)*0.4
    #return x**2-cos(x/(0.5+x**2)*200)*gauss(x, 0, 0.5)*0.4

x = linspace(-1,1, 1000)
plot(x, E(x))"
"random.seed(1234)
def step(x, stepsize = 0.1):
    return x + random.normal(0, stepsize)

for stepsize in [0.01, 0.5, 5.]:
    path, acceptance = greedy(0.8, step, 2000, E, stepsize=stepsize)
    figure(figsize=(6,4))
    ax1 = gcf().add_axes([.15, .15, .45, .8])
    ax2 = gcf().add_axes([.70, .15, .35, .8])

    ax1.plot(path, E(path))
    x = linspace(-1,1, 1000)
    ax1.plot(x, E(x))
    ax2.semilogy(E(path)-E(0))
pass"
"T0 = 1.
def schedule(k):
    return T0/log(k+1)

def step(x, k, stepsize = 0.1):
    return x + random.normal(0, stepsize*sqrt(schedule(k)))

random.seed(1234)
nstep = 10000
x0 = 0.8
for stepsize in [0.01, 0.1, 5.]:
    path, acceptance = boltzmann_anneal(x0, step, nstep, E, schedule, stepsize=stepsize)
    figure(figsize=(12,4))
    ax1 = gcf().add_axes([.10, .15, .40, .8])
    ax2 = gcf().add_axes([.55, .15, .20, .8])
    ax3 = gcf().add_axes([.80, .15, .20, .8])

    ax1.plot(path, E(path))
    x = linspace(-1,1, 1000)
    ax1.plot(x, E(x))
    ax2.semilogy(E(path)-E(0))
    ax3.plot(schedule(arange(nstep)))
pass"
"T0 = 10.
def schedule(k):
    return T0/(k+10)

def step(x, k, stepsize = 0.1):
    return x + random.normal(0, stepsize*sqrt(schedule(k)))

random.seed(1234)
nstep = 10000
x0 = 0.8
for stepsize in [0.1, 1, 10.]:
    path, acceptance = boltzmann_anneal(x0, step, nstep, E, schedule, stepsize=stepsize)
    print(acceptance)
    figure(figsize=(12,4))
    ax1 = gcf().add_axes([.10, .15, .40, .8])
    ax2 = gcf().add_axes([.55, .15, .20, .8])
    ax3 = gcf().add_axes([.80, .15, .20, .8])

    ax1.plot(path, E(path))
    x = linspace(-1,1, 1000)
    ax1.plot(x, E(x))
    ax2.semilogy(E(path)-E(0))
    ax3.plot(schedule(arange(nstep)))
pass"
"T0 = 10.
def schedule(k):
    return T0/(k+1)

def step(x, k, stepsize = 0.1):
    return x + random.standard_cauchy() * stepsize*(schedule(k))

random.seed(1234)
nstep = 10000
x0 = 0.8
for stepsize in [0.1, 1, 10.]:
    path, acceptance = boltzmann_anneal(x0, step, nstep, E, schedule, stepsize=stepsize)
    print(acceptance)
    figure(figsize=(12,4))
    ax1 = gcf().add_axes([.10, .15, .40, .8])
    ax2 = gcf().add_axes([.55, .15, .20, .8])
    ax3 = gcf().add_axes([.80, .15, .20, .8])

    ax1.plot(path, E(path))
    x = linspace(-1,1, 1000)
    ax1.plot(x, E(x))
    ax2.semilogy(E(path)-E(0))
    ax3.plot(schedule(arange(nstep)))
pass"
"T0 = 10.
def schedule(k):
    eps=0.1
    return T0*exp(-k*eps)

def step(x, k, stepsize = 0.1):
    return x + random.standard_cauchy() * stepsize*sqrt(schedule(k))

random.seed(1234)
nstep = 2000
x0 = 0.8
for stepsize in [0.1, 1., 10., 100., 1., 1., 1.]:
    path, acceptance = boltzmann_anneal(x0, step, nstep, E, schedule, stepsize=stepsize)
    print(acceptance)
    figure(figsize=(12,4))
    ax1 = gcf().add_axes([.10, .15, .40, .8])
    ax2 = gcf().add_axes([.55, .15, .20, .8])
    ax3 = gcf().add_axes([.80, .15, .20, .8])

    ax1.plot(path, E(path))
    x = linspace(-1,1, 1000)
    ax1.plot(x, E(x))
    ax2.semilogy(E(path)-E(0))
    ax3.plot(schedule(arange(nstep)))
pass"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np 

nx,ny=6,4
X = np.random.randint(0,5,size=(nx,ny))
X"
"X[:,slice(0,4,2)]"
X[stripe]
"# Plot the filled contour of the temperature.
pyplot.figure(figsize=(8.0, 5.0))
pyplot.xlabel('x [m]')
pyplot.ylabel('y [m]')
levels = numpy.linspace(20.0, 100.0, num=51)
contf = pyplot.contourf(x, y, T, levels=levels)
cbar = pyplot.colorbar(contf)
cbar.set_label('Temperature [C]')
pyplot.axis('scaled', adjustable='box');"
"# Plot the filled contour of the temperature.
pyplot.figure(figsize=(8.0, 5.0))
pyplot.xlabel('x [m]')
pyplot.ylabel('y [m]')
levels = numpy.linspace(20.0, 100.0, num=51)
contf = pyplot.contourf(x, y, T, levels=levels)
cbar = pyplot.colorbar(contf)
cbar.set_label('Temperature [C]')
pyplot.axis('scaled', adjustable='box');"
"# Plot the temperature along the rod.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Plot the temperature along the rod.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Plot the temperature along the rod.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Plot the temperature along the rod.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Compute the analytical temperature distribution.
T_exact = analytical_temperature(x, nt * dt, alpha, L, 100)

# Plot the numerical and analytical temperatures.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, label='numerical',
            color='C0', linestyle='-', linewidth=2)
pyplot.plot(x, T_exact, label='analytical',
            color='C1', linestyle='--', linewidth=2)
pyplot.legend()
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Plot the error versus the time-step size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.grid()
pyplot.xlabel(r'$\Delta t$')
pyplot.ylabel('Relative $L_2$-norm\nof the error')
pyplot.loglog(dt_values, errors, label='Crank-Nicolson',
              color='black', linestyle='--', linewidth=2, marker='o')
pyplot.loglog(dt_values, errors_btcs, label='BTCS (implicit)',
              color='black', linestyle='--', linewidth=2, marker='s')
pyplot.legend()
pyplot.axis('equal');"
errors
"# Plot the error versus the grid-spacing size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.grid()
pyplot.xlabel(r'$\Delta x$')
pyplot.ylabel('Relative $L_2$-norm\nof the error')
dx_values = L / (numpy.array(nx_values) - 1)
pyplot.loglog(dx_values, errors,
              color='black', linestyle='--', linewidth=2, marker='o')
pyplot.axis('equal');"
"# Plot the error versus the grid-spacing size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.grid()
pyplot.xlabel(r'$\Delta x$')
pyplot.ylabel('Relative $L_2$-norm\nof the error')
dx_values = L / (numpy.array(nx_values) - 1)
pyplot.loglog(dx_values, errors,
              color='black', linestyle='--', linewidth=2, marker='o')
pyplot.axis('equal');"
errors
"# Plot the temperature along the rod.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Increase the CFL number.
sigma = 5.0
dt = sigma * dx**2 / alpha  # time-step size
nt = 100  # number of time steps to compute

# Compute the temperature along the rod.
T = btcs_implicit(T0, nt, dt, dx, alpha, q)

# Plot the temperature along the rod.
pyplot.figure(figsize=(6.0, 4.0))
pyplot.xlabel('Distance [m]')
pyplot.ylabel('Temperature [C]')
pyplot.grid()
pyplot.plot(x, T, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 100.0);"
"# Set the font family and size to use for Matplotlib figures.
pyplot.rcParams['font.family'] = 'serif'
pyplot.rcParams['font.size'] = 16

# Plot the solution of the elevation.
pyplot.figure(figsize=(9.0, 4.0))  # set the size of the figure
pyplot.title('Elevation of the phugoid over the time')  # set the title
pyplot.xlabel('Time [s]')  # set the x-axis label
pyplot.ylabel('Elevation [m]')  # set the y-axis label
pyplot.xlim(t[0], t[-1])  # set the x-axis limits
pyplot.ylim(40.0, 160.0)  # set the y-axis limits
pyplot.grid()  # set a background grid to improve readability
pyplot.plot(t, z, color='C0', linestyle='-', linewidth=2);"
"# Plot the numerical solution and the exact solution.
pyplot.figure(figsize=(9.0, 4.0))  # set the size of the figure
pyplot.title('Elevation of the phugoid over the time')  # set the title
pyplot.xlabel('Time [s]')  # set the x-axis label
pyplot.ylabel('Elevation [m]')  # set the y-axis label
pyplot.xlim(t[0], t[-1])  # set the x-axis limits
pyplot.ylim(40.0, 160.0)  # set the y-axis limits
pyplot.grid()  # set a background grid to improve readability
pyplot.plot(t, z, label='Numerical',
            color='C0', linestyle='-', linewidth=2)
pyplot.plot(t, z_exact, label='Analytical',
            color='C1', linestyle='-', linewidth=2)
pyplot.legend();  # set the legend"
"# Plot the error versus the time-step size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.title('L1-norm error vs. time-step size')  # set the title
pyplot.xlabel('$\Delta t$')  # set the x-axis label
pyplot.ylabel('Error')  # set the y-axis label
pyplot.grid()
pyplot.loglog(dt_values, error_values,
              color='C0', linestyle='--', marker='o')  # log-log plot
pyplot.axis('equal');  # make axes scale equally"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo('6i6qhqDCViA')"
"print('Distance traveled: {:.3f}'.format(x_rk2[idx_ground_rk2 - 1]))

# Plot the glider's path for both schemes.
pyplot.figure(figsize=(9.0, 6.0))
pyplot.subplot(121)
pyplot.grid()
pyplot.xlabel('x')
pyplot.ylabel('y')
pyplot.plot(x_euler[:idx_ground_euler], y_euler[:idx_ground_euler],
            label='Euler')
pyplot.plot(x_rk2[:idx_ground_rk2], y_rk2[:idx_ground_rk2],
            label='RK2')
pyplot.legend();
# Let's take a closer look!
pyplot.subplot(122)
pyplot.grid()
pyplot.xlabel('x')
pyplot.ylabel('y')
pyplot.plot(x_euler, y_euler, label='Euler')
pyplot.plot(x_rk2, y_rk2, label='RK2')
pyplot.xlim(0.0, 5.0)
pyplot.ylim(1.8, 2.5);"
"# Plot difference versus the time-step size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.title('L1-norm of the difference vs. time-step size')
pyplot.xlabel('$\Delta t$')
pyplot.ylabel('Difference')
pyplot.grid()
pyplot.loglog(dt_values[:-1], diff_values[:-1],
              color='C0', linestyle='--', marker='o')
pyplot.axis('equal');"
"print('Distance traveled: {:.3f}'.format(x_leapfrog[idx_ground_leapfrog - 1]))

# Plot the glider's path for the leapfrog scheme.
pyplot.figure(figsize=(9.0, 6.0))
pyplot.subplot(121)
pyplot.grid()
pyplot.xlabel('x')
pyplot.ylabel('y')
pyplot.plot(x_leapfrog[:idx_ground_leapfrog],
            y_leapfrog[:idx_ground_leapfrog])
# Let's take a closer look!
pyplot.subplot(122)
pyplot.grid()
pyplot.xlabel('x')
pyplot.ylabel('y')
pyplot.plot(x_leapfrog, y_leapfrog)
pyplot.xlim(0.0, 5.0)
pyplot.ylim(1.8, 2.5);"
"# Plot the path of the glider.
pyplot.figure(figsize=(9.0, 4.0))
pyplot.title('Path of the glider (flight time = {})'.format(T))
pyplot.xlabel('x')
pyplot.ylabel('y')
pyplot.grid()
pyplot.plot(x, y, color='C0', linestyle='-', linewidth=2);"
"# Plot the difference versus the time-step size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.title('L1-norm difference vs. time-step size')  # set the title
pyplot.xlabel('$\Delta t$')  # set the x-axis label
pyplot.ylabel('Difference')  # set the y-axis label
pyplot.grid()
pyplot.loglog(dt_values[:-1], diff_values,
              color='C0', linestyle='--', marker='o')  # log-log plot
pyplot.axis('equal');  # make axes scale equally"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo('ysdU4mnRYdM')"
"# Initial conditions: zt = 64.0, z0 = 16.0, theta0 = 0.0.
plot_flight_path(64.0, 16.0, 0.0)"
"# Initial conditions: zt = 64.0, z0 = 16.0, theta0 = 180.0.
plot_flight_path(64.0, 16.0, 180.0)"
"# Initial conditions: zt = 16.0, z0 = 48.0, theta0 = 0.0.
plot_flight_path(16.0, 48.0, 0.0)"
"# Initial conditions: zt = 64.0, z0 = 16.0, theta0 = -90.0.
plot_flight_path(64.0, 16.0, -90.0)"
linear_convection(41)  # solve using 41 spatial grid points
linear_convection(61)
linear_convection(71)
linear_convection(85)
linear_convection_cfl(85)
linear_convection_cfl(121)
"# Plot the initial conditions.
pyplot.figure(figsize=(4.0, 4.0))
pyplot.title('Initial conditions')
pyplot.xlabel('x')
pyplot.ylabel('u')
pyplot.grid()
pyplot.plot(x, u0, color='C0', linestyle='--', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 2.5);"
"# Plot the solution after nt time steps
# along with the initial conditions.
pyplot.figure(figsize=(4.0, 4.0))
pyplot.xlabel('x')
pyplot.ylabel('u')
pyplot.grid()
pyplot.plot(x, u0, label='Initial',
            color='C0', linestyle='--', linewidth=2)
pyplot.plot(x, u, label='nt = {}'.format(nt),
            color='C1', linestyle='-', linewidth=2)
pyplot.legend()
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 2.5);"
"# Plot the initial conditions.
pyplot.figure(figsize=(4.0, 4.0))
pyplot.title('Initial conditions')
pyplot.xlabel('x')
pyplot.ylabel('u')
pyplot.grid()
pyplot.plot(x, u0, color='C0', linestyle='--', linewidth=2)
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 2.5);"
"# Plot the solution after nt time steps
# along with the initial conditions.
pyplot.figure(figsize=(4.0, 4.0))
pyplot.xlabel('x')
pyplot.ylabel('u')
pyplot.grid()
pyplot.plot(x, u0, label='Initial',
            color='C0', linestyle='--', linewidth=2)
pyplot.plot(x, u, label='nt = {}'.format(nt),
            color='C1', linestyle='-', linewidth=2)
pyplot.legend()
pyplot.xlim(0.0, L)
pyplot.ylim(0.0, 2.5);"
"# Compute the solution using Jacobi relaxation method.
p, ites, diff = laplace_2d_jacobi(p0, maxiter=20000, rtol=1e-8)
print('Jacobi relaxation: {} iterations '.format(ites) +
      'to reach a relative difference of {}'.format(diff))"
"%%timeit
laplace_2d_jacobi(p0, maxiter=20000, rtol=1e-8)"
"# Compute the analytical solution.
p_exact = laplace_solution(x, y, Lx, Ly)

# Compute the relative L2-norm of the error.
l2_norm(p, p_exact)"
"%%timeit
fib_it(500000)"
"%%timeit
fib_it(500000)"
"%%timeit
fib_it(500000)"
print(numba.__version__)
"# Compute the solution using Jacobi relaxation method.
p, ites, conv_jacobi = laplace_2d_jacobi(p0,
                                         maxiter=20000, rtol=1e-8)
print('Jacobi relaxation: {} iterations '.format(ites) +
      'to reach a relative difference of {}'.format(conv_jacobi[-1]))"
"%%timeit
laplace_2d_jacobi(p0, maxiter=20000, rtol=1e-8)"
"# Compute the solution using Gauss-Seidel relaxation method.
p, ites, conv_gs = laplace_2d_gauss_seidel(p0,
                                           maxiter=20000, rtol=1e-8)
print('Gauss-Seidel relaxation: {} iterations '.format(ites) +
      'to reach a relative difference of {}'.format(conv_gs[-1]))"
"%%timeit
laplace_2d_gauss_seidel(p0, maxiter=20000, rtol=1e-8)"
"# Compute the solution using SOR method.
omega = 1.0
p, ites, conv_sor = laplace_2d_sor(p0, omega,
                                   maxiter=20000, rtol=1e-8)
print('SOR (omega={}): {} iterations '.format(omega, ites) +
      'to reach a relative difference of {}'.format(conv_sor[-1]))"
"# Compute the solution using SOR method.
omega = 1.5
p, ites, conv_sor = laplace_2d_sor(p0, omega,
                                   maxiter=20000, rtol=1e-8)
print('SOR (omega={}): {} iterations '.format(omega, ites) +
      'to reach a relative difference of {}'.format(conv_sor[-1]))"
"%%timeit
laplace_2d_sor(p0, omega, maxiter=20000, rtol=1e-8)"
"# Compute the solution using tuned SOR method.
omega = 2.0 / (1.0 + numpy.pi / nx)
p, ites, conv_opt_sor = laplace_2d_sor(p0, omega,
                                       maxiter=20000, rtol=1e-8)
print('SOR (omega={:.4f}): {} iterations '.format(omega, ites) +
      'to reach a relative difference of {}'.format(conv_opt_sor[-1]))"
"%%timeit
laplace_2d_sor(p0, omega, maxiter=20000, rtol=1e-8)"
"# Compute the relative L2-norm of the error.
l2_norm(p, p_exact)"
"# Plot the convergence history for different methods.
pyplot.figure(figsize=(9.0, 4.0))
pyplot.xlabel('Iterations')
pyplot.ylabel('Relative $L_2$-norm\nof the difference')
pyplot.grid()
pyplot.semilogy(conv_jacobi, label='Jacobi')
pyplot.semilogy(conv_gs, label='Gauss-Seidel')
pyplot.semilogy(conv_sor, label='SOR')
pyplot.semilogy(conv_opt_sor, label='Optimized SOR')
pyplot.legend()
pyplot.xlim(0, 20000);"
"# Set parameters.
Lx = 1.0  # domain length in the x direction
Ly = 1.0  # domain length in the y direction
nx = 41  # number of points in the x direction
ny = 41  # number of points in the y direction

# Create the gridline locations.
x = numpy.linspace(0.0, Lx, num=nx)
y = numpy.linspace(0.0, Ly, num=ny)

# Compute the analytical solution.
p_exact = laplace_solution(x, y, Lx, Ly)

# Plot the analytical solution.
plot_3d(x, y, p_exact)"
"# Plot the initial conditions.
plot_3d(x, y, p0)"
"# Plot the numerical solution.
plot_3d(x, y, p)"
"# Plot the error versus the grid-spacing size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.xlabel(r'$\Delta x$')
pyplot.ylabel('Relative $L_2$-norm\nof the error')
pyplot.grid()
dx_values = Lx / (numpy.array(nx_values) - 1)
pyplot.loglog(dx_values, errors,
              color='black', linestyle='--', linewidth=2, marker='o')
pyplot.axis('equal');"
"# Plot the error versus the grid-spacing size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.xlabel(r'$\Delta x$')
pyplot.ylabel('Relative $L_2$-norm\nof the error')
pyplot.grid()
dx_values = Lx / (numpy.array(nx_values) - 1)
pyplot.loglog(dx_values, errors,
              color='black', linestyle='--', linewidth=2, marker='o')
pyplot.axis('equal');"
"# Set the initial conditions.
p0 = numpy.zeros((ny, nx))

# Compute the source term.
b = poisson_source(x, y, Lx, Ly)

# Plot the initial scalar field.
plot_3d(x, y, p0)"
"# Plot the solution.
plot_3d(x, y, p)"
"# Plot the convergence history.
pyplot.figure(figsize=(9.0, 4.0))
pyplot.xlabel('Iterations')
pyplot.ylabel('Relative $L_2$-norm\nof the difference')
pyplot.grid()
pyplot.semilogy(conv, color='C0', linestyle='-', linewidth=2)
pyplot.xlim(0, len(conv));"
"# Plot the error versus the grid-spacing size.
pyplot.figure(figsize=(6.0, 6.0))
pyplot.xlabel(r'$\Delta x$')
pyplot.ylabel('Relative $L_2$-norm\nof the error')
pyplot.grid()
dx_values = Lx / (numpy.array(nx_values) - 1)
pyplot.loglog(dx_values, errors,
              color='black', linestyle='--', linewidth=2, marker='o')
pyplot.axis('equal');"
"plt.plot(x, hrf(x))
plt.xlabel(""time"")
plt.ylabel(""HRF"")"
"plt.plot(x, hrf(x, shift=3))
plt.xlabel(""time"")
plt.ylabel(""HRF"")"
"plt.plot(x, convolved_hrf(x, [0, 5], [1, 1.5]))
plt.xlabel(""time"")
plt.ylabel(""HRF"")"
"plt.plot(x_realistic, convolved_hrf(x_realistic, [0, 5], [1, 1.5]))
plt.xlabel(""time samples"")
plt.ylabel(""HRF"")"
"x = np.arange(0, 100, 0.25)
plt.plot(x, random_voxel_data(x, [0, 2, 15, 37]))"
"plt.figure()
inc = loansData['Monthly.Income']
h = inc.hist()
plt.title('Histogram of Monthly Income')
plt.show()"
"plt.figure()
h = loansData['Monthly.LogIncome'].hist()
plt.title('Histogram of Log(Monthly Income)')
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
%matplotlib inline

plt.figure(figsize=(8,4))
plt.scatter([0,0], [0, 1], color='b')
plt.scatter([10,10], [0, 1], color='r', marker='^')
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.xlabel('term 1')
plt.ylabel('term 2')
plt.show()

plt.figure(figsize=(8,4))
plt.scatter([0,0], [0, 1], color='b')
plt.scatter([10,10], [0, 1], color='r', marker='^')
plt.annotate('$\mu_1$', xy=(5,1), size=20)
plt.scatter([5], [1], color='k')
plt.annotate('$\mu_2$', xy=(5,0), size=20)
plt.scatter([5], [0], color='k')
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.xlabel('term 1')
plt.ylabel('term 2')
plt.show()

plt.figure(figsize=(8,4))
plt.scatter([0,10], [1, 1], color='b')
plt.scatter([0,10], [0, 0], color='r', marker='^')
plt.annotate('$\mu_1$', xy=(5,1), size=20)
plt.scatter([5], [1], color='k')
plt.annotate('$\mu_2$', xy=(5,0), size=20)
plt.scatter([5], [0], color='k')
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.xlabel('term 1')
plt.ylabel('term 2')
plt.show()"
"# Here's an example. 
# Exercise: work out the means/cluster assignments
# until convergence.
def plot(points, cluster_assignments, means):
    plt.figure()
    for point, asg in zip(points, cluster_assignments):
        plt.scatter([point[0]], [point[1]], marker='o' if asg==1 else '^')
    for i, m in enumerate(means):
        plt.annotate('$\mu_%d$' % i, xy=m, size=20)
        plt.scatter([m[0]], [m[1]], color='k')
    plt.show()
    
plot([(0, 0), (0, 1), (2, 0), (3,1), (3,0)], [0,0,0,1,1], [(1,0), (4,0)])"
"fig, ax = plt.subplots()

pdf[1947].plot(ax=ax, color='b', logy=True)
pdf[1967].plot(ax=ax, color='m', logy=True)
pdf[1987].plot(ax=ax, color='r', logy=True)
pdf[2004].plot(ax=ax, color='g', logy=True)
ax.legend()"
"from IPython.html.widgets import interact, fixed"
"# play with the colors 
fig, ax = plt.subplots()

years = [1947, 1967, 1987, 2004]

for year in years:
    darkness = (year-1940)/(2010-1940)
    pdf[year].plot(ax=ax, lw=2, color='b', alpha=darkness, logy=True)
    
ax.set_ylabel('Sales by Industry Rank (log scale)')
ax.set_xlabel('Industry Rank')
ax.legend(years, fontsize=10, handlelength=2, labelspacing=0.15)"
"model = smf.ols(formula = 'GSP ~ UNEMP + P_CAP + PC', data = df).fit()     #Fits the model

print(model.summary())  #Prints off a nice summary


"
"model1970 = smf.ols(formula='GSP ~ UNEMP + P_CAP + PC', data=df[df['YR']==1970]).fit()     #Fits the model

""""""
Notice that we've isolated a subset of the original dataframe (in this case the obs. corresponding to 1970)
by specificying 'data = df[df['YR']==1970]]' in the regression forumula above. 
""""""

print(model1970.summary())  #Prints off a nice summary"
"""""""
Below are a few examples of calling speficic elements of our regression
""""""
model.params          #Produces all coefficient estimates
model.params['P_CAP']  #Produces coefficient estimate for the regressor 'P_CAP'

model.bse               #Standard Errors for all regressors 
model.bse['P_CAP']      #Standard Errors for regressor 'P_CAP'

model.pvalues           #P-values for all regressors
model.pvalues['P_CAP']  #P-values for regressor 'P_CAP'

r_sqr = model.rsquared          #R-squared

print('The R^2 for our regression is',r_sqr)"
"import warnings
warnings.filterwarnings('ignore')
import sys

print('Welcome')
print(sys.version)"
"import warnings
warnings.filterwarnings('ignore')
import pandas as pd             # data package
import matplotlib.pyplot as plt # graphics 
import sys                      # system module, used to get Python version 
import datetime as dt           # date tools, used to note current date  

print('\nPython version: ', sys.version) 
print('Pandas version: ', pd.__version__)
print(""Today's date:"", dt.date.today())"
"# summarize results
for var in list(ep):
    print('\n', var, '\n', ep[var].value_counts().head(5), sep='')"
"ep['Stats'].str.contains('one', na=False).head(10)*1"
"print(""Python version: "", sys.version)
print(""Pandas version: "", pd.__version__)
print(""Matplotlib version: "", ml.__version__)"
"url1 = ""http://data.insideairbnb.com/united-states/""
url2 = ""ny/new-york-city/2016-02-02/data/listings.csv.gz""
full_df = pd.read_csv(url1+url2, compression=""gzip"")
full_df[[""id"", ""last_scraped"", ""name"", ""description"", ""number_of_reviews"", ""price"", ""review_scores_rating""]].head(3)"
full_df.dtypes
"df = full_df[[""id"", ""price"", ""number_of_reviews"", ""review_scores_rating"", ""bedrooms"", ""city"", ""neighbourhood""]]

df.tail(10)"
"df.replace({'price': {'\$': ''}}, regex=True, inplace=True)
df.replace({'price': {'\,': ''}}, regex=True, inplace=True)
df['price'] = df['price'].astype('float64', copy=False)"
"df.plot.scatter(x=""number_of_reviews"", y=""review_scores_rating"", figsize=(10, 8), alpha=0.2)"
"bins = [0, 5, 10, 25, 50, 100, 350]
boxplot_vecs = []

fig, ax = plt.subplots(figsize=(10, 8))

for i in range(1, 7):
    lb = bins[i-1]
    ub = bins[i]
    foo = df[""review_scores_rating""][df[""number_of_reviews""].apply(lambda x: lb <= x <= ub)].dropna()
    boxplot_vecs.append(foo.values)
    
ax.boxplot(boxplot_vecs, labels=bins[:-1])
ax.set_xlabel(""Number of Reviews"")
ax.set_ylabel(""Review Score"")
plt.show()"
"df.plot.scatter(x=""review_scores_rating"", y=""price"", figsize=(10, 8), alpha=0.2)"
"df.plot.scatter(x=""bedrooms"", y=""price"", figsize=(10, 8))"
"df[df[""neighbourhood""] == ""Upper West Side""].plot.scatter(x=""bedrooms"", y=""price"")"
"df[df[""city""] == ""New York""].plot.scatter(x=""bedrooms"", y=""price"")"
"for nuc in {'A','T','G','C'}:
    print(nuc, ':', sum([base==nuc for base in DNA]))"
"# convert the lat-long coordinates into a two-dimensional numpy array and plot it
coordinates = df.as_matrix(columns=['lon', 'lat'])

most_index = df['city'].value_counts().head(6).index
most = pd.DataFrame(df[df['city'].isin(most_index)])
most.drop_duplicates(subset=['city'], keep='first', inplace=True)

plt.figure(figsize=(10, 6), dpi=100)
co_scatter = plt.scatter(coordinates[:,0], coordinates[:,1], c='b', edgecolor='', s=15, alpha=0.3)

plt.title('Scatter plot of the full set of GPS points')
plt.xlabel('Longitude')
plt.ylabel('Latitude')

for i, row in most.iterrows():
    plt.annotate(row['city'], 
                 xy=(row['lon'], row['lat']),
                 xytext=(row['lon'] + 1.5, row['lat'] + 0.6),
                 bbox=dict(boxstyle='round', color='k', fc='w', alpha=0.6),
                 xycoords='data',
                 arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.5', color='k', alpha=0.8))

plt.show()"
"# performs k-means on a set of observation vectors forming k clusters
# returns a k-length array of cluster centroid coordinates, and the final distortion
cluster_centroids1, distortion = kmeans(w, k, iter=i)

# plot the cluster centroids
plt.figure(figsize=(10, 6), dpi=100)
plt.scatter(cluster_centroids1[:,0], cluster_centroids1[:,1], c='y', s=100)
plt.show()"
"# the kmeans2 function classifies the set of observations into k clusters using the k-means algorithm
# returns a k by N array of centroids found at the last iteration of k-means,
# and an index of the centroid the i'th observation is closest to
# use optional argument minit='points' because the data is not evenly distributed
# minit='points' will choose k observations (rows) at random from data for the initial centroids
cluster_centroids2, closest_centroids = kmeans2(w, k, iter=i, minit='points')

# plot the cluster centroids
plt.figure(figsize=(10, 6), dpi=100)
plt.scatter(cluster_centroids2[:,0], cluster_centroids2[:,1], c='r', s=100)
plt.scatter(w[:,0], w[:,1], c='k', alpha=.3, s=10)
plt.show()"
"# plot the original full data set colored by cluster - not very useful with this many clusters
plt.figure(figsize=(10, 6), dpi=100)
plt.scatter(coordinates[:,0], coordinates[:,1], c=closest_centroids, s=100)
plt.show()"
"print('k =', k)
print('N =', N)

# the size of cluster_centroids1 and cluster_centroids2 should be the same as k
print(len(cluster_centroids1)) # appears some clusters collapsed, giving us a value less than k
print(len(cluster_centroids2))

# the size of closest_centroids should be the same as N
print(len(closest_centroids))

# the number of unique elements in closest_centroids should be the same as k
print(len(np.unique(closest_centroids)))"
"# for each set of coordinates in our full data set, add the closest_centroid from the kmeans2 clustering
rs = pd.DataFrame(df)
rs['closest_centroid'] = closest_centroids

# reduce the data set so there is only one row for each closest_centroid
rs.drop_duplicates(subset=['closest_centroid'], keep='first', inplace=True)
rs.head()"
"# plot the final reduced set of coordinate points
plt.figure(figsize=(10, 6), dpi=100)
plt.scatter(rs['lon'], rs['lat'], c='m', s=100)
plt.show()"
"# plot the cluster centroids vs the whitened coordinate points
plt.figure(figsize=(10, 6), dpi=100)
plt.scatter(cluster_centroids2[:,0], cluster_centroids2[:,1], c='r', alpha=.7, s=150)
plt.scatter(w[:,0], w[:,1], c='k', alpha=.3, s=10)
plt.show()"
"# plot the final reduced set of coordinate points vs the original full set
plt.figure(figsize=(10, 6), dpi=100)
rs_scatter = plt.scatter(rs['lon'], rs['lat'], c='r', alpha=.7, s=150)
df_scatter = plt.scatter(df['lon'], df['lat'], c='k', alpha=.3, s=5)

plt.title('Full data set vs k-means reduced set')
plt.legend((df_scatter, rs_scatter), ('Full set', 'Reduced set'), loc='upper left')
plt.xlabel('Longitude')
plt.ylabel('Latitude')

plt.show()"
"# reshape() since it needs input as a 2D matrix
encoded_dense = ohe_dense.fit_transform(orig.reshape(-1, 1))
encoded_dense"
ohe_dense.active_features_
"decoded_dense = encoded_dense.dot(ohe_dense.active_features_).astype(int)
decoded_dense"
ohe_sparse.active_features_
"np.allclose(orig, encoded_sparse.dot(ohe_sparse.active_features_))"
"import warnings
warnings.filterwarnings('ignore')
class Ball(object):
    pass

b = Ball()
b.__repr__()"
print(b)
"i = Image(filename='./images/ipython-image.png')
display(i)"
i
"from IPython.display import YouTubeVideo
YouTubeVideo('sjfsUzECqK0')"
"from IPython.display import IFrame
IFrame('https://ipython.org', width='100%', height=350)"
"from IPython.display import FileLink, FileLinks
FileLink('../Visualize/01-Introduction.ipynb')"
FileLinks('./')
"Image(""images/mackinlay1.png"", width=600)"
"Image(""images/mackinlay2.png"", width=600)"
"for i in range(10):
    print(np.random.rand())"
"μ = 2.0
σ = np.sqrt(1.0)
for i in range(10):
    print(np.random.normal(μ, σ))"
"for i in range(10):
    print(np.random.choice(['summer', 'winter'], p=[0.25, 0.75]))"
"np.random.choice(['summer', 'winter'], p=[0.25, 0.75], size=10)"
x[0:10]
"pdf, bins, patches = plt.hist(x, normed=True)
plt.xlabel('x')
plt.ylabel('P(x)');"
"interact(plot_uniform_pdf, n=(100,2000,100));"
"plt.hist(data, bins=20);"
"mu_hat = data.mean()
mu_hat"
"var_hat = data.var()
var_hat"
"theta_hat = [mu_hat, var_hat]
theta_hat"
data.min()
"for i in range(10):
    print(biased_var(theta, observations))"
"bias1 = var_dist1.mean() - theta[1]
bias2 = var_dist2.mean() - theta[1]
print(""Bias of biased esimator: {}"".format(bias1))
print(""Bias of unbiased esimator: {}"".format(bias2))"
"plt.plot(m, biased_data, label='Biased')
plt.plot(m, unbiased_data, label='Unbiased')
plt.hlines(theta[1], 0, 100, color='grey', alpha=0.8, label=""True value"")
plt.ylabel('Variance estimate')
plt.xlabel('Number of observations (m)')
plt.title('Biased/Unbiased Estimators: Variance of the Normal Dist.')
plt.legend();"
"fig, ax = plt.subplots(2, 1, sharex=True)
ax[0].hist(var_dist1, bins=20, normed=True)
ax[0].set_title('Biased')
ax[1].hist(var_dist2, bins=20, normed=True)
ax[1].set_title('Unbiased')
ax[1].set_xlabel('Estimated Variance')
plt.tight_layout();"
"var_dist1.mean(), var_dist2.mean()"
"var_dist1.var(), var_dist2.var()"
"m = 100
data = np.random.choice(['H','T'], m, p=[0.5, 0.5])
data"
fair(data)
"data2 = np.random.choice(data, size=len(data))
data2"
fair(data2)
"for i in range(20):
    re_data = bootstrap_data(data)
    print(fair(re_data))"
fairs
"plt.hist(fairs, bins=20)
plt.xlim(0, 1.0)
plt.title(""Bootstrapped coin fairness"")
plt.xlabel(""Fairness"")
plt.grid(True)
plt.ylabel(""Count"");"
"print(""Mean fairness:"", fairs.mean())
print(""95% confidence interval:"", np.percentile(fairs, (2.5,97.5)))"
"bias = fairs.mean() - fair(data)
var = fairs.var()
bias, var"
"x = ""abc""
# nur solche, die nicht mit ""_"" beginnen
print([a for a in dir(x) if not a.startswith(""_"")])"
inspect.getargspec(f2)
"x = 42
frame = inspect.currentframe()
print(inspect.getframeinfo(frame))
print(""Lokale Variable x: %s"" % frame.f_locals['x'])"
"# xx und yy werden die x und y koordinaten aller Punkte beinhalten.

xx = []
yy = []

for i in range(-20, 30):
    x = i / 10.
    y = -.3 * x** 5 + 10 * x**2 + x - 1
    xx.append(x)
    yy.append(y)

plt.plot(xx, yy)"
"# selbe daten, andere Darstellung
plt.plot(xx, yy, marker=""o"", color=""cyan"", ms=10, linestyle="""")"
"xx = [5, -6, 1, 8, -1, 11]
yy = [1, 2, 6, -1, 0, 1]

plt.scatter(xx, yy, s=100, color=""red"")
plt.scatter([2, 6], [3, 3], s=200, color=""blue"")"
"N = 100
x = np.random.randn(N)
y = 5 * np.random.rand(N)
colors = np.random.rand(N)
area = np.pi * (10 * np.random.rand(N) + y)**2

plt.scatter(x, y, s=area, c=colors, alpha=0.5)"
"X = np.linspace(-6, 6, 100) # 100 ist die Anzahl der gleichmäßig verteilten Punkte
Y = np.linspace(-3, 3, 100)
X, Y = np.meshgrid(X, Y)

U = -2 - X + 2 * Y**2
V = 1 + np.sqrt(X**2 + Y**2)

plt.streamplot(X, Y, U, V, color=U, linewidth=2, cmap=plt.cm.summer)
plt.colorbar()"
"speed = np.sqrt(U**2 + V**2)
speed /= speed.max()

plt.streamplot(X, Y, U, V, color=speed, linewidth=10*speed, cmap=plt.cm.summer)
plt.colorbar()"
"import matplotlib.pyplot as plt
import numpy as np

xx = np.linspace(-3, 3, 100)
yy = -xx**2 + 2*xx - 1

plt.plot(xx, yy)
plt.ylim(-20, 10)
ax = plt.gca()
ax.annotate('Maximum',
            xy=(1, 0), xycoords='data',
            xytext=(-2, 5), textcoords='data', size = 20,
            bbox = {'boxstyle' : 'round', 'fc' : '0.9'},
            arrowprops = {'arrowstyle' : '->', 'connectionstyle' : 'angle,angleA=0,angleB=270,rad=10'})"
"fp.cplot(lambda z : z, (-3, 3), (-3, 3), points=50000)"
"fp.cplot(lambda z: fp.sin(z.real**2 + z.imag**2) + z.imag*1j, (-4, 4), (-4, 4), points=30000)"
"rcParams[""figure.figsize""] = (12,10)
fp.cplot(fp.cos, (-7, 7), (-4, 4), points=50000)"
"import matplotlib.pyplot as plt

kochzeit = np.array([30, 5, 10, 50, 5])
verarbeitung = np.array([30,20,40, 5, 10])
vorbereitung = np.array([10, 5, 5, 7, 5])
idx = np.arange(len(kochzeit))
speisen = [""$S_{%d}$""%i for i in idx]

p1 = plt.bar(idx, kochzeit, align=""center"", color='orange', 
             label='Kochzeit')
p2 = plt.bar(idx, verarbeitung, align=""center"", color='y', 
             bottom=kochzeit, 
             yerr=.2 * kochzeit, 
             label='Verarbeitung')
p3 = plt.bar(idx, vorbereitung, align=""center"", color='g', 
             bottom=kochzeit+verarbeitung, 
             label='Vorbereitung')

plt.title('Speisezubereitung')
plt.xticks(idx, speisen)
plt.ylabel(""Minuten"")
plt.legend()
plt.legend()"
"import numpy as np
data1 = np.r_[4 * np.random.randn(1000) - 3,
              np.linspace(3, 6, 1000)**2 + np.random.randn(1000)]
_ = plt.hist(data1, 25, color=""grey"")"
"plt.scatter(data1, data2, c=""black"", marker=""x"", alpha=.5)"
"plt.hist2d(data1, data2, bins=30, cmap=plt.cm.bone_r)
plt.grid()
plt.colorbar()"
"plt.hexbin(data1, data2, gridsize=25, cmap=plt.cm.bone_r)
plt.colorbar()"
"fig, axes = plt.subplots(2, 2)
ax = axes[1, 0]
ax.add_artist(plt.Circle((2, 1), 3, color=""yellow""))
ax.set_xlim(-10, 10)
ax.set_ylim(-5, 5)
axes[1,1].grid()"
"fig, axes = plt.subplots(1, 2, sharey=True)
xx = np.linspace(-10, 10, 1000)
[ax.grid() for ax in axes] # grid für beide
axes[0].plot(np.sin(xx * xx))
axes[1].plot(np.cos(xx) * xx, color=""red"")
fig.subplots_adjust(wspace=0) # no horizontal space"
"fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,3))
xx = np.linspace(1, 20, 1000)
yy = np.log(xx**2 + 1) * np.sin(xx) + xx
ax1.plot(xx, yy)
ax2.scatter(sorted(xx), sorted(yy), s=1, marker=""."", color=""green"")
ax3.hist(yy, bins=20, color=""red"", alpha=.5)
fig.tight_layout()"
"xx = np.linspace(0, 4 * np.pi, 1000)
yy = np.sin(xx) + np.cos(2 * xx) + 3
plt.close(""all"")
axpolar = plt.gca(projection='polar')
axpolar.plot(xx, yy)
axpolar.plot(xx + .5 * np.pi, 1.2 * yy, color=""green"")
axpolar.plot(xx +  1 * np.pi, 1.5 * yy, color=""red"")
axpolar.set_rmax(7)"
"from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm

fig = plt.figure()
ax = fig.gca(projection='3d')
X, Y, Z = axes3d.get_test_data(0.05)
ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)
cset = ax.contour(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)
cset = ax.contour(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)
cset = ax.contour(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)

ax.set_xlabel('X')
ax.set_xlim(-40, 40)
ax.set_ylabel('Y')
ax.set_ylim(-40, 40)
ax.set_zlabel('Z')
ax.set_zlim(-100, 100)

plt.show()"
"from matplotlib import cm
from IPython.html.widgets import interact

sr = (-10, 10, .1)
@interact(a = sr, b = sr, c = sr, d = sr, elevation=(0,90), azimuth=(0,180))
def xy_grid3d(a = -2, b = -4, c = 4, d = 4, elevation=40, azimuth=30):
    X = np.linspace(-10, 10, 100)
    Y = np.linspace(-10, 10, 100)
    X, Y = np.meshgrid(X, Y)
    
    Z = 15 * np.exp(-.5 * (X - a)**2 - (Y - b)**2) 
    Z += - 25 * np.exp(.15 * (-(X - c)**2 - (Y - d)**2))
    Z += - .1 * (np.sin(X) - Y)**2

    fig = plt.figure()
    ax = fig.gca(projection='3d')
    ax.view_init(elev=elevation, azim=azimuth)
    ax.plot_surface(X, Y, Z, rstride=5, cstride=5, alpha=0.65, cmap=cm.afmhot)
    
    #cset = ax.contour(X, Y, Z, zdir='z', offset=-30, cmap=cm.coolwarm)
    #cset = ax.contour(X, Y, Z, zdir='x', offset=-15, cmap=cm.coolwarm)
    #cset = ax.contour(X, Y, Z, zdir='y', offset=-15, cmap=cm.coolwarm)
    
    ax.set_xlabel('X')
    ax.set_xlim(-10, 10)
    ax.set_ylabel('Y')
    ax.set_ylim(-10, 10)
    ax.set_zlabel('Z')
    ax.set_zlim(-30, 15)
    
    # Colorbar auf der rechten Seite
    m = plt.cm.ScalarMappable(cmap=cm.afmhot)
    m.set_array(Z)
    plt.colorbar(m, shrink=.5)
    
    plt.show()"
"p = plot(sqrt(x) * cos(x), sqrt(x), -sqrt(x), (x, 0, 10), show=False)
p[0].line_color=""red""
p[1].line_color=""blue""
p[2].line_color=""blue""
p.show()"
"p = plot_implicit(Or(
                 And(
                    x**2 + y**2 < 25, 
                    x**2 + y**2 > 10, 
                 ), 
                 x**2 - 5*x < y - 10), 
              (x,-10, 10), (y, -10, 10))"
"from sympy.plotting import plot3d_parametric_surface
from sympy import pi
from sympy.abc import u, v
R = 10
r = 3
p = plot3d_parametric_surface(
    (R + r * cos(u)) * cos(v),
    (R + r * cos(u)) * sin(v), 
    r * cos(u),
    (u, -pi, pi), (v, -pi, pi))"
"import warnings
warnings.filterwarnings('ignore')
import numpy as np
from scipy.spatial import ConvexHull

pts = np.random.normal(size=(100,2))
chull = ConvexHull(pts)
chull.vertices"
"%matplotlib inline
import matplotlib.pyplot as plt
for simplex in chull.simplices:
    plt.plot(pts[simplex, 0], pts[simplex, 1], ""g-"", lw=2, zorder=1)
plt.scatter(pts[:,0], pts[:,1], zorder=2)"
"import sympy as sy
from sympy.geometry import Point, Segment, Circle, Line, Triangle"
seg1.intersection(seg2)
seg1.midpoint
"l2 = Line(Point(2, -4), Point(3, -2))
c.intersection(l2)"
"xx = [20, 15,  11, 7.57, 9.6, 13,  21,  24, 28, 23, 20]
yy = [3, 2.5, 2.3, 2.66,  3, 3.1, 2.3, 2.5, 2.8, 3,  3]

plt.plot(xx, yy, ""o-"")
plt.xlim(5, 30)
plt.ylim(2, 3.3)"
"from sympy.plotting import plot
plot(sin_square, (x, -3, 15))"
"from IPython.html.widgets import interact
from sympy.abc import x
from sympy import exp, cos
from sympy.plotting import plot

@interact(a = (0, 20, .1), b = (0, 3, .1))
def damped_oscillation(a = 10, b = .5):
    f2 = a * exp(-b * x) * cos(a * x) / a
    plot(f2, (x, 0, 10), ylim=(-1, 1))"
"from IPython.html.widgets import interact
import numpy as np

@interact(a=(-2, 2, .1), b =(-2, 2, .1), c=(-2, 2, .1), d=(-2, 2, .1))
def elliptic_plot(a = 1., b = 0, c = 0, d = -1):
    phi = np.linspace(0, 8 * np.pi, 1000)
    m = np.array([[a, b],
                  [c, d]])
    v = np.c_[np.sin(phi), 
              np.cos(phi)].T
    r = np.log1p(phi)
    
    xx, yy = m.dot(r * v)
    
    plt.plot(xx, yy)
    plt.grid()
    plt.ylim(-4, 4)
    plt.xlim(-4, 4)"
"_ = plt.hist(data, 20, color=""grey"")"
"from sympy.ntheory.modular import crt
crt([2, 3, 13], [1, 2, 7])"
"import warnings
warnings.filterwarnings('ignore')
authornames = ! git log --pretty=format:""%aN <%aE>"" HEAD
for name in sorted(set(authornames), key = lambda n : n.split(""<"")[0].split()[-1]):
    print(name)"
w
v + w
v - w
v * w
v.dot(w)
"x = np.array([1,2,3])
np.sin(x)"
np.exp(x)
"np.arange(1, 5, .5)"
"np.linspace(0, 2, 10)"
"np.logspace(-1, 2, 10, base=10)"
f2
"eigenvalues, eigenvectors = LA.eig(m)
print(eigenvalues)
print(eigenvectors)"
LA.inv(m)
LA.inv(m).dot(m)
"opti1 = minimize(f1, x0, bounds = bounds)
opti1"
"x_opti = opti1[""x""]
x_opti"
"f3_root = root(f3, [2., 1.])
f3_root"
"import warnings
warnings.filterwarnings('ignore')
import datetime
print(""Zeitpunkt: %s"" % datetime.date.today())

import sys
print(""Python: %s"" % sys.version.splitlines()[0])

# bs4: beautifulsoup4
libs = ['numpy', 'scipy', 'matplotlib', 'sympy', 'mpmath', 'pandas', 'statsmodels',
        'sklearn', 'networkx', 'yaml', 'json', 'csv', 'sqlite3', 'cython', ""bs4""]
from importlib import import_module
for lib_name in sorted(libs):
    lib = import_module(lib_name)
    try:
        vers = lib.__version__
    except:
        vers = lib.version
    print(""{:<15s} {}"".format(lib_name, vers))"
"plt.plot(X.ravel(), Y.ravel(), 'k.')
for vert in verts:
    plt.fill(vert[:,0], vert[:,1], edgecolor='none', alpha=0.2)"
"T = matplotlib.transforms.Affine2D()
T.rotate_around(1, 1, 0.1 * np.pi)
"
"XY_t = T.transform(np.c_[X.ravel(), Y.ravel()])
X_t, Y_t = XY_t[:,0].reshape(X.shape), XY_t[:,1].reshape(Y.shape)
vert_t = [T.transform(vert) for vert in verts]
vert_t = grid2enclosure(X_t, Y_t)

plt.plot(X_t, Y_t, 'k.')
for vert in vert_t:
    plt.fill(vert[:,0], vert[:,1], edgecolor='none', alpha=0.2)"
"T.skew(0.8, 0.3)
"
"XY_t = T.transform(np.c_[X.ravel(), Y.ravel()])
X_t, Y_t = XY_t[:,0].reshape(X.shape), XY_t[:,1].reshape(Y.shape)
vert_t = [T.transform(vert) for vert in verts]
vert_t = grid2enclosure(X_t, Y_t)

plt.plot(X_t, Y_t, 'k.')
for vert in vert_t:
    plt.fill(vert[:,0], vert[:,1], edgecolor='none', alpha=0.2)"
"# note that this has 1 cell less
mesh = plt.pcolormesh(X_t, Y_t, X_t)"
"vor = scipy.spatial.Voronoi(np.c_[X_t.ravel(), Y_t.ravel()])
scipy.spatial.voronoi_plot_2d(vor)"
"# Note on np.random.nrand()
# distribution of mean 0 and variance 1
# returns number of integers passed
np.random.randn(4)"
grey_height[:5]
"plt.hist([grey_height, lab_height], stacked=True, color=['r', 'b'])
plt.show()"
"f = y(n) - Fraction(295, 100)*y(n - 1) + 2*y(n - 2)
display(f)"
"eqn = Eq(f, 0)
soln = rsolve(eqn, y(n))
display(soln)
soln.evalf()"
"# Create non-homogeneous equation
eqn = Eq(f, -63.685*(1.07**n))
display(eqn)"
"soln = rsolve(eqn, y(n), init={y(0) : 2000, y(1) : 2200})
display(soln)
soln.evalf()"
"# Plot
plot(soln, (n, 0, 12), xlabel=""year (n)"", ylabel=""fee"")

# Evaluate fee at 10 years
print(""Fee after 10 years (n=10): {}"".format(soln.subs(n, 10).evalf()))"
"n = Symbol(""n"", integer=True)
y = Function(""y"")

a, b, c = symbols(""a b c"")

f = a*y(n) - b*y(n - 1) + c*y(n - 2)
display(f)"
"eqn = Eq(f, 0)
soln = rsolve(eqn, y(n))
display(soln)"
"soln = rsolve(eqn, y(n), init={y(0) : 2, y(1) : 1})
display(soln)"
"eqn1 = eqn.subs('a', 4).subs('b', 1).subs('c', 2)
soln = rsolve(eqn1, y(n), init={y(0) : 1, y(1) : 2})
display(soln)

plot(soln, (n, 0, 12), xlabel=""$n$"", ylabel=""$y_{n}$"");"
"f = a*y(n) - b*y(n - 1) + c*y(n - 2)
eqn = Eq(f, 0)
display(eqn)"
"def plot_solution(a=6, b=1, c=8):
    # Substitute in parameters
    eqn1 = eqn.subs('a', a).subs('b', b).subs('c', c)
    
    # Check roots
    roots = ((-b - sqrt(b**2 - 4*a*c))/(2*a), (-b + sqrt(b**2 - 4*a*c))/(2*a))
    print(""Roots of characteristic eqn:"")
    display(roots)

    # Solve
    soln = rsolve(eqn1, y(n), init={y(0) : 1, y(1) : 2})
    print(""Solution:"")
    display(soln)
    
    # Plot
    plot(soln, (n, 0, 20), xlabel=""$n$"", ylabel=""$y_n$"", axis_center=""auto"", adaptive=False, nb_of_points=21)

    
interact(plot_solution, a=(-10, 11, 2), b=(-2, 20, 1), c=(1, 10, 1), continuous_update=False);"
"eqn = Eq(m*Derivative(y(t), t, t) + lmbda*Derivative(y(t), t) + k*y(t), 0)
display(eqn)"
"y = dsolve(eqn, y(t))
display(y)"
"y = Function(""y"")
x = symbols(""x"")
eqn = Eq(Derivative(y(x), x, x) + 2*Derivative(y(x), x) - 3*y(x), 0)
display(eqn)"
"y1 = dsolve(eqn)
display(y1)"
"eqn = Eq(lmbda**2 + 2*lmbda -3, 0)
display(eqn)"
solve(eqn)
"# Compute determinant
detA = np.linalg.det(A)
print(""Determinant of A: {}"".format(detA))

# Compute inverse
Ainv = np.linalg.inv(A)
print(""Inverse of A"")
print(Ainv)

# Check that inverse is correct
print(""A*A^-1: {}"".format(A*Ainv))"
"%matplotlib inline

# Set up plotting environment
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np
from itertools import product, combinations

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.set_aspect(""equal"")

# Draw cube
r = [0, 1]
for s, e in combinations(np.array(list(product(r, r, r))), 2):
    if np.sum(np.abs(s - e)) == r[1] - r[0]:
        ax.plot3D(*zip(s, e), color=""b"", marker=""o"")"
"# Draw orginal cube and transformed shape
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.set_aspect(""equal"")
r = [0, 1]
for s, e in combinations(np.array(list(product(r, r, r))), 2):
    if np.sum(np.abs(s - e)) == r[1] - r[0]:
        ax.plot3D(*zip(s, e), color=""b"", marker=""o"")
        
        s = A.dot(s)
        e = A.dot(e)
        ax.plot3D(*zip(s, e), color=""r"", marker=""o"")"
"# Create a transformation matrix (diagonal)
A = np.array([[0.8, 0.0, 0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.7]])

# Check determinant
print(""Det A: {}"".format(np.linalg.det(A)))

# Draw orginal cube and transformed shape
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.set_aspect(""equal"")
r = [0, 1]
for s, e in combinations(np.array(list(product(r, r, r))), 2):
    if np.sum(np.abs(s - e)) == r[1] - r[0]:
        ax.plot3D(*zip(s, e), color=""b"", marker=""o"")
        s = A.dot(s)
        e = A.dot(e)
        ax.plot3D(*zip(s, e), color=""r"", marker=""o"")
        
        "
"# Create a transformation matrix (diagonal)
A = np.array([[0.8, 0.8, 0.8], [0.6, 1.0, 0.0], [-1.1, 0.0, 0.7]])

# Check determinant
print(""Det A: {}"".format(np.linalg.det(A)))

# Draw orginal cube and transformed shape
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.set_aspect(""equal"")
r = [0, 1]
for s, e in combinations(np.array(list(product(r, r, r))), 2):
    if np.sum(np.abs(s - e)) == r[1] - r[0]:
        ax.plot3D(*zip(s, e), color=""b"", marker=""o"")
        
        s = A.dot(s)
        e = A.dot(e)
        ax.plot3D(*zip(s, e), color=""r"", marker=""o"")"
"# Create a transformation matrix (diagonal)
A = np.array([[2.0, 0.0, 0.0], [0.0, 1.1, 0.0], [0.0, 0.0, 1.1]])

# Check determinant
print(""Det A: {}"".format(np.linalg.det(A)))

# Draw orginal cube and transformed shape
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.set_aspect(""equal"")
r = [0, 1]
for s, e in combinations(np.array(list(product(r, r, r))), 2):
    if np.sum(np.abs(s - e)) == r[1] - r[0]:
        ax.plot3D(*zip(s, e), color=""b"", marker=""o"")
        
        s = A.dot(s)
        e = A.dot(e)
        ax.plot3D(*zip(s, e), color=""r"", marker=""o"")"
"# Multiply A by -1 and print determinant
A = -A
print(""Det A: {}"".format(np.linalg.det(A)))

# Draw orginal cube and transformed shape
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.set_aspect(""equal"")
r = [0, 1]
for s, e in combinations(np.array(list(product(r, r, r))), 2):
    if np.sum(np.abs(s - e)) == r[1] - r[0]:
        ax.plot3D(*zip(s, e), color=""b"", marker=""o"")
        
        s = A.dot(s)
        e = A.dot(e)
        ax.plot3D(*zip(s, e), color=""r"", marker=""o"")"
"import itertools

# Build pairs (0,0), (0,1), . . . (0, n-1), (1, 2), (1, 3), . . . 
pairs = itertools.combinations_with_replacement(range(len(evectors)), 2)

# Compute dot product of eigenvectors x_{i} \cdot x_{j}
for p in pairs:
    e0, e1 = p[0], p[1]
    print (""Dot product of eigenvectors {}, {}: {}"".format(e0, e1, evectors[:, e0].dot(evectors[:, e1])))"
"# Compute dot product of eigenvectors x_{i} \cdot x_{j}
pairs = itertools.combinations_with_replacement(range(len(evectors)), 2)
for p in pairs:
    e0, e1 = p[0], p[1]
    print (""Dot product of eigenvectors {}, {}: {}"".format(e0, e1, evectors[:, e0].dot(evectors[:, e1])))"
"Lambda = np.linalg.inv(evectors).dot(A.dot(evectors))
print(Lambda)"
"# Create a symmetric matrix
S = A + A.T

# Compute eigenvectors of S and print eigenvalues
lmbda, U = np.linalg.eig(S)
print(lmbda)

# R matrix
R = U.T

# Diagonalise S
Lambda = R.dot(S.dot(R.T))
print(Lambda)"
"# Create starting vector
x0 = np.random.rand(S.shape[0])

# Perform power iteration
for i in range(10):
    x0 = S.dot(x0)
    x0 = x0/np.linalg.norm(x0)
x1 = S.dot(x0)

# Get maxiumum exact eigenvalue (absolute value)
eval_max_index = abs(lmbda).argmax()
max_eig = lmbda[eval_max_index]

# Print estimated max eigenvalue and error 
max_eig_est = np.sign(x1.dot(x0))*np.linalg.norm(x1)/np.linalg.norm(x0)
print(""Estimate of largest eigenvalue: {}"".format(max_eig_est))
print(""Error: {}"".format(abs(max_eig - max_eig_est)))"
"# Create starting vector
x0 = np.random.rand(S.shape[0])

# Get eigenvector associated with maxiumum eigenvalue
eval_max_index = abs(lmbda).argmax()
evec_max = U[:,eval_max_index]

# Make starting vector orthogonal to eigenvector associated with maximum 
x0 = x0 - x0.dot(evec_max)*evec_max

# Perform power iteration
for i in range(10):
    x0 = S.dot(x0)
    x0 = x0/np.linalg.norm(x0)
x1 = S.dot(x0)

# Print estimated max eigenvalue and error
max_eig_est = np.sign(x1.dot(x0))*np.linalg.norm(x1)/np.linalg.norm(x0)
print(""Estimate of largest eigenvalue: {}"".format(max_eig_est))
print(""Error: {}"".format(abs(max_eig - max_eig_est)))   

# Get second largest eigenvalue
print(""Second largest eigenvalue (exact): {}"".format(lmbda[np.argsort(abs(lmbda))[-2]]))  "
"rayleigh_quotient = x1.dot(S).dot(x1)/(x1.dot(x1))
print(""Rayleigh_quotient: {}"".format(rayleigh_quotient))"
"x = Symbol(""x"")
y = Function(""y"")
f = Function(""f"")
eqn = Eq(Derivative(y(x), x, x) + 2*Derivative(y(x), x) + y(x), 0)
display(eqn)
dsolve(eqn)"
"eqn = Eq(Derivative(y(x), x, x) + 2*Derivative(y(x), x) + y(x), f(x))
dsolve(eqn)"
"# Compute eigenvectors to generate a set of orthonormal vector
evalues, evectors = np.linalg.eig(A)

# Verify that eigenvectors R[i] are orthogonal (see Lecture 8 notebook)
import itertools
pairs = itertools.combinations_with_replacement(range(np.size(evectors, 0)), 2)
for p in pairs:
    e0, e1 = p[0], p[1]
    print(""Dot product of eigenvectors vectors {}, {}: {}"".format(e0, e1, evectors[:, e0].dot(evectors[:, e1])))"
"Ap = (R).dot(A.dot(R.T))
print(Ap)"
"eqn = Eq(m*Derivative(y(t), t, t) + nu*Derivative(y(t), t) + k*y(t), f(t))
display(eqn)"
"soln = dsolve(eqn)
display(soln)"
"def plot_solution(m=10, ν=1, k=20):
    # Substitute in parameters
    eqn1 = eqn.subs(f(t), 0).subs('m', m).subs('nu', ν).subs('k', k)
    
    roots = (-ν - sqrt(ν**2 - 4*m*k))/(2*m), (-ν + sqrt(ν**2 - 4*m*k))/(2*m)
    print(""Roots of characteristic eqn:"", roots)
    
    # Solve and insert constants
    soln = dsolve(eqn1)
    soln = soln.subs('C1', 0).subs('C2', 1)

    # Plot position vs time
    plot(soln.args[1], (t, 0.0, 20.0), ylim=(-1, 1), xlabel=""time"", ylabel=""displacement"");

interact(plot_solution, m=(1, 100, 1), ν=(0, 30, 0.5), k=(0.1, 100, 1));"
"# Define natural frequency
ω = Symbol(""omega"")
ω = sqrt(k/m)

# Set f(t) = sin(\omega t)
α = symbols(""alpha"")
β = symbols(""beta"")

eqn1 = eqn.subs(f(t), sin(ω*t*α/β))
display(eqn1)"
"# Set numerical values for m, lambda and k
m, nu, k = 4, 0, 1
eqn1 = eqn1.subs('m', m).subs('k', k).subs('nu', nu)

def plot_solution(α=0, β=1):
    # Substitute in parameters
    eqn2 = eqn1.subs('alpha', α).subs('beta', β)
    
    print(""Forcing frequency as fraction of natural frequency: "", α/β)    
    
    # Solve and insert constants
    soln = dsolve(eqn2)
    soln = soln.subs('C1', 0).subs('C2', 1)
    display(soln)
           
    # Plot position vs time
    plot(soln.args[1], (t, 0.0, 200.0), xlabel=""time"", ylabel=""displacement"");

interact(plot_solution, α=(0, 10, 1), β=(1, 10, 1));"
"eqn = Eq(Derivative(x(t), t), v0*exp(-t/(tau)))
display(eqn)"
"x = dsolve(eqn, x(t))
display(x)"
"x = x.subs('C1', v0*tau)
display(x)"
"x = x.subs(v0, 100)

def plot(τ=1.0):
    x1 = x.subs(tau, τ)

    # Plot position vs time
    sympy.plot(x1.args[1], (t, 0.0, 10.0), xlabel=""time"", ylabel=""position"");

interact(plot, τ=(0.0, 10, 0.2));"
"t, m, k, alpha = symbols(""t m k alpha"")
v = Function(""v"")
eqn = Eq((m/k)*Derivative(v(t), t), alpha*alpha - v(t)*v(t))
display(eqn)"
"v = dsolve(eqn, v(t))
display(v)"
print(Q.dot(Q.T))
"import itertools

# Build pairs (0,0), (0,1), . . . (0, n-1), (1, 2), (1, 3), . . . 
pairs = itertools.combinations_with_replacement(range(len(Q)), 2)

# Compute dot product of column vectors q_{i} \cdot q_{j}
for p in pairs:
    col0, col1 = p[0], p[1]
    print (""Dot product of column vectors {}, {}: {}"".format(col0, col1, Q[:, col0].dot(Q[:, col1])))"
"# Compute dot product of row vectors q_{i} \cdot q_{j}
pairs = itertools.combinations_with_replacement(range(len(Q)), 2)
for p in pairs:
    row0, row1 = p[0], p[1]
    print (""Dot product of row vectors {}, {}: {}"".format(row0, row1, Q[row0, :].dot(Q[row1, :])))"
"import warnings
warnings.filterwarnings('ignore')
from sympy import *
init_printing()
from IPython.display import display
from sympy.plotting import plot_parametric

# This command makes plots appear inside the browser window
%matplotlib inline

# Create independent variable and function for x and y
s = Symbol('s')
xs = Function('xs')
ys = Function('ys')

# Pick concrete values for a and b
a = 5
b = 3

# Parametric representation of ellipse
xs = a*cos(s)
ys = b*sin(s)

# Plot parametric line
plot_parametric(xs, ys)"
"x, y = symbols('x y')
f = Eq(x**2/a**2 + y**2/b**2, 1)
display(f)
grad_f = (diff(f.args[0], x), diff(f.args[0], y))
display(grad_f)"
"from sympy.utilities.lambdify import lambdify
import numpy as np
import matplotlib.pyplot as plt

# Set plot limits (based on ellipse size)
plt.xlim(-(a + 1), a + 1)
plt.ylim(-(b + 1), b + 1)

# Make plot aspect ratio equal -> normal lines appear normal
ax = plt.axes()
ax.set_aspect('equal')

# Prepare the symbolix expression for x(s) and y(s) for plotting
xs = lambdify(s, xs, modules=['numpy'])
ys = lambdify(s, ys, modules=['numpy'])

# Plot ellipse
s = np.linspace(0, 7, 300)
plt.plot(xs(s), ys(s))

# Add tangent vector to plot
ax.arrow(x0, y0,  float(t0[0]),  float(t0[1]), label='tangent', color='g')
ax.arrow(x0, y0, -float(t0[0]), -float(t0[1]), color='g')

# Add normal vector to splot
ax.arrow(x0, y0,  float(n0[0]),  float(n0[1]), label='normal', color='r')

# Show plot
plt.show()"
"sample = np.random.normal(5, 4, 100)
sample_std = np.std(sample)
sample_mean = np.mean(sample)


print(""Sample standard deviation (found via np.std): %s"" % str(sample_std))
print(""Sample mean (found via np.mean): %s"" % str(sample_mean))"
"result = minimize(nll, [4,1], args=(sample))
mle_std = result[""x""][0]
mle_mean = result[""x""][1]

print(""Sample standard deviation (found via MLE): %s"" % str(mle_std))
print(""Sample mean (found via MLE): %s"" % str(mle_mean))"
"result = minimize(nll, [3,1,2], args=(x_matrix,y_array))
standard_error_mle = result.x[0]
beta_mle = result.x[1:]
print(""Standard error calculated with MLE: %s"" % str(standard_error_mle))
print(""Beta calculated with MLE: %s"" % str(beta_mle))
"
"beta_ols = np.linalg.inv(x_matrix.T * x_matrix) * (x_matrix.T * y_array)
print(""Beta calculated with OLS: %s"" % str(beta_ols))"
"error_ols = y_array - (x_matrix*beta_ols)
standard_error_ols = np.std(error_ols)
print(""Standard error calculated with OLS: %s"" % str(standard_error_ols))"
"y_pred = knn.predict(X_test)
print('Actual & Predicted y values')
print(np.vstack([y_test, y_pred]).T)
print('\n')

knn_accuracy_score = accuracy_score(y_test, y_pred)
print('Accuracy score: {}'.format(knn_accuracy_score))
print('\n')

print('Confusion Matrix')
print(confusion_matrix(y_test, y_pred))"
"sklearn_knn = KNeighborsClassifier(n_neighbors=5)
sklearn_knn.fit(X_train, y_train)
sklearn_y_pred = sklearn_knn.predict(X_test)

print('Actual & Predicted y values')
print(np.vstack([y_test, sklearn_y_pred]).T)
print('\n')

sklearn_knn_accuracy_score = accuracy_score(y_test, sklearn_y_pred)
print('Accuracy score: {}'.format(sklearn_knn_accuracy_score))
print('\n')

print('Confusion Matrix')
print(confusion_matrix(y_test, sklearn_y_pred))"
"eigval_a, eigvec_a=np.linalg.eig(a)
eigval_a, eigvec_a"
(eigvec_a[0]*eigvec_a[0].transpose())
(eigvec_a[1]*eigvec_a[1].transpose())
(eigvec_a[1]*eigvec_a[0].transpose())
(eigvec_a[0]*eigvec_a[1].transpose())
data
arr2.dtype
a
b
a1
c
e
f
arr_float
arr
arr*arr
arr-arr
1/arr
arr**0.5
data
names == 'Bob'
data[names == 'Bob']
"data[names == 'Bob', 2:]"
"data[names == 'Bob', 2]"
data[names != 'Bob']
data[~(names == 'Bob')]
data[(names == 'Bob') | (names == 'Will')]
data
data
arr
arr
"arr[[4, 3, 2, 5]]"
"arr[[-3, -5, -7]]"
np.sqrt(arr)
np.exp(arr)
"np.maximum(x, y)"
"arr = np.random.randn(7)*5
arr"
np.modf(arr)
np.floor(arr)
np.ceil(arr)
np.rint(arr)
np.isnan(arr)
"plot_tour(capital_cities)
plot_tour(east_cities)"
"tours = []
numtours = 30
for i in range(numtours):
    tour = east_cities.copy()
    random.shuffle(tour)
    tours.append(tour)
def plotone(i=0):
    tour = tours[i]
    plot_tour(tour)
    plt.title('Distance {d}'.format(d=tour_dist(tour)))
interact(plotone,i=(0,numtours-1))"
"tours = []
numtours = 30
for i in range(numtours):
    tour = capital_cities.copy()
    random.shuffle(tour)
    tours.append(tour)
def plotone(i=0):
    tour = tours[i]
    plot_tour(tour)
    plt.title('Distance {d}'.format(d=tour_dist(tour)))
interact(plotone,i=(0,numtours-1))"
"tour = east_cities.copy()
numtrials = 20000
results = anneal(tour,numtrials,temp=linear_temp)
def vis(i=0):
    fig = plt.figure(figsize=(10,5))
    plt.subplot(1,2,1)
    plot_tour(results[i][0])
    plt.subplot(1,2,2)
    plt.plot([r[1] for r in results])
    plt.plot([i], results[i][1], 'ro')
interact(vis,i=(0,numtrials-1))"
"tour = capital_cities.copy()
numtrials = 20000
results = anneal(tour,numtrials,temp=one_over_x_temp)
def vis(i=0):
    fig = plt.figure(figsize=(10,5))
    plt.subplot(1,2,1)
    plot_tour(results[i][0])
    plt.subplot(1,2,2)
    plt.plot([r[1] for r in results])
    plt.plot([i], results[i][1], 'ro')
interact(vis,i=(0,numtrials-1))"
"tour = capital_cities.copy()
numtrials = 20000
results = anneal(tour,numtrials,temp=linear_temp)
def vis(i=0):
    fig = plt.figure(figsize=(10,5))
    plt.subplot(1,2,1)
    plot_tour(results[i][0])
    plt.subplot(1,2,2)
    plt.plot([r[1] for r in results])
    plt.plot([i], results[i][1], 'ro')
interact(vis,i=(0,numtrials-1))"
"tour = capital_cities.copy()
numtrials = 40000
results = anneal(tour,numtrials,temp=combo_temp)
def vis(i=0):
    fig = plt.figure(figsize=(10,5))
    plt.subplot(1,2,1)
    plot_tour(results[i][0])
    plt.subplot(1,2,2)
    plt.plot([r[1] for r in results])
    plt.plot([i], results[i][1], 'ro')
interact(vis,i=(0,numtrials-1))"
%timeit string[::-1]
"%timeit """".join(list(reversed(string)))"
%timeit rev_concatenation(string)
%timeit rev_preappend(string)
%timeit rev_recrusion(string)
"# view quick statistics
df.describe()"
"# create a frequency count of the sites
dist = df['site'].value_counts()
dist.head(10)"
"# set style options (optional step)
plt.style.use('ggplot')

# create a bar graph to depict the frequencies
dist.plot(kind='bar', figsize=(14,6));"
"# plot only those that are seen more than once
dist[dist > 1].plot(kind='bar')"
"#Ahora, para pintar nuestra función, usaremos matplotlib a la manera habitual

#Primero crearemos un array 1D de unos 200 elementos donde almacenaremos los posibles valores del cociente de masas

cociente_masas = np.linspace(1,40, 200)

#El mínimo cociente es 1, es decir, la masa inicial y final es la misma, no se ha consumido combustible.
#El máximo cociente que he usado es 40, suponiendo que el peso del combustible es el 97,5% del peso total inicial de la nave

delta_v_adim = eq_cohete_adim(cociente_masas)

#Y pintamos al gusto


plt.figure(figsize=(12, 6))
plt.xlabel('$m_0/m_1$',fontsize=20)
plt.ylabel('$\Delta v /v_e$',fontsize=20)
plt.title ('$\Delta v /v_e  = f(m_0/m_1)$',fontsize=20)
plt.grid()
plt.plot(cociente_masas,delta_v_adim)"
"#Ahora, para pintar nuestra función, usaremos matplotlib a la manera habitual

#Esta vez, nuestra variable independiente va a ser el índice de carga de pago.
#Sus valores máximo y mínimo serán, lógicamente, 0 y 1

mu = np.linspace(0,1, 200)

#Ahora vamos a pintar 3 líneas para 3 valores del índice estructural
#Hemos visto que para el Ariane 5, es 0,13, así que este será uno de los que usemos.
#Pintaremos también uno con sigma = 0,2, un lanzador algo peor que el Ariane
#El otro valor será 0,08, un valor excepcionalmente bajo, que representaría un lanzador de calidad y eficacia inigualable


plt.figure(figsize=(12, 6))
plt.xlabel('$\mu$',fontsize=20)
plt.ylabel('$\Delta v /v_e$',fontsize=20)
plt.title ('$\Delta v /v_e  = f(\sigma,\mu)$',fontsize=20)
plt.grid()
plt.ylim(0,3)

plt.rc('font', size = 18)
plt.plot(mu,eq_cohete_adim_masa(0.2, mu),label='$\sigma = 0.2$')
plt.plot(mu,eq_cohete_adim_masa(0.13, mu),label='$\sigma = 0.13$')
plt.plot(mu,eq_cohete_adim_masa(0.08, mu),label='$\sigma = 0.08$')
plt.plot([0.0128, 0.0128], [0, 3],'k--', label='$\mu Ariane$')
plt.legend()"
"#Calculemos ahora el delta V del cohete!

#Primera Fase:
st1_sigma = 0.0439
st1_mu = 0.2264
st1_ve = 2.58
st1_dv_adim = eq_cohete_adim_masa(st1_sigma, st1_mu)
st1_dv = st1_dv_adim * st1_ve

#Segunda Fase:
st2_sigma = 0.0600
st2_mu = 0.2570
st2_ve = 4.13
st2_dv_adim = eq_cohete_adim_masa(st2_sigma, st2_mu)
st2_dv = st2_dv_adim * st2_ve

#Tercera Fase:
st3_sigma = 0.0787
st3_mu = 0.2832
st3_ve = 4.13
st3_dv_adim = eq_cohete_adim_masa(st3_sigma, st3_mu)
st3_dv = st3_dv_adim * st3_ve

total_dv = st1_dv + st2_dv + st3_dv

print(  'Etapa 1: ',st1_dv,
      '\nEtapa 2: ', st2_dv, '\nEtapa 3: ', st3_dv, '\nTotal  :', total_dv)"
"#Primera Fase, rendimiento en vacío:
st1_ve_vac = 2.98
st1_dv_vac = st1_dv_adim * st1_ve_vac
print(  'Etapa 1, nivel del mar:', st1_dv,
      '\nEtapa 1, en el vacío  :', st1_dv_vac,
      '\nDiferencia            :', st1_dv_vac - st1_dv)"
"pintar_cohete(13, 48.6, 421.4, 73.18, 0.763, 0.107)"
"v = interactive(pintar_cohete, 
               delta_v=(1.0,20.0, 1),
               m_pl = (1, 100, 1),
               isp = (250, 450, 10),
               t_w_ratio_motor = (40, 180, 10),
               t_w_ratio_total = (0.5, 5, 0.25),
               structural_ratio = (0.04, 0.12, 0.01))
display(v)"
"fig, axes = plt.subplots(2, 2, sharex='col', sharey='row')
axes[1, 1].axis('off')
ax_3d = fig.add_subplot(224, projection='3d')
ax_3d.set_aspect('equal')
ax_3d.set_adjustable('box-forced')

for ax in axes.ravel():
    ax.set_aspect('equal')
    ### This makes things worst
    #ax.set_adjustable('box-forced')

data = np.random.normal(scale=0.2, size=(3, 100)).cumsum(axis=1)
# put some anisotropy along z to ease orientation
data[2, :] /= 3. 

axes[0, 0].plot(data[0, :], data[1, :]) #x, y
axes[0, 1].plot(data[2, :], data[1, :]) #z, y
axes[1, 0].plot(data[0, :], data[2, :]) #x, z

ax_3d.plot(data[0, :], data[1, :], data[2, :])
#ax_3d.bbox = ax_3d.bbox.shrunk(0.8, 0.8)

"
"import warnings
warnings.filterwarnings('ignore')
%pylab inline
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from IPython.html.widgets import interact, interactive, fixed
import ToomreGalaxy as ToomreGalaxy
a = interact(ToomreGalaxy.Make_Plot_stars,results = fixed(np.load('Toomre_A.npy')), M = fixed(1.0e11), S = fixed(1.0e11), t = (0.1,20.1), dt = fixed(0.0075))
"
"import matplotlib.pyplot as plt
%matplotlib inline
fig, ax = plt.subplots(1, 1, figsize=(8, 6))
plt.plot(SGs,cap,'ro', Label='Table 12N Values')
plt.plot(x,y, label='Linear Regression Fit')
plt.plot(x_proj,y_proj, 'b', linestyle=':',label='Linear Regression Projection')
plt.plot(x_fit,y_fit, 'bo', fillstyle='none', Label='Linear Fit Regression Projection')
plt.plot(x_intr,y_intr,'g*',fillstyle='none', Label='Linear Extrapolation Projection')

plt.xlabel('SG Values')
plt.ylabel('16d Common Nail Capacity')
plt.title('SG vs. 16d Nail Capacity for 1-1/2 Side Member (12N)\nWhite Oak (SG = 0.73) Extrapolation')
plt.legend(loc='upper left', shadow=True)"
"import warnings
warnings.filterwarnings('ignore')
import warnings
warnings.filterwarnings('ignore')

#Below is inline matplotlib
%matplotlib inline

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from sklearn import linear_model
from sklearn.preprocessing import PolynomialFeatures
x = pd.read_csv('../data/LogisticRegression/ex5Logx.dat', header=None, names=['x1', 'x2'])
y = pd.read_csv('../data/LogisticRegression/ex5Logy.dat', header=None, names=['y'])
xy = pd.concat([x, y], axis=1)
logistic = linear_model.LogisticRegression(C=100000) # The larger the C, the less regularization.
poly = PolynomialFeatures(6) # Polynomial feature to overfit the data
logistic.fit(poly.fit_transform(x), y)

pos = xy[xy['y']==1]
neg = xy[xy['y']==0]

ax = pos.plot.scatter(x='x1', y='x2', marker='+', label='y=1')
neg.plot.scatter(x='x1', y='x2', color='yellow', marker='o', label='y=0', ax=ax)

x1c = np.linspace(-1.0, 1.2, 200)
x2c = np.linspace(-1.0, 1.2, 200)
z = np.zeros((len(x1c), len(x2c)))
for i in range(len(x1c)):
    for j in range(len(x2c)):
        z[i,j] = logistic.predict(poly.fit_transform([[x1c[i], x2c[j]]]))[0]

plt.contour(x1c, x2c, np.transpose(z), levels=[0], color='green', label='Decision boundary')"
"fig = plt.figure()
ax = plt.gca()
ax.set_yscale('log')
plt.plot(lengths, error)
plt.title('Transfer Matrix method error as a function of length')
plt.xlabel('Length')
plt.ylabel('error')"
"# generate potential
x = np.linspace(-3,3,L)
y = np.linspace(-4,4,N)
X, Y = np.meshgrid(x,y)
pot = np.tanh(Y**2-X**2)+1+mu

# plot the potential
fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
plt.xlabel('x')
plt.ylabel('y')
p = ax.plot_surface(X, Y, pot)
plt.show()"
"fig, ax = plt.subplots()
plot = ax.matshow(pot)
title = ax.set_title(""Crank-Nicholson method"")
ax.set_xlabel(r'$x$')
ax.set_ylabel(r'$y$')
plt.show()"
"en = 0.5
L = 200
N = 40
V = smooth_potential(en, L, xx=1, yy=1, h=.6, plot=True)"
"N = 40 # number of transverse lattice points
L = 200 # length of the scattering region

G = []

energies = np.linspace(.3, 1, 50)
for en in energies:
    V = smooth_potential(en, L, xx=1, yy=1, h=.6, plot=False)
    G.append(solve(en, V, L, en, opt = True)[0])
    
plt.plot(energies, G)
plt.title('Quantized Conductance of a quantum point contact (QPC)')
plt.xlabel('energy [t]')
plt.ylabel('conductance [e^2/h]')
plt.show()"
"G2 = []
for en in energies:
    V = smooth_potential(en, L, xx=1, yy=1, h=0, plot=False)
    G2.append(solve(en, V, L, en, opt = True)[0])

plt.title('Quantized Conductance of a quantum point contact (QPC) for different heigts of potential')
plt.xlabel('energy [t]')
plt.plot(energies, G, energies, G2)
plt.show()"
"from scipy.optimize import curve_fit
N = 20
G = []
lengths = np.arange(300, 1000, 20)
mu = 0.1
for L in lengths:
    V = np.random.rand(N,L)
    G.append(solve(mu, V, L, L, opt = False)[0])

def func(x, a, b, c):
    return a * np.exp(-b * x) + c

popt, pcov = curve_fit(func, lengths, G)

plt.figure()

plt.plot(lengths, G, 'ko', label=""Original Noised Data"")
plt.plot(lengths, func(lengths, *popt), 'r-', label=""Fitted Curve"")
plt.xlabel(""length [L]"")
plt.ylabel(""conductance [e^2/h]"")
plt.legend()
plt.show()"
"%matplotlib nbagg
plt.plot([1,2,3,4,5,8,7,8])
"
"%matplotlib nbagg
plt.plot([1,2,3,4,5,8,7,8])
"
"phi, c = poly_airy(x, y, 4)

phi"
"s11, s22, s12 = airy_stress(phi, x, y)
display(s11, s22, s12)"
"eqlist = conds2eqs(conds, (x, y))
eqlist"
sol
s11.subs(sol)
s12.subs(sol)
s22.subs(sol)
"phi, c = poly_airy(x, y, 3)

phi"
"conds = [s22.subs(y, h/2),
         s12.subs(y, h/2),
         s22.subs(y, -h/2),
         s12.subs(y, -h/2),
         s11.subs(x, L/2) - S*y,
         s12.subs(x, L/2),
         s11.subs(x, -L/2) - S*y,
         s12.subs(x, -L/2)]

conds"
"eqlist = conds2eqs(conds)

eqlist"
sol
s11.subs(sol)
s12.subs(sol)
s22.subs(sol)
"phi, d = poly_airy(x, y, 5)

phi"
"s11, s22, s12 = airy_stress(phi, x, y)
display(s11, s22, s12)"
"conds = [s22.subs(y, h/2) + q,
         s12.subs(y, h/2),
         s22.subs(y, -h/2),
         s12.subs(y, -h/2),
         integrate(s11.subs(x, L/2), (y,-h/2, h/2)),
         integrate(s12.subs(x, L/2), (y,-h/2, h/2)) - q*L/2,
         integrate(y*s11.subs(x, L/2), (y,-h/2, h/2)),
         diff(phi, x, 4) + diff(phi, y, 4) + 2*diff(phi, x, 2, y, 2)]
conds"
"eqlist = conds2eqs(conds)

eqlist"
sol
factor(s11.subs(sol))
factor(s12.subs(sol))
factor(s22.subs(sol))
"phi, d = poly_airy(x, y, 6)

phi"
"s11, s22, s12 = airy_stress(phi, x, y)
display(s11, s22, s12)"
"conds = [s22.subs(y, h/2) + (x + L/2)*q/L,
         s12.subs(y, h/2),
         s22.subs(y, -h/2),
         s12.subs(y, -h/2),
         integrate(s11.subs(x, L/2), (y,-h/2, h/2)),
         integrate(s12.subs(x, L/2), (y,-h/2, h/2)) - q*L/2,
         integrate(y*s11.subs(x, L/2), (y,-h/2, h/2)),
         diff(phi, x, 4) + diff(phi, y, 4) + 2*diff(phi, x, 2, y, 2)]
conds"
"eqlist = conds2eqs(conds)

eqlist"
sol
factor(s11.subs(sol))
factor(s12.subs(sol))
factor(s22.subs(sol))
"phi, d = poly_airy(x, y, 5)

phi"
"s11, s22, s12 = airy_stress(phi, x, y)
display(s11, s22, s12)"
"conds = [s22.subs(y, h/2) + q,
         s12.subs(y, h/2),
         s22.subs(y, -h/2),
         s12.subs(y, -h/2),
         integrate(s11.subs(x, 0), (y,-h/2, h/2)),
         integrate(s12.subs(x, 0), (y,-h/2, h/2)) + q*L,
         integrate(y*s11.subs(x, 0), (y,-h/2, h/2)) - q*L**2/2,
         diff(phi, x, 4) + diff(phi, y, 4) + 2*diff(phi, x, 2, y, 2)]
conds"
"eqlist = conds2eqs(conds)
eqlist"
sol
factor(s11.subs(sol))
factor(s12.subs(sol))
factor(s22.subs(sol))
"r, theta, C, alpha, q = symbols(""r  theta C alpha q"")
phi = C*(r**2*(alpha - theta) + r**2*sin(2*theta)/2 - r**2*cos(theta)**2*tan(alpha))
phi"
"Srr = simplify(1/r**2*diff(phi, theta, 2) + 1/r*diff(phi, r))
Srr"
"Stt = simplify(diff(phi, r, 2))
Stt"
"Srt = -simplify(diff(1/r*diff(phi, theta), r))
Srt"
"sol = solve(Stt.subs(theta, 0) + q, C)
sol"
"Srr2 = Srr.subs(C, sol[0])
Stt2 = Stt.subs(C, sol[0])
Srt2 = Srt.subs(C, sol[0])

display(Srr2)
display(Stt2)
display(Srt2)"
"Srt.subs(theta, 0)"
"trigsimp(Stt.subs(theta, alpha))"
"simplify((Srt.subs(theta, alpha)).rewrite(sin))"
"S_cart = simplify(Q.T *  S_polar * Q)
S_cart"
"from IPython.display import IFrame
IFrame('http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.morphology.distance_transform_edt.html',
    width='100%', height=400)"
"a = np.array(([0,1,1,1,1],
                  [0,0,1,1,1],
                  [0,1,1,1,1],
                  [0,1,1,1,0],
                  [0,1,1,0,0]))
dist, ind = distance_transform_edt(a, sampling=[2, 0.11], return_indices=True)
dist"
ind
"n = 200
a = np.random.randint(low=0, high=2, size=(n,n,n))
%timeit dist = distance_transform_edt(a, sampling=[2.001, 0.11, 0.73])"
"a = np.random.rand(n,n,n)
a[a < 0.5] = 0
a[a >= 0.5] = 1
%timeit dist = distance_transform_edt(a, sampling=[2.001, 0.11, 0.73])"
"a = np.random.rand(n,n,n)
a[a < 0.5] = 0
a[a >= 0.5] = 1
%timeit dist, ind = distance_transform_edt(a, sampling=[2.001, 0.11, 0.73], return_indices=True)"
"# simple shear first
dot(PS, SS)"
"# pure shear first
dot(SS, PS)"
"matrix_power(PSi, 10)"
"matrix_power(SSi, 10)"
orientation(F)
"plot(nrange, PSar, label='pure shear')
plot(nrange, SSar, label='simple shear')
plt.legend(loc=2)"
"plot(nrange, ang)"
"V = la.sqrtm(B)
print(V)
def_show(V)"
"U = la.sqrtm(C)
print(U)
def_show(U)"
"R, V = la.polar(F, 'left')
print(V)
def_show(V)"
"R, U = la.polar(F, 'right')
print(U)
def_show(U)"
"gammas = linspace(0, 10, 50)[1:]
thetas = []
for gamma in gammas:
    F = array([[1, gamma],[0, 1]])
    B = dot(F, F.T)
    e,v = eig(B)
    x, y = v[:, e.argmax()]
    thetas.append(degrees(arctan2(y, x)))
plot(gammas, thetas)
xlabel('gamma')
ylabel('theta');"
"gammas = linspace(0, 10, 1000)[1:]
ars = []
for gamma in gammas:
    F = array([[1, gamma],[0, 1]])
    B = dot(F, F.T)
    e,v = eig(B)
    ars.append(sqrt(max(e)/min(e)))
plot(gammas, ars)
xlabel('gamma')
ylabel('AR');"
"S = array([[10, 0], [0, 5]])
tau = []
sn = []

for theta in pi*uniform(size=5000):
    n = array([cos(theta), sin(theta)])
    sv = dot(S, n)
    sn.append(dot(sv, n))
    tau.append(norm(sv-n*dot(sv, n)))

plot(sn, tau, 'k.')
axis('equal')
margins(x=0.1, y=0.1)
show()"
"S = array([[5, 0, 0], [0, 9, 0], [0, 0, 15]])
tau = []
sn = []

for i in range(5000):
    n = rand_vec()
    sv = dot(S, n)
    sn.append(dot(sv, n))
    tau.append(norm(sv-n*dot(sv, n)))

plot(sn, tau, 'k.')
axis('equal')
margins(x=0.1, y=0.1)
show()
"
"# parametric definition of unit circle
theta = linspace(0, 2*pi, 300)
Xc, Yc = cos(theta), sin(theta)
plot(Xc, Yc, 'g')

# Apply deformation gradient and plot ellipse
F = array([[2, 0], [0, 0.5]])
xe, ye = dot(F, [Xc, Yc])
plot(xe, ye, 'r')
axis('equal');"
"# coordinates of square
Xs = [1, -1, -1, 1, 1]
Ys = [1, 1, -1, -1, 1]
plot(Xs, Ys, 'g')

# Apply deformation gradient and plot result
F = array([[2, 0], [0, 0.5]])
xn, yn = dot(F, [Xs, Ys])
plot(xn, yn, 'r')
axis('equal');"
"# create rectangular grid
X, Y = meshgrid(linspace(-2.2, 2.2, 21), linspace(-1.9, 1.9, 17))

# Apply deformation gradient. As [X, Y] is 3D array, we need
# special function to treat dot product properly. tensordot
# can do it.
x, y = tensordot(F, [X, Y], axes=1)

# plot displacement vectors on all point
quiver(X, Y, x-X, y-Y, angles='xy')
plot(Xc, Yc, 'g', xe, ye, 'r')
plot(Xs, Ys, 'g', xn, yn, 'r')
axis('equal');"
"# calculate displacements
J = F - eye(2)
u, v = tensordot(J, [X, Y], axes=1)

# plot
quiver(X, Y, u, v, angles='xy')
plot(Xc, Yc, 'g', xe, ye, 'r')
plot(Xs, Ys, 'g', xn, yn, 'r')
axis('equal');"
"# Deformation gradient
F = array([[0.5, 1],
           [0  , 2]])
def_field(F)
def_ellipse(F)"
"# Displacement gradient
J = array([[1,    1],
           [0, -0.5]])
dis_field(J)
dis_ellipse(J)"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import Image
Image('pics/formuli.png', embed=True)"
"from math import *
input_tree = [1,2,3,4,5,None, None, 2,3,None, 4, None, None, None, None, None, 19]
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
def create_tree(input_tree):
    if len(input_tree)==0:
        return None
    levels = int(ceil(log(len(input_tree),2)))
    
    for level in range(1, levels+1):
        print(input_tree[int(pow(2,max(0, level-1))-1): int(pow(2,max(0, level))-1)])
        
create_tree(input_tree)"
"
"
"#Plot the posterior for all three strains
p= np.linspace(0, 1, 300)

#make plots
strains= ['WT', 'ASH', 'AVA']

for strain in strains:
    n_r, n= revs_trials(df, strain)
    plt.plot(p, np.exp(log_posterior(n_r, n, p)), '-')
    
#prettify
plt.margins(y = 0.02)
plt.xlabel('prob of reversal, $p$')
plt.ylabel(r'$P(p\mid n_r, n, I)$')"
"#generate plot
gamma= np.linspace(0, 2, 200)
delta= np.linspace(-1, 1, 200)

#make coordinate for contour plot
dd, gg= np.meshgrid(delta, gamma)

#compute probabilities
n_r_ash, n_ash= revs_trials(df, 'ASH')
n_r_ava, n_ava= revs_trials(df, 'AVA')

post= posterior_delta_gamma(delta, gamma, n_r_ash, n_ash, n_r_ava, n_ava)

#plot the contour
plt.contourf(dd, gg, post, cmap= plt.cm.Blues, alpha= 0.7)
plt.contourf(dd, gg, post, cmap=plt.cm.Blues, alpha=0.7)
plt.xlabel(r'$\delta = p_\mathrm{AVA} - p_\mathrm{ASH}$', fontsize=24)
plt.ylabel(r'$\gamma = p_\mathrm{AVA} + p_\mathrm{ASH}$', fontsize=24)
plt.xlim((0.4, 0.9))
plt.ylim((0.9, 1.4))
plt.axes().set_aspect('equal', adjustable='box')
"
"# Integrate over gamma
post_delta = np.trapz(post, x=gamma, axis=0)

# Plot the distribution of delta 
plt.plot(delta, post_delta, '-')
plt.xlabel(r'$\delta = p_\mathrm{AVA} - p_\mathrm{ASH}$')
plt.ylabel(r'$P(\delta \mid D, I)$')
plt.margins(y=0.02)
"
"# Generate gamma and delta for the plot
gamma = np.linspace(0, 2, 200)
delta = np.linspace(-1, 1, 200)

# Make coordinates for contour plots
dd, gg = np.meshgrid(delta, gamma)

# Compute probability
n_r_ash, n_ash = revs_trials(df, 'WT')
n_r_ava, n_ava = revs_trials(df, 'ASH')
post = posterior_delta_gamma(delta, gamma, n_r_ash, n_ash, n_r_ava, n_ava)

# Integrate over gamma
post_delta = np.trapz(post, x=gamma, axis=0)

# Plot the distribution of delta 
plt.plot(delta, post_delta, '-')
plt.xlabel(r'$\delta = p_\mathrm{ASH} - p_\mathrm{WT}$')
plt.ylabel(r'$P(\delta \mid D, I)$')
plt.margins(y=0.02)
"
"# Generate gamma and delta for the plot
gamma = np.linspace(0, 2, 200)
delta = np.linspace(-1, 1, 200)

# Make coordinates for contour plots
dd, gg = np.meshgrid(delta, gamma)

# Compute probability
n_r_ash, n_ash = revs_trials(df, 'WT')
n_r_ava, n_ava = revs_trials(df, 'AVA')
post = posterior_delta_gamma(delta, gamma, n_r_ash, n_ash, n_r_ava, n_ava)

# Integrate over gamma
post_delta = np.trapz(post, x=gamma, axis=0)

# Plot the distribution of delta 
plt.plot(delta, post_delta, '-')
plt.xlabel(r'$\delta = p_\mathrm{AVA} - p_\mathrm{WT}$')
plt.ylabel(r'$P(\delta \mid D, I)$')
plt.margins(y=0.02)
"
"plot(t, x, 'b', label='Numeric')
plot(ta, x, 'g.', label='Analytic')
ylim(tc, 0)
legend()
xlabel('x')
ylabel('Teplota')
title('Tok na povrchu {:.2f} mW/m2'.format(1000 * k * (t[1] - t[0]) / dx));"
tshow(m)
tshow(m)
"plot(time, hf)
xlabel('Time [Ma]')
ylabel('Surface heatflow [mW/m2]')"
"plot(ti, x)
ylim(tc, 0);"
"plot(ti, x)
ylim(tc, 0);"
"t = ti
res = []
tt = []
total_time = 0
plot(ti ,x)
for j in range(10):
    for i in range(100):
        t = A.dot(t) + b
        res.append(t)
        total_time += dt
        tt.append(total_time/(365.25*24*3600))
    plot(t, x)
ylim(tc, 0);
res = asarray(res)"
"plot(tt, res[:,31])
xlabel('Time [years]')
ylabel('Temperature')"
"plot(t, x, 'b', label='Numeric')
plot(ta, x, 'g.', label='Analytic')
ylim(tc, 0)
legend()
xlabel('x')
ylabel('Teplota')
title('Tok na povrchu {:.2f} mW/m2'.format(1000 * k * (t[1] - t[0]) / dx));"
"plot(-1000*qset, qs)
xlabel('Mantle heat flow [mW/m2]')
ylabel('Surface heat flow [mW/m2]');"
"for iteration in range(20):
    prediction = input.dot(weights)
    error = (prediction - goal_prediction) ** 2
    delta = prediction - goal_prediction
    weights = weights - (alpha * (input * delta))
    
    print(""Error:"" + str(error) + "" Prediction:"" + str(prediction))"
"for iteration in range(40):
    error_for_all_lights = 0
    for row_index in range(len(walk_vs_stop)):
        input = streetlights[row_index]
        goal_prediction = walk_vs_stop[row_index]
        prediction = input.dot(weights)
        error = (goal_prediction - prediction) ** 2
        error_for_all_lights += error
        delta = prediction - goal_prediction
        weights = weights - (alpha * (input * delta))
        print(""Prediction:"" + str(prediction))

    print(""Error:"" + str(error_for_all_lights) + ""\n"")"
"plt.imshow(chelsea)
#plt.axis('off')"
img
chelsea
"img_adapteq = img_as_float(skie.equalize_adapthist(img, clip_limit=0.03))"
"@interact(hist_type=list(hist_types.keys()))
def display_result(hist_type):
    result = hist_types[hist_type]

    # We display the processed grayscale image on the left.
    plt.subplot(121)
    plt.imshow(result, cmap='gray')
    plt.axis('off')

    # We display the histogram on the right.
    plt.subplot(122)
    plt.hist(result.ravel(), bins=np.linspace(0., 1., 256),
             histtype='step', color='black')

    plt.show()"
"def asset_profile1(ca0):
    
    A = np.zeros(61)

    cb0 = ca0
    Q0 = 3*ca0
    A_pre = 0
    for t in range(60):
        A_next = (1 + r)*A_pre + Y[t].sum() - (ca0 + cb0 + Q0)*((1 + r)*beta)**t
        A_pre = A_next

        A[t+1] = A_next
    
    return A

def term_cond1(ca0):
    
    return abs(asset_profile1(ca0)[-1])

rslt = minimize(term_cond1, x0=1000, method='Nelder-Mead')
print(rslt.success, rslt.x[0])
plt.plot(range(1, 62), asset_profile1(rslt.x[0]))"
"def asset_profile2(theta, ca0):
    
    A = np.zeros(61)
    
    cb0 = (1-theta)*ca0/(2*theta)
    Q0 = 3*ca0/(2*theta)
    A_pre = 0
    for t in range(60):
        A_next = (1 + r)*A_pre + Y[t].sum() - (ca0 + cb0 + Q0)*((1 + r)*beta)**t
        A_pre = A_next

        A[t+1] = A_next
    
    return A

def term_cond2(theta, ca0):
    
    return abs(asset_profile2(theta, ca0)[-1])

thetas = [0.3, 0.5, 0.7]
A = pd.DataFrame(columns=thetas)

for theta in thetas:
    
    eval_term_cond = functools.partial(term_cond2, theta)
    
    rslt = minimize(eval_term_cond, x0=1000, method='Nelder-Mead')
    print(rslt.success, rslt.x[0])
    A[theta] = asset_profile2(theta, rslt.x[0])
    
A.index = range(1, 62)
A.plot(xlim=[0, 61], ylim=[0, 2000000])"
"P_K = P_K.astype('int')
A_K = asset_grid[P_K]

# Setting dead households to missing
A_K[S == 3] = np.nan

# Taking averages, skipping missing households
A_avg = np.nanmean(A_K, axis = 1)

# Plotting average wealth over lifecycle for living households
%matplotlib inline

import matplotlib.pyplot as plt
plt.plot(range(20, T+20), A_avg)"
"interact(factorit, n=(2,40));"
"t, x_t = solve_lorenz(angle=10, N=10)"
"w = interactive(solve_lorenz, angle=(0.,360.), N=(0,50), σ=(0.0,50.0), ρ=(0.0,50.0))
display(w)"
w.kwargs
xyz_avg.shape
"plt.hist(xyz_avg[:,0])
plt.title('Average $x(t)$')"
"plt.hist(xyz_avg[:,1])
plt.title('Average $y(t)$')"
"# load the data
iris = datasets.load_iris()

print(iris.keys())"
"print(iris.feature_names)
# only print the first 10 samples
print(iris.data[:10])
print('We have %d data samples with %d features'%(iris.data.shape[0], iris.data.shape[1]))"
print(iris.DESCR)
"print(digits.data)
print('The targets are:')
print(digits.target_names)"
"## plot the first 64 samples, and get a sense of the data
fig = plt.figure(figsize = (8,8))
fig.subplots_adjust(left=0, right=1, bottom=0, top=1, hspace=0.05, wspace=0.05)
for i in range(64):
    ax = fig.add_subplot(8, 8, i+1, xticks=[], yticks=[])
    ax.imshow(digits.images[i],cmap=plt.cm.binary,interpolation='nearest')
    ax.text(0, 7, str(digits.target[i]))"
"boston = datasets.load_boston()
print(boston.DESCR)"
boston.feature_names
"# let's just plot the average number of rooms per dwelling with the price
plt.figure(figsize = (10,8))
plt.plot(boston.data[:,5], boston.target, 'o')
plt.xlabel('Number of rooms')
plt.ylabel('Price (thousands)')"
print(model)
"plt.figure(figsize = (10,8))
plt.plot(x,y,'o')"
"plt.figure(figsize = (10,8))
plt.plot(x,y_noise,'o')"
"# The input data for sklearn is 2D: (samples == 10 x features == 1)
X = x[:, np.newaxis]
print(X)
print(y_noise)"
"# model fitting is via the fit function
model.fit(X, y_noise)"
"# underscore at the end indicates a fit parameter
print(model.coef_)
print(model.intercept_)"
"plt.figure(figsize = (10,8))
plt.plot(x,y_noise,'o')
plt.plot(x,predicted, label = 'Prediction')
plt.legend()"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""OO8Jfs9uZnc"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""hKCqske0rAE"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""BTRssTnhZVU"")"
"import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt

nx.draw_circular(simple_relation, with_labels=True, directed = True)
plt.show()"
nx.transitive_closure(simple_relation)
"tc = nx.transitive_closure(simple_relation)
tc.edges()"
"nx.draw_circular(tc, with_labels=True, directed = True)
plt.show()"
"# What this does, is list all the edges in the edge list for ""tc"" 
# as long as the edge was not in the edge list for simple_relation. 

[edge for edge in tc.edges() if edge not in simple_relation.edges()]"
"import warnings
warnings.filterwarnings('ignore')
import networkx as nx
import matplotlib.pyplot as plt

# Converting the list of pairs to actual networkX digraphs: 

divides_relation = nx.DiGraph(divides)
next_to_relation = nx.DiGraph(next_to)
leq_relation = nx.DiGraph(less_than_eq)
slt_relation = nx.DiGraph(strict_less_than)

# Put these into a list: 
examples = [divides_relation, next_to_relation, leq_relation, slt_relation]

# Look at the dictionaries: 
for r in examples:
    print(nx.to_dict_of_lists(r))"
"nx.draw_circular(divides_relation, with_labels=True)
plt.show()"
"nx.draw_circular(next_to_relation, with_labels=True)
plt.show()"
"nx.draw_circular(slt_relation, with_labels=True)
plt.show()"
"not_symmetric = [(1,2), (2,1), (1,3), (3,1), (2,4), (4,2), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10)]
not_symmetric_relation = nx.DiGraph(not_symmetric)
nx.draw_circular(not_symmetric_relation, with_labels=True)
plt.show()"
"nx.draw_circular(divides_relation, with_labels=True)
plt.show()"
"nx.draw_circular(next_to_relation, with_labels=True)
plt.show()"
"nx.draw_circular(leq_relation, with_labels=True)
plt.show()"
"nx.draw_circular(slt_relation, with_labels=True)
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""YyLaRffCdk4"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""rcJTZXZJVUs"")"
"import warnings
warnings.filterwarnings('ignore')
import warnings
warnings.filterwarnings('ignore')
import networkx as nx
import matplotlib.pyplot as plt

U = [2,3,4,6,8,9,12]

# Add (x,y) to the edge list if x divides y
poset_edges = [(x,y) for x in U for y in U if y % x == 0]

poset = nx.DiGraph(poset_edges)
nx.draw(poset, with_labels=True)
plt.show()
"
"from IPython.display import YouTubeVideo
from datetime import timedelta
start=int(timedelta(minutes=9, seconds=55).total_seconds())
YouTubeVideo(""R36F8CWAi2k"", start=start)"
"import warnings
warnings.filterwarnings('ignore')
import warnings
warnings.filterwarnings('ignore')
import networkx as nx
import matplotlib.pyplot as plt

t = nx.random_powerlaw_tree(8)

nx.draw(t)
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import warnings
warnings.filterwarnings('ignore')

import networkx as nx
import matplotlib.pyplot as plt

chapsnat_edges = [('Ronald', 'Scott'), ('Ronald', 'Trish'), ('Scott', 'Uriah'), ('Scott', 'Trish'), 
                  ('Uriah', 'Ronald'), ('Uriah', 'Scott'), ('Uriah', 'Trish'), ('Uriah', 'Victoria'), 
                  ('Victoria', 'Uriah'), ('Victoria', 'Scott')]

chapsnat = nx.DiGraph(chapsnat_edges)
nx.draw_circular(chapsnat, with_labels = True, node_size = 2500)
plt.show()"
"bsquared = [('Ronald', 'Uriah'), ('Ronald', 'Trish'), 
 ('Scott', 'Ronald'), ('Scott', 'Scott'), ('Scott', 'Trish'), ('Scott', 'Victoria'), 
 ('Uriah', 'Scott'), ('Uriah', 'Trish'), ('Uriah', 'Uriah'), 
 ('Victoria', 'Ronald'), ('Victoria', 'Scott'), ('Victoria', 'Trish'), ('Victoria', 'Victoria'), ('Victoria', 'Uriah')]

bsquaredgraph = nx.DiGraph(bsquared)
nx.draw_circular(bsquaredgraph, with_labels = True, node_size = 1000)
plt.show()"
"from IPython.display import YouTubeVideo
YouTubeVideo(""G7rGep_v-EM"")"
"# Let's first set up the edge list for our relation. 

chapsnat_edges = [('Ronald', 'Scott'), ('Ronald', 'Trish'), ('Scott', 'Uriah'), ('Scott', 'Trish'), 
                  ('Uriah', 'Ronald'), ('Uriah', 'Scott'), ('Uriah', 'Trish'), ('Uriah', 'Victoria'), 
                  ('Victoria', 'Uriah'), ('Victoria', 'Scott')]

# Here's how to tell networkX you have a directed graph.
# It's exactly the same process as undirected graphs except you use DiGraph intead of Graph. 

chapsnat = nx.DiGraph(chapsnat_edges)

# Once we have this defined, we can visualize using Matplotlib: 

nx.draw_circular(chapsnat, with_labels = True, node_size = 2000)
plt.show()"
nx.to_dict_of_lists(chapsnat)
chapsnat.edges()
print(nx.adjacency_matrix(chapsnat))
"g = nx.Graph({0: [1, 3, 4, 5, 6, 7],
 1: [0, 3, 4, 5, 6, 7],
 2: [3, 5, 6, 7],
 3: [0, 1, 2, 4, 6],
 4: [0, 1, 3, 5, 7],
 5: [0, 1, 2, 4, 6, 7],
 6: [0, 1, 2, 3, 5, 7],
 7: [0, 1, 2, 4, 5, 6]})

nx.draw_circular(g, with_labels=True)
plt.show()"
nx.coloring.greedy_color(g)
"# This is the default greedy algorithm -- the strategy does not 
# actually need to be stated. 
nx.coloring.greedy_color(g, strategy=nx.coloring.strategy_largest_first)"
"# This one randomly selects vertices one at a time and builds a 
# proper coloring. Notice the result is different here. 
nx.coloring.greedy_color(g, strategy=nx.coloring.strategy_random_sequential)"
"nx.coloring.greedy_color(g, strategy=nx.coloring.strategy_connected_sequential)"
"nx.coloring.greedy_color(g, strategy=nx.coloring.strategy_independent_set)"
"nx.coloring.greedy_color(g, strategy=nx.coloring.strategy_smallest_last)"
"nx.coloring.greedy_color(g, strategy=nx.coloring.strategy_random_sequential)"
"# First let's remind ourselves what the graph looked like

nx.draw_circular(g, with_labels=True)
plt.show()"
"# And the coloring: 

nx.coloring.greedy_color(g)"
"# The color classes are {0,2}, {1}, {3,5}, {4,6}, and {7}. 
# Here is some code that will assign those red, blue, yellow, green, and purple. 

# Specify the layout; in this case ""circular"" 
pos = nx.circular_layout(g)

# Now draw just the nodes, one color class at a time. 
# Here we have to specify the layout (`pos`) and the list of nodes. 
nx.draw_networkx_nodes(g, pos, nodelist=[0,2], node_color='red')
nx.draw_networkx_nodes(g, pos, nodelist=[1], node_color='blue')
nx.draw_networkx_nodes(g, pos, nodelist=[3,5], node_color='yellow')
nx.draw_networkx_nodes(g, pos, nodelist=[4,6], node_color='green')
nx.draw_networkx_nodes(g, pos, nodelist=[7], node_color='purple')

# Now draw the edges and labels: 
nx.draw_networkx_edges(g, pos)
nx.draw_networkx_labels(g, pos)

# Turn off the axes: 
plt.axis('off')

# Then plot the whole thing: 
plt.show()"
"# Specify the layout; in this case with a ""random"" layout.
pos = nx.random_layout(k44)

# Now draw just the nodes, one color class at a time. 
# Here we have to specify the layout (`pos`) and the list of nodes. 
nx.draw_networkx_nodes(k44, pos, nodelist=[0,1,2,3], node_color='red')
nx.draw_networkx_nodes(k44, pos, nodelist=[4,5,6,7], node_color='blue')

# Now draw the edges and labels: 
nx.draw_networkx_edges(k44, pos)
nx.draw_networkx_labels(k44, pos)

# Turn off the axes: 
plt.axis('off')

# Then plot the whole thing: 
plt.show()"
"# For MTH 325 students: Using Python to visualize graphs...

# Jupyter has access to the huge collection of Python libraries that are available: 
import networkx as nx
import matplotlib.pyplot as plt

# Let's plot the complete graph on 20 vertices: 
k20 = nx.complete_graph(20)  
nx.draw(k20, pos = nx.circular_layout(k20), edge_color=""red"", 
        node_color=""cyan"", with_labels = True)
plt.show()"
"from IPython.display import YouTubeVideo
YouTubeVideo(""T4WXs6niloU"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""tz4UwhQs0Z8"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""woEVRMADIck"")"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""aNQV45Wichw"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""txdmCgThR6o"")"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""n-bJB_7QbQU"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""ML-g2xLYruE"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""6O1s3_GsSHo"")"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""4c6Bg2GJvQw"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""GvOBBcnIjlw"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""Rwm-NW9Y5iM"")"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""OO8Jfs9uZnc"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""hKCqske0rAE"")"
"from IPython.display import YouTubeVideo
YouTubeVideo(""BTRssTnhZVU"")"
"import warnings
warnings.filterwarnings('ignore')
from IPython.display import YouTubeVideo
YouTubeVideo(""Z9sYIWHIvNc"")"
"fig = plt.figure()
ax = fig.add_subplot(1,1,1)

ax.scatter(diamondData.carats, diamondData.price)
   # draw linear regression line
x = [0.1,0.4]
y = [-259.6 + 3721 * i for i in x] 
ax.plot(x, y)
   # alternatively, plot the fitted values
#y_hat = simpleModel.fittedvalues
#ax.plot(diamondData.carats, y_hat)
   # pretty-up the plot
fig.suptitle(""Relation between diamonds' price and weight"")
ax.set_ylabel('Price [SIN $]')
ax.set_xlabel('Weight [carat]')
ax.grid(True)"
simpleModel.params[0] + 0.2*simpleModel.params[1]
simpleModel.predict(newDiamond)
simpleModel.predict(newDiamonds)
max (abs (y - y_hat))
max(abs(residuals))
"fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.plot(simpleModel.fittedvalues, residuals, 'o') # as round marks

   # pretty-up the plot
ax.plot ((0, 1200), (0,0)) # draw also a line at y=0
fig.suptitle(""Residuals versus fitted prices"")
ax.set_ylabel('Residuals [SIN $]')
ax.set_xlabel('Price [SIN $]')
ax.grid(True)"
sum(residuals)
np.mean(residuals)
plt.hist(residuals)
"sm.qqplot(residuals, fit=True, line = '45')"
"n = len(y)
MSE = sum(residuals**2) / (n-2)
RMSE = np.sqrt(MSE)
RMSE"
max(simpleModel.resid / RMSE)
simpleModel.rsquared
"fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.plot(simpleModel.fittedvalues, diamondData.price, 'o') # as round marks
   # identity line
plt.plot(simpleModel.fittedvalues, simpleModel.fittedvalues, '--') 
   # pretty-up the plot
fig.suptitle(""Relation between estimated and actual diamonds' prices"")
ax.set_ylabel('Estimated Price [SIN $]')
ax.set_xlabel('Actual Price [SIN $]')
ax.grid(True)"
1 - (1-simpleModel.rsquared)*((n-1)/simpleModel.df_resid)
simpleModel.rsquared_adj
"  # calculate standard error for beta1
seBeta1 = sigma / np.sqrt(ssx)
seBeta1"
"tBeta1 = beta1 / seBeta1
tBeta1"
"print (""##            Estimate     Std. Error    t-value        p-value"")
print (""Intercept: "", beta0, seBeta0, tBeta0, pBeta0)
print (""Carats:     "", beta1, seBeta1, tBeta1, pBeta1)"
[beta1 + i*t_value*seBeta1 for i in limits]
"fig, ax = plt.subplots()
ax.plot(x,y, 'o', label=""data"")
ax.plot(x, simpleModel.fittedvalues, 'g-', label=""OLS"")

ax.plot(x, interval_u, 'c--', label = ""Intervals"")
ax.plot(x, interval_l, 'c--')
   # pretty-up the plot
fig.suptitle(""OLS Linear Regression with confidence intervals"")
ax.set_ylabel('Predicted Price [SIN $]')
ax.set_xlabel('Weight [Carat]')
ax.grid(True)
ax.legend(loc='best')"
simpleModel.summary()
dir(simpleModel)
"df = pd.DataFrame(scale(iris.data), columns=iris.feature_names)
df.head()"
"pca = PCA(n_components=4)
pca.fit(df)
var = pca.explained_variance_ratio_.cumsum()
var"
plot(var)
pca.fit(d)
"var = pca.explained_variance_ratio_.cumsum()
var"
plot(var)
"import warnings
warnings.filterwarnings('ignore')
%matplotlib inline
from IPython.display import Image
Image(filename='figures/exp_setup.png', width = 240)"
"Image(filename='figures/fit_W.png', width = 240)"
"Image(filename='figures/fit_RH.png', width = 240)"
"plt.figure(figsize=(8, 8))

# Question A
plt.subplot(4, 1, 1)
a, b = 4, 4
prior = beta(a, b)
posterior = update_beta(prior, N=1, z=1)
prior_posterior_plot(prior, posterior, text='First flip, head')

# Question B
plt.subplot(4, 1, 2)
prior = posterior
posterior = update_beta(prior, N=1, z=1)
prior_posterior_plot(prior, posterior, text='Second flip, head again')

# Question C
plt.subplot(4, 1, 3)
prior = posterior
posterior = update_beta(prior, N=1, z=0)
prior_posterior_plot(prior, posterior, text='3rd flip, tail')

# Question D
plt.subplot(4, 1, 4)
a, b = 4, 4
prior = beta(a, b)
posterior = update_beta(prior, N=3, z=2)
prior_posterior_plot(prior, posterior, text='3 flips, different order (THH)')

plt.legend(loc='best');"
"plt.figure(figsize=(8, 5))

# Question A
plt.subplot(2, 1, 1)
a, b = 1, 1
prior = beta(a, b)
posterior = update_beta(prior, N=100, z=58)
prior_posterior_plot(prior, posterior, hdi_tails=distribution_hdi(posterior),
                     text='From uniform to 100 flips,\n58 heads')

# Question B
plt.subplot(2, 1, 2)
prior = posterior
posterior = update_beta(prior, N=100, z=57)
prior_posterior_plot(prior, posterior, hdi_tails=distribution_hdi(posterior),
                     text='Additional 100 flips,\n57 heads')

plt.legend(loc='best');"
"a = b = 1
prior = beta(a, b)
posterior = update_beta(prior, 50, 40)
text = '''
Prior: a = b = 1 (uniform)
50 participants, 40 choose F
'''.strip()
prior_posterior_plot(prior, posterior, text=text,
                     hdi_tails=distribution_hdi(posterior))

plt.legend(loc='best');"
"a = b = 1
prior = beta(a, b)
posterior = update_beta(prior, 50, 15)
text = '''
Prior: a = b = 1 (uniform)
50 participants, 15 choose F
'''.strip()
prior_posterior_plot(prior, posterior, text=text,
                     hdi_tails=distribution_hdi(posterior))

plt.legend(loc='best');"
"a = b = 0.1
prior = beta(a, b)
posterior = update_beta(prior, N=5, z=4)
text = '''
Prior: a = b = .1
5 flips, 4 heads
'''.strip()
prior_posterior_plot(prior, posterior, text=text)

plt.legend(loc='best');"
"plt.figure(figsize=(8, 5))

# Question A
plt.subplot(2, 1, 1)
a = b = 50  # Strong prior belief that the coin is fair
prior = beta(a, b)
posterior = update_beta(prior, N=10, z=9)
text = '''Update strong prior with
controversial data.
Prior: a = b = 50
N = 10, z = 9
'''.strip()
prior_posterior_plot(prior, posterior, text=text)
plt.legend(loc=2)

# Question B
plt.subplot(2, 1, 2)
a = b = .1  # Strong prior belief that the coin is unfair
prior = beta(a, b)
posterior = update_beta(prior, N=10, z=9)
text = '''Different prior, same data.
Prior: a = b = .1
N = 10, z = 9
'''.strip()
prior_posterior_plot(prior, posterior, text=text)"
"N = 500
p_head = .8

coin_flips = np.random.rand(N) < p_head
running_avarage = np.cumsum(coin_flips) / (np.arange(N) + 1)
print('End proportion: {}'.format(running_avarage[-1]))

# Plot
plt.title('Running proportion of heads')
plt.gca().set(xscale='log')
plt.plot(running_avarage)
plt.ylim(0, 1.1)
plt.xlabel('Flip number')
plt.ylabel('Proportion heads')
# Plot proportion line
plt.plot((0, N), (p_head, p_head), linestyle='dashed');"
"dx = 0.01
x = np.arange(0, 1, dx)
plt.plot(x, p(x))
plt.xlabel('$x$')
plt.ylabel('$y = 6x(1 - x)$')
plt.title('Probability density function');"
"plt.plot(base, norm_pdf(base))
plt.fill_between(x, 0, norm_pdf(x), alpha=0.3)
plt.title('Normal distribution probability density function')
plt.xticks([-1, 0, 1], [""$\mu - alpha$"", ""$\mu$"", ""$\mu + alpha$""])
plt.yticks([], []);"
"x = np.linspace(-3, 3, 100)
y = x ** 3

plt.plot(x, y)
plt.xlabel('$x$')
plt.ylabel('$y = x ^ 3$')
plt.title('Qubic function');"
"import warnings
warnings.filterwarnings('ignore')
%pylab inline
from urllib.request import urlopen
import datetime
import numpy as np
import matplotlib
matplotlib.rcParams['font.size'] = 15
from matplotlib import pyplot as plt

stableURL = 'https://raw.githubusercontent.com/jradavenport/aas225-gender/master/data.csv'
raw = urlopen(stableURL).read().splitlines()

num = []
time = []
sid = []
speaker = []
qs = []
comments = []

for i in range(len(raw)):
    splitline = str(raw[i]).split(';')[0].split(',')
    splitline = [j for j in splitline if j != ' ' and j != '']
    
    # If all columns filled and there is only one entry (M, F) for speaker gender:
    if len(splitline) >= 5 and len(splitline[3]) == 1 and ('M' in splitline[4].upper() or 'F' in splitline[4].upper()):
        iscleansid = splitline[2].replace('.', '').isdigit()
        if iscleansid:
            # Fix sid if necessary
            if len(splitline[2]) != 6:
                splitsid = splitline[2].split('.')
                splitline[2] = '.'.join([splitsid[0], splitsid[1].zfill(2)])
            
            # If this talk ID has not been added:
            if splitline[2] not in sid:
                num.append(splitline[0])
                time.append(splitline[1])
                sid.append(splitline[2])
                speaker.append(splitline[3].upper())
                qs.append(splitline[4].upper())
                comments.append(','.join(splitline[5:]))
            
            # If this talk ID has been added already:
            if splitline[2] in sid:
                # Check if the number of questions in new entry is longer. 
                # If so, replace earlier entry with the longer one.
                if len(qs[sid.index(splitline[2])]) < len(splitline[4].upper()):
                    replaceindex = sid.index(splitline[2])
                    num[replaceindex] = splitline[0]
                    time[replaceindex] = splitline[1]
                    sid[replaceindex] = splitline[2]
                    speaker[replaceindex] = splitline[3].upper()
                    qs[replaceindex] = splitline[4].upper()
                    comments[replaceindex] = ','.join(splitline[5:])"
"def annotateformat(number):
    if number < 1:
        return '%.2f' % number
    else: 
        return '%d' % number

def nicehist(axis, female, male, title):
    axis.bar([0, 1], [female, male], color='k', width=0.5)
    axis.set_xticklabels(['Female', 'Male'])
    axis.set_xticks([0.25, 1.25])
    axis.set_xlim([-0.2, 1.7])
    
    axis.annotate(annotateformat(female), xy=(0.25, female), va='bottom', ha='center')
    axis.annotate(annotateformat(male), xy=(1.25, male), va='bottom', ha='center')
    axis.set_title(title)    
    axis.spines['right'].set_color('none')
    axis.spines['top'].set_color('none')
    axis.xaxis.set_ticks_position('bottom')
    axis.yaxis.set_ticks_position('left')

Nfemalespeakers = len([i for i in speaker if i == 'F'])
Nmalespeakers = len([i for i in speaker if i == 'M'])

fig, ax = plt.subplots(1)
nicehist(ax, Nfemalespeakers, Nmalespeakers, 
         'Gender of Speakers ({0} Total)'.format(Nfemalespeakers+Nmalespeakers))
plt.show()

print('Male speakers/All speakers= {0:.1f}%'
      .format(100*float(Nmalespeakers)/(Nfemalespeakers + Nmalespeakers)))
print('Female speakers/All speakers = {0:.1f}%'
      .format(100*float(Nfemalespeakers)/(Nfemalespeakers + Nmalespeakers)))"
"allqs = ''.join([i for i in qs if 'M' in i or 'F' in i])
Nfemaleqs = len([i for i in allqs if i == 'F'])
Nmaleqs = len([i for i in allqs if i == 'M'])
    
fig, ax = plt.subplots(1)
nicehist(ax, Nfemaleqs, Nmaleqs, 'Gender of Question-Askers (%d Total)' % (Nfemaleqs+Nmaleqs))

print('Male qs/All qs = {0:.1f}%'.format((100*float(Nmaleqs)/(Nfemaleqs + Nmaleqs))))
print('Female qs/All qs = {0:.1f}%'.format((100*float(Nfemaleqs)/(Nfemaleqs + Nmaleqs))))"
"fig, ax = plt.subplots(1)
Nbins = 7

ax.hist([len(i) for i in qs], Nbins, histtype='stepfilled', color='w', lw=2)
ax.set_title('Number of Questions Per Talk:')
ax.set_xlabel('Number of Questions')
plt.show()

malespeaker_Nqs = [len(qs[i]) for i in range(len(num)) if speaker[i] == 'M']
femalespeaker_Nqs = [len(qs[i]) for i in range(len(num)) if speaker[i] == 'F']

fig, ax = plt.subplots(1)
ax.hist(malespeaker_Nqs, Nbins, histtype='step', color='b', lw=2, label='Male Speaker', range=[1,8])
ax.hist(femalespeaker_Nqs, Nbins, histtype='step', color='r', lw=2, label='Female Speaker', range=[1,8])
ax.set_title('Number of Questions Per Talk:')
ax.set_xlabel('Number of Questions')
ax.legend()
plt.show()"
"Nmalesfirst = len([i for i in qs if i[0] == 'M'])
Nfemalesfirst = len([i for i in qs if i[0] == 'F'])

fig, ax = plt.subplots(1)
nicehist(ax, Nfemalesfirst, Nmalesfirst, 
         'Gender of First Question-Askers ({0} Total)'.format(Nfemalesfirst+Nmalesfirst))
plt.show()



print('Male first qs/All qs = {0:.1f}%'.format((100*float(Nmalesfirst)/(Nfemalesfirst + Nmalesfirst))))
print('Female first qs/All qs = {0:.1f}%'.format((100*float(Nfemalesfirst)/(Nfemalesfirst + Nmalesfirst))))"
"malesfirst = [i for i in qs if i[0] == 'M']
malesfirst_percentagefemaleafter = [float(i.count('F'))/len(i) for i in malesfirst[1:] \
                                    if len(i) >= 2]

femalesfirst = [i for i in qs if i[0] == 'F']
femalesfirst_percentagefemaleafter = [float(i.count('F'))/len(i) for i in femalesfirst[1:] 
                                      if len(i) >= 2]

fig, ax = plt.subplots(1, 2, figsize=(16,8))
Nbins = 5

ax[0].hist(malesfirst_percentagefemaleafter, Nbins, color='k', 
           range=[0,1], histtype='step', lw=2, 
           weights=len(malesfirst_percentagefemaleafter)*[1./len(malesfirst_percentagefemaleafter)])
ax[0].set_title('Male Asks First Question')

ax[1].hist(femalesfirst_percentagefemaleafter, Nbins, color='k', 
           range=[0,1], histtype='step', lw=2,
           weights=len(femalesfirst_percentagefemaleafter)*[1./len(femalesfirst_percentagefemaleafter)])

ax[1].set_title('Female Asks First Question')

for axes in ax:
    axes.set_xlim([0, 1])
    axes.set_xlabel(""Fraction subsequent Q's asked by females"")
    axes.set_ylabel(""Fraction of all talks"")
    axes.set_ylim([0, 1])
plt.show()"
"fig, ax = plt.subplots(1, figsize=(10,8))
Nbins = 5
ax.hist(malesfirst_percentagefemaleafter, Nbins, color='b', 
           range=[0,1], histtype='step', lw=3, 
           weights=len(malesfirst_percentagefemaleafter)*[1./len(malesfirst_percentagefemaleafter)],
           label='Male Asks First Question')

ax.hist(femalesfirst_percentagefemaleafter, Nbins, color='r', 
           range=[0,1], histtype='step', lw=3,
           weights=len(femalesfirst_percentagefemaleafter)*[1./len(femalesfirst_percentagefemaleafter)],
           label='Female Asks First Question')

ax.set_xlim([0, 1])
ax.set_ylim([0, 1])
ax.set_xlabel(""Fraction subsequent Q's asked by females"")
ax.set_ylabel(""Fraction of all talks"")
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.yaxis.set_ticks_position('left')
ax.legend()
plt.show()"
"malesfirst_lenafter = float(len(''.join(malesfirst)))
malesfirst_Nfemaleafter = sum([i.count('F') for i in malesfirst[1:]
                                    if len(i) >= 2])/malesfirst_lenafter
femalesfirst_lenafter = float(len(''.join(femalesfirst)))
femalesfirst_Nfemaleafter = sum([i.count('F') for i in femalesfirst[1:]
                                      if len(i) >= 2])/femalesfirst_lenafter

fig, ax = plt.subplots(1, 2, figsize=(16,8))

nicehist(ax[0], malesfirst_Nfemaleafter, 1-malesfirst_Nfemaleafter,
         'Male Asks First Q ({0} Total)'.format(len(''.join(malesfirst))))

nicehist(ax[1], femalesfirst_Nfemaleafter, 1-femalesfirst_Nfemaleafter,
         'Female Asks First Q (%d Total)'.format(len(''.join(femalesfirst))))

for axes in ax:
    axes.set_ylim([0,1])

plt.show()"
"malespeaker_qs = [qs[i] for i in range(len(num)) if speaker[i] == 'M']
femalespeaker_qs = [qs[i] for i in range(len(num)) if speaker[i] == 'F']

malespeaker_Nfemaleqs = ''.join(malespeaker_qs).count('F')
malespeaker_Nquestions = len(''.join(malespeaker_qs))
malespeaker_percentagefemaleqs = malespeaker_Nfemaleqs/float(malespeaker_Nquestions)

femalespeaker_Nfemaleqs = ''.join(femalespeaker_qs).count('F')
femalespeaker_Nquestions = len(''.join(femalespeaker_qs))
femalespeaker_percentagefemaleqs = femalespeaker_Nfemaleqs/float(femalespeaker_Nquestions)

fig, ax = plt.subplots(1, 2, figsize=(16,8))

nicehist(ax[0], malespeaker_percentagefemaleqs, 1-malespeaker_percentagefemaleqs, 
         'Male Speaker ({0} Total)'.format(malespeaker_Nquestions))

nicehist(ax[1], femalespeaker_percentagefemaleqs, 1-femalespeaker_percentagefemaleqs,
          'Female Speaker ({0} Total)'.format(femalespeaker_Nquestions))
for axes in ax:
    axes.set_xlabel(""Fraction Q's asked"")
    axes.set_ylim([0,1])


plt.show()"
"def getfirstindex(searchstring, letter):
    if letter in searchstring:
        return searchstring.index(letter) + 1
    return None
    
malespeaker_orderfemale = [getfirstindex(i, ""F"") for i in malespeaker_qs if 'F' in i]
femalespeaker_orderfemale = [getfirstindex(i, ""F"") for i in femalespeaker_qs if 'F' in i]

fig, ax = plt.subplots(1, figsize=(10,8))
Nbins = 3
ax.hist(malespeaker_orderfemale, Nbins, color='b', 
           range=[1,3], histtype='step', lw=3, 
           label='Male Speaker')

ax.hist(femalespeaker_orderfemale, Nbins, color='r', 
           range=[1,3], histtype='step', lw=3,
           label='Female Speaker')

ax.set_xlim([1, 3])
ax.set_xticks([1,2,3])
#ax.set_ylim([0, 1])
ax.set_xlabel(""First Female Question Position in Sequence"")
#ax.set_ylabel(""Fraction of all talks"")
ax.set_title('In talks when a female asked a question:')
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')
ax.xaxis.set_ticks_position('bottom')
ax.yaxis.set_ticks_position('left')
ax.legend()
plt.show()"
"N_qs = np.array([len(i) for i in qs])
percentagefemaleqs = np.array([i.count('F')/float(len(i)) for i in qs])
order = np.argsort(N_qs)

#plt.plot(N_qs, percentagefemaleqs, '.')

for i in range(1, max(N_qs)):
    considertalks = i == N_qs
    medianpercentagefemaleqs = np.median(percentagefemaleqs[considertalks])
    stdpercentagefemaleqs = np.std(percentagefemaleqs[considertalks])
    plt.errorbar(i, medianpercentagefemaleqs, yerr=stdpercentagefemaleqs, fmt='o', color='k')
plt.ylim([0, 1.0])
plt.xlabel('Number of questions asked')
plt.ylabel('Fraction of Qs asked by females')
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
%matplotlib inline
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.serif'] = 'Ubuntu'
plt.rcParams['font.monospace'] = 'Ubuntu Mono'
plt.rcParams['font.size'] = 14
plt.rcParams['axes.labelsize'] = 14
plt.rcParams['axes.labelweight'] = 'bold'
plt.rcParams['axes.titlesize'] = 14
plt.rcParams['xtick.labelsize'] = 12
plt.rcParams['ytick.labelsize'] = 12
plt.rcParams['legend.fontsize'] = 14
plt.rcParams['figure.titlesize'] = 18

import c_ve_3param

f = range(0, 600)
ve_params = [(10e3, 2e3, 6666.7, 'Phantom 1'), (15e3, 4e3, 5500, 'Phantom 2'), (20e3, 4e3, 4000, 'Phantom 3')] # G0, Ginf, beta
label_positions = [(450, 2.0, 'Phantom 1'), (375,3.1, 'Phantom 2'), (200, 3.4, 'Phantom 3')]
c140_yoffset = [0.1, 0.1, 0.2]
markers_on = [140]
plt.figure(figsize=(10, 8))
for n, ve in enumerate(ve_params):
    c = c_ve_3param.calc(f, ve[0], ve[1], ve[2])
    h = plt.plot(f, c, '-o', label=ve[3], markevery=markers_on, markersize=12)
    plt.xticks(range(0, 600, 140), range(0, 600, 140))
    plt.xlabel('Frequency (Hz)')
    plt.ylabel('Phase Velocity (m/s)')
    plt.title('c @ 140 Hz annotated on plot')
    c140 = c_ve_3param.calc(140, ve[0], ve[1], ve[2])
    plt.annotate(""%.1f"" % c140, xy=(140, c140), xycoords='data', xytext=(140, c140+c140_yoffset[n]), textcoords='data', color=h[0].get_color())
    plt.text(label_positions[n][0], label_positions[n][1], label_positions[n][2], color=h[0].get_color())"
"from collections import Counter

Counter(message)"
"import warnings
warnings.filterwarnings('ignore')
from scipy.stats import norm
from numpy import linspace
from pylab import plot,show,hist,figure,title

%matplotlib inline

from matplotlib import pyplot as plt
plt.style.use('ggplot')
_ = plt.figure(figsize=(16,8))"
"from scipy.stats import norm,rayleigh

samp = rayleigh.rvs(loc=5,scale=2,size=150) # samples generation

param = rayleigh.fit(samp) # distribution fitting

x = linspace(5,13,100)
# fitted distribution
pdf_fitted = rayleigh.pdf(x,loc=param[0],scale=param[1])
# original distribution
pdf = rayleigh.pdf(x,loc=5,scale=2)

plt.figure(figsize=(16,8))
title('Rayleigh distribution')
plot(x,pdf_fitted,'r-',x,pdf,'b-')
_ = hist(samp,normed=1,alpha=.3,bins=16)"
"# picking 150 of from a normal distrubution
# with mean 0 and standard deviation 1
samp = norm.rvs(loc=0,scale=1,size=150) 

param = norm.fit(samp) # distribution fitting

# now, param[0] and param[1] are the mean and 
# the standard deviation of the fitted distribution
x = linspace(-5,5,100)
# fitted distribution
pdf_fitted = norm.pdf(x,loc=param[0],scale=param[1])
# original distribution
pdf = norm.pdf(x)

plt.figure(figsize=(16,8))
title('Normal distribution')
plot(x,pdf_fitted,'r-',x,pdf,'b-')
_ = hist(samp,normed=1,alpha=.3, bins=16)"
"# probability of symbols
p = np.array( [ .25, .2, .2, .15, .07, .05, .025, .025, .02, .01] )
    
# get codeword lengths by rounding towards 0 and mapping to int
# (type conversion being necessary to use cw_lengths as indices)
cw_lengths = np.ceil( - np.log2( p ) )
cw_lengths = cw_lengths.astype( int )

# show probabilities and codewords lengths
print( 'Probabilities:' )
print( 'p = {}\n'.format( p ) )

print( 'Codeword lengths:' )
print( 'L(x_n) = {}'.format( cw_lengths ) )"
"plt.axis('square');
plt.scatter(complex_noisy_samples.real, complex_noisy_samples.imag, s=6, alpha=0.3)
plt.xlim(-3000, 3000); plt.ylim(-3000, 3000)
plt.xlabel('In-phase component'); plt.ylabel('Quadrature component')
plt.tight_layout()"
"seaborn.jointplot(complex_noisy_samples.real, complex_noisy_samples.imag, kind=""reg"", size=6, joint_kws={""scatter_kws"": {""s"":6, ""alpha"":0.3}})
plt.xlim(-3000, 3000); plt.ylim(-3000, 3000)
plt.xlabel('In-phase component');  plt.ylabel('Quadrature component')"
"t = np.arange(num_samples) * T_S  # vector of sampling time instances
plt.plot(t*1e3, complex_noisy_samples.real, t*1e3, complex_noisy_samples.imag, alpha=0.7)
plt.title(""Time Domain of I an Q components"")
plt.xlabel('Time / ms'); plt.ylabel('Amplitude'); plt.legend(('inphase', 'quadrature'));"
"plt.subplot(121)
plt.acorr(complex_noisy_samples.real, usevlines=True, maxlags=50)
plt.ylabel('$\phi_{\Re\Re}$'); plt.xlabel('lag / Samples'); plt.axis('tight')

plt.subplot(122)
plt.acorr(complex_noisy_samples.imag, usevlines=True, maxlags=50)
plt.ylabel('$\phi_{\Im\Im}$'); plt.xlabel('lag / Samples'); plt.axis('tight');"
"# Plot normalized histogram
plt.hist(complex_noisy_samples.real, bins=40, normed=True, alpha=0.5);
plt.xlabel('Amplitude'); plt.ylabel('Probability')

# Plot normal distribution
x = np.linspace(-3000, 3000, 100)
_ = plt.plot(x,stats.norm.pdf(x,0,sigma))"
"freqs, Pxx = signal.welch(complex_noisy_samples,
                          fs=f_S, nfft=1024, noverlap=0,
                          window=""hanning"", scaling=""density"",
                          return_onesided=False)
freqs = np.fft.fftshift(freqs); Pxx = np.fft.fftshift(Pxx)
# Plot PSD, use logarithmic scale:
plt.plot(freqs / 1000, 10*np.log10(np.abs(Pxx)))
plt.ylim(-70, 10)
plt.ylabel('$\Phi_{XX}(f)$ [dB]'); plt.xlabel('$f$ / kHz');"
"cutoff_freq = 1e5  # cutoff frequency of lowpass filter: 100 kHz
numtaps = 51      # number of filter taps 

# FIR filter design:
lpass_taps = signal.firwin(numtaps, cutoff_freq, nyq=f_nyquist)  #  Get filter taps
freq_norm, response = signal.freqz(lpass_taps) # filter response in frequency domain
freq = freq_norm * f_nyquist / np.pi

# Plot frequency response:
plt.plot(freq / 1e3, 10*np.log10(np.abs(response))) 
plt.title('Frequency response of lowpass filter'); plt.ylabel('$H(f)$ [dB]'); plt.xlabel('$f$ / kHz');"
"# Filter noise with lowpass:
filtered_x = signal.lfilter(lpass_taps, 1.0, complex_noisy_samples)
# Calculate PSD:
freqs, Pxx = signal.welch(filtered_x,
                          nfft=1024, fs=f_S, window=""hanning"", noverlap=0, scaling=""density"", return_onesided=False)
plt.plot(np.fft.fftshift(freqs),
         10*np.log10(np.abs(np.fft.fftshift(Pxx))))
# Plot PSD, use logarithmic scale:
plt.title('PSD of low-pass filtered Gaussian noise');
plt.axis('tight'); plt.ylim(-70, 10); plt.ylabel('$P_{XX}(f)$'); plt.xlabel('$f$ / kHz');"
"plt.acorr(filtered_x.real, usevlines=False, maxlags=50, marker=None, linestyle='-')
plt.acorr(filtered_x.imag, usevlines=False, maxlags=50, marker=None, linestyle='-')
plt.xlabel('lag / Samples')
plt.legend(('inphase', 'quadrature'));"
"# Take every 5th element of filtered signal
factor = 5; filt_x_dwnsampled = filtered_x[::factor]
plt.acorr(filt_x_dwnsampled.real, usevlines=False, maxlags=50, marker=None, linestyle='-')
plt.acorr(filt_x_dwnsampled.imag, usevlines=False, maxlags=50, marker=None, linestyle='-')
plt.title('Autocorrelation function of downsampled signal')
plt.xlabel('lag / Samples'); plt.axis('tight'); plt.legend(('inphase', 'quadrature'));"
"freqs, Pxx = signal.welch(filt_x_dwnsampled,
             fs=f_S/factor,nfft=1024, window=""hanning"", noverlap=0, scaling=""density"", return_onesided=False)
# Plot PSD, use logarithmic scale:
plt.plot(np.fft.fftshift(freqs),
         10*np.log10(np.abs(np.fft.fftshift(Pxx))))
plt.axis('tight'); plt.ylim(-70, 10)
plt.ylabel('$P_{XX}$'); plt.xlabel('$f$ / kHz');"
"# Calculate impulse response and frequency response from definition:
for idx,r in enumerate(np.nditer(r_values)):
    # time domain:
    g[idx,:] = np.sinc(t)*np.cos(np.pi*t*r)/(1-np.power(2*r*t,2)) # np.sinc = sin(pi*x)/(pi*x)
    # frequency domain:
    for idx2,myf in enumerate(np.nditer(f)):
        if np.abs(myf) < (1-r)/2:
            G[idx,idx2] = 1
        elif np.abs(myf) < (1+r)/2:
            G[idx,idx2] = 0.5*(1+np.cos(np.pi/r*(np.abs(myf)-(1-r)/2)))
            
# plotting:
plt.subplot(121) # Time domain
plt.plot(np.transpose(t_mat), np.transpose(g), alpha=0.7)
plt.ylim(-0.25, 1.1)
plt.xlabel('t / T'); plt.ylabel('g(t)'); plt.legend(('r=0','r=0.5','r=1.0'))

plt.subplot(122) # Frequency Domain
plt.plot(np.transpose(f_mat), np.transpose(G), alpha=0.7)
plt.ylim(-0.25, 1.1)
plt.xlabel('fT'); plt.ylabel('G(f)'); plt.legend(('r=0','r=0.5','r=1.0'),loc=8);"
"Image('images/ligo-press.png', width='80%')"
"Image(""images/oreilly-socialweb.png"", width=""80%"")"
"Image(""images/p4sp-clipped.png"", width=""60%"")"
"Image(""images/oreilly-beta.png"", width=""80%"")"
"Image(""images/oreilly-oriole.png"", width=""80%"")"
"Image(""images/nature-genetics.png"", width=""80%"")"
"Image(""images/reinhart-rogoff-replication.png"", width=""80%"")"
"Image(""images/python-data-science-handbook.png"")"
"Image(""images/intro-ml-python.png"")"
"df1 = pd.read_csv('data/police_locals.csv')
df1 = df1.replace('**',np.nan)
df1['all'] = df1['all'].astype('float')
df1['white'] = df1['white'].astype('float')
df1['non-white'] = df1['non-white'].astype('float')
df1['black'] = df1['black'].astype('float')
df1['hispanic'] = df1['hispanic'].astype('float')"
"sns.boxplot(x='ethnicity', y='percent', data=df2);"
"from IPython.display import Image
Image('images/538_local_police.png', width=600)"
"Image(""images/nbviewer1.png"", width=""80%"")"
"Image(""images/mybinder.png"", width=""80%"")"
"Image(""images/jupyterhub-admin.png"", width=""80%"")"
"from IPython.display import Image
Image(""images/calpoly_logo.png"", width=400)"
"Image(""images/jupyter_logo.png"", width=400)"
"Image(""images/ipython_logo.png"", width=400)"
"Image(""images/buzzfeed-article.png"", width=""80%"")"
"Image(""images/buzzfeed-repo.png"", width=""80%"")"
"Image(""images/latimes-article.png"", width=""80%"")"
"Image(""images/latimes-repo.png"", width=""80%"")"
Image('images/JupyterBlocksA.png')
Image('images/JupyterBlocksB.png')
Image('images/JupyterBlocksC.png')
Image('images/JupyterBlocksD.png')
"Image(""images/quantopian-research.png"", width=""90%"")"
Image('images/JupyterBlocksE.png')
"Image(""images/ipython_logo.png"", width=400)"
"Image(""images/jupyter_logo.png"", width=400)"
"Image('images/lego-filebrowser.png', width='80%')"
"Image('images/lego-terminal.png', width='80%')"
"Image('images/lego-texteditor.png', width='80%')"
"Image('images/lego-output.png', width='80%')"
bayarea16.isin(['manifold'])
"matchAgency(nyc,emdf)"
"matchAgency(goldenbears,emdf)"
"matchAgency(pilgrims,emdf)"
"raw='./data/it-list.csv'
# raw='/Users/ganesha/Documents/src/dataviz/inc5000/csv_data/it-list.txt'
df = pd.read_csv(raw)
df"
"df[""TAGS""].apply(tagSeries)"
plt.plot(trace2)
"# check filenames of the data we are exploring:
glob.glob('./data/*.xls')"
"# Import the excel file and call it xls_file
xls_file = pd.ExcelFile('./data/Table01—Estimated Revenue 2007 through 2015.xls')
xls_file"
"# Load the xls file's Sheet1 as a dataframe
df = xls_file.parse('Sheet1')
df"
"ds_train_x[[""maxPlayerLevel"", ""numberOfAttemptedLevels""]].hist(bins=10, figsize = (15,5))"
"# different view of histograms
ds_train_x.hist(bins=10, figsize = (20,20), normed=1)"
"# different view of histograms
ds_train_x.hist(bins=10, figsize = (20,20))"
"ds_train_y.hist(bins=10, figsize = (10,10))
#ds_train_y.hist(bins=10, figsize = (10,10), normed=1)"
"clf = clf.fit(X, y)
print (clf.coef_)
print (clf.intercept_)"
"clfSVC = SVC()
clfSVC = clfSVC.fit(X, y)
print ('Intercept_: {0}\n'.format(clfSVC.intercept_))
print (clfSVC)"
"from sklearn.linear_model import LogisticRegression

clfLR = LogisticRegression().fit(X, y)
print ('Intercept_: {0}\n'.format(clfLR.intercept_))
print (clfLR)"
pca.components_  
"print (pca.explained_variance_ratio_)  
print (pca.explained_variance_ratio_.sum())"
"plot_2D(X_pca, iris.target, iris.target_names)"
"np.round(kmeans.cluster_centers_, decimals=2)"
"plot_2D(X_pca, kmeans.labels_, [""c0"", ""c1"", ""c2""])"
"import warnings
warnings.filterwarnings('ignore')
!head -20 /Users/sr320/data-genomic/tentacle/OlyO-v4-transcriptome.fasta"
"!fgrep -c "">"" /Users/sr320/data-genomic/tentacle/OlyO-v4-transcriptome.fasta"
"import warnings
warnings.filterwarnings('ignore')
!head /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/blastout_query.part-01.fasta_sp"
"!cat /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/blastout_*fasta_sp \
> ./data/blastout_sp"
!head /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/error-blastout_query.part-10.fasta_sp
!wc -l ./data/blastout_sp
!wc -l /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/blastout_query.part-01.fasta_sp
"!cat /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/error-*fasta_sp \
> ./data/error_blastout_sp"
!wc -l ./data/error_blastout_sp
"!sed 's/|c/_c/g' ./data/blastout_sp \
> ./data/blastout_sp_rn
!head ./data/blastout_sp_rn"
"!cat /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/blastout_*fasta_nt \
> ./data/blastout_nt"
!wc -l ./data/blastout_nt
"!cat /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/err*fasta_nt \
> ./data/error_blastout_nt"
!wc -l /Users/sr320/Dropbox/hummingbird-ipython-nbs/OlyO-v6/blastout_query.part-10.fasta_nt
"!fgrep ""Bacteria"" ./data/blastout_nt | wc -l"
"plt.figure(1)
plt.subplot(111)
plt.plot(t,a)
plt.title(""Synthetized time history"")
plt.xlabel(""Time [s]"")
plt.ylabel(""Acceleration [g]"")
plt.grid(True)

plt.figure(2)
plt.subplot(211)
plt.plot(f, A, 'rs')
plt.title(""Amplitude and Phase Angle @ frequency"")
plt.ylabel(""Amplitude [g]"")
plt.grid(True)

plt.subplot(212)
plt.plot(f, fi, 'gs')
plt.xlabel(""Frequency [Hz]"")
plt.ylabel(""Phase angle [rad]"")
plt.grid(True)

plt.figure(3)
plt.subplot(111)
plt.semilogy(range(len(f)), f, 'y^')
plt.grid(True)
plt.title('Frequency change by 1/6 octave')
plt.xlabel('step')
plt.ylabel('Frequency [Hz]')"
"import warnings
warnings.filterwarnings('ignore')
#importing all required modules
#important otherwise pop-up window may not work
%matplotlib inline 
import numpy as np
import scipy as sp
import matplotlib as mpl
import matplotlib.pyplot as plt
import math
import cmath
import seaborn"
"#definition of module of current density J (otherwise only real component will be plotted)
modJ = [abs(J[i]) for i in range(0, len(J))]
rJ = [J[i].real for i in range(0, len(J))]
iJ = [J[i].imag for i in range(0, len(J))]

#plot preparation
fig, ax = plt.subplots(2, figsize=(10,10))

ax[0].plot(x*10**3,modJ, label=""|J| [A/mm2]"", color = ""green"")
ax[0].plot(x*10**3,rJ, label=""Re{J} [A/mm2]"", color = ""red"")
ax[0].set_ylabel(""Current density [A/mm2]"")
ax[0].set_xlabel(""Conductor width [mm]"")
ax[0].set_title(""Current density distribution along conductor width"")
#ax.axis([-5, 5, 0.9, 1.3])
ax[0].legend()

ax[1].plot(x*10**3,iJ, label=""Im{J} [A/mm2]"", color = ""blue"")
ax[1].set_ylabel(""Current density [A/mm2]"")
ax[1].set_xlabel(""Conductor width [mm]"")
ax[1].legend()
plt.tight_layout()"
"#Plotting
import seaborn
import matplotlib.pyplot as plt
%matplotlib inline

#conductor height vector
y = np.linspace(0, 100, n)

#plot preparation
fig, ax = plt.subplots(2, figsize=(10,10))

ax[0].plot(y,modJ, label=""|J| [A/mm2]"", color = ""green"")
ax[0].set_ylabel(""Current density [A/mm2]"")
ax[0].set_xlabel(""Conductor height [mm]"")
ax[0].set_title(""Current density distribution along conductor width"")
ax[0].legend()

ax[1].plot(y,phJ, label=""Arg{J} [deg]"", color = ""blue"")
ax[1].set_ylabel(""Current density phase [deg]"")
ax[1].set_xlabel(""Conductor height [mm]"")
ax[1].legend()
plt.tight_layout()"
"Pac, Pdc, k"
"plt.plot(t,ua,t,ub,t,uc)
plt.title(""Three phase voltages"")
plt.xlabel(""Time [s]"")
plt.ylabel(""Voltage [V]"")
plt.axis([0, 0.02, -400, 400])
plt.grid(True)"
"kresl(t, ia, iadc, iau, ""Phase A"")
kresl(t, ib, ibdc, ibu, ""Phase B"")
kresl(t, ic, icdc, icu, ""Phase C"")"
"interact(current, u=(100,400), alpha=(0,phi))"
"p = figure(plot_width=400, plot_height=400)
p.line(t,ia, color=""navy"", line_width=2, legend=""final current"")
p.line(t,iau, color=""red"", line_width=1, legend=""periodic component"")
p.line(t,iadc, color=""green"", line_width=1, legend=""aperiodic component"")
show(p)"
"# after integration vectors t and uc had different lengths so I need to append one item
np.append(uc, uc[999])"
"fig, ax = plt.subplots(nrows=2, ncols=1, figsize=(8,8))

ax[0].plot(t,ia, label=""Current"")
ax[0].set_ylabel(""Current [A]"")
ax[0].set_xlabel(""Time [s]"")
ax[0].set_title(""Current in R-L-C circuit during switch-on"")
ax[0].legend()

ax[1].plot(t,ua, label=""Supply voltage"", color=""green"")
ax[1].plot(t,uc, label=""Capacitor voltage"", color=""orange"")
ax[1].set_ylabel(""Voltage [V]"")
ax[1].set_xlabel(""Time [s]"")
ax[1].set_title(""Supply voltage"")
ax[1].legend()

fig.tight_layout()"
"fig, ax = plt.subplots(nrows=2, ncols=1, figsize=(8,8))

ax[0].plot(t,ib, label=""Current"")
ax[0].set_ylabel(""Current [A]"")
ax[0].set_xlabel(""Time [s]"")
ax[0].set_title(""Current in R-L-C circuit during switch-on"")
ax[0].legend()

ax[1].plot(t,ub, label=""Line voltage"", color=""green"")
ax[1].plot(t,uc2, label=""Capacitor voltage"", color=""orange"")
ax[1].set_ylabel(""Voltage [V]"")
ax[1].set_xlabel(""Time [s]"")
ax[1].set_title(""Supply voltage"")
ax[1].legend()

fig.tight_layout()"
"plt.figure(figsize=(10,5))
plt.plot(t,ia, label=""Current"")
plt.ylabel(""Current [A]"")
plt.xlabel(""Time [s]"")
plt.title(""Current in R-L circuit during switch-on"")
plt.legend();"
"plt.figure(figsize=(10,5))
plt.plot(t, uR, label='R')
plt.plot(t, U, label='supply')
plt.plot(t, uL, label='L')
plt.legend();"
"#half past x
#y past x
#quarter till x
#y till x
hours_eng = {0: ""Midnight"", 1:""one"", 2: ""two"", 3:""three"", 4:""Four"", 5:""Five"", 6:""Six"",
             7:""Seven"", 8:""Eight"", 9:""Nine"",10:""Ten"",11:""Eleven"",12:""Noon""}
min_eng = {1:""One"", 2:""Two"", 3:""Three"", 4:""Four"", 5:""Five"", 6:""Six"", 7:""Seven"", 8:""Eight"", 9:""Nine"", 10:""Ten"",
          11:""Eleven"", 12:""Twolve"", 13:""Thirteen"", 14:""Fourteen"", 15:""Quarter"", 16:""Sixteen"", 17:""Seventeen"", 18:""Eighteen"", 19:""Nineteen"",20:""Twinty"",
          21:""Twinty-one"", 22:""Twinty-two"", 23:""Twinty-three"", 24:""Twinty-four"", 25:""Twinty-five"",
          26:""Twinty-six"", 27:""Twinty-seven"", 28:""Twinty-eight"", 29:""Twinty-nine"", 30:""Half""}

def print_time(time_str):
    time_str = time_str.replace("":"", """")[::-1]
    minu = int(time_str[:2][::-1])
    hour = int(time_str[2:][::-1])
    #print(minu, hour)
    pend = ""past""
    if minu > 30:
        minu = 60 -minu
        hour = ( hour + 1) % 24
        pend = ""till""
    hour = hour % 24
    result = min_eng[minu] + "" "" + pend + "" "" + hours_eng[hour - ((hour-1)//12 == 1) * 12] #noon is not past midnight
    return result
    
print([print_time(str(i)+"":25"") for i in range(24)])"
"g = 9.8

def draw_graph(x, y):
    plot(x, y)
    xlabel('x-coordinate')
    ylabel('y-coordinate')
    title('Projectile motion at different initial velocities and angles')
    
def draw_markers(x,y):
    plot((x),(y),'o',color='y')
    
def frange(start, final, interval):

    numbers = []
    while start < final:
        numbers.append(start)
        start = start + interval
    
    return numbers

def draw_trajectory(u, theta, t_flight, t_time):
    # list of x and y co-ordinates
    x = []
    y = []
    intervals = frange(0, t_flight, 0.001)
    for t in intervals:
        x.append(u*math.cos(theta)*t)
        y.append(u*math.sin(theta)*t - 0.5*g*t*t)

    #create the graph
    draw_graph(x, y)
    time_step = min(int(t_time/0.001), len(intervals)) -1
    draw_markers(x[time_step], y[time_step])

def new_trajectory(v, theta, at_time):
    #num_trajectories = 3
    velocity = v
    angle = math.radians(float(theta))
    
    t_flight = 2*velocity*math.sin(angle)/g
    S_x = velocity*math.cos(angle)*t_flight
    S_y = velocity*math.sin(angle)*(t_flight/2) - (1/2)*g*(t_flight/2)**2
    draw_trajectory(velocity, angle, t_flight, at_time)

    # Add a legend and show the graph
    legends = []

    legends.append('{0} - {1}'.format(velocity, math.degrees(angle)))
    legend(legends)
    xlim(0, 10)
    ylim(0, 10)
    show()
#new_trajectory()
interact(new_trajectory, 
         v=FloatSlider(min=0.1, max=10.0, step=0.5, value=9.0), 
         theta= FloatSlider(min=0.1, max=90.0, step=0.5, value=45.0),
        at_time=FloatSlider(min=0.1, max=2.0, value=2.0))

"
"# horizontal from general dynamics of IPM

z,X0 = 0.8,0.2
th0,r0 = np.arctan2(X0,z),np.sqrt(z**2+X0**2)
x0 = np.array([th0,r0,0.0,0.0]) # x = [th,r,w,rp]

m,g = 50,9.81 # uIPMFreeFallFcn # uIPMConstantLengthFcn # uIPMHorizontalFcn
t = np.linspace(0,0.8,41)
sols = []
for fun in {uIPMFreeFallFcn, uIPMConstantLengthFcn, uIPMHorizontalFcn, uIPMFallFcn}:
    pars = (m,g,fun,(m,g),)
    # odeint solver
    sols.append(odeint(dynGeneralIPM, x0, t, args=(pars,)))

plt.figure(1,figsize=(10,10))
for i,sol in enumerate(sols):
    plt.subplot(2,2,i+1),
    plt.plot(sol[:,1]*np.sin(sol[:,0]),sol[:,1]*np.cos(sol[:,0]),'o-')
    plt.axis('equal'),plt.axis((0,1.8,0.0,1.2))

plt.show()
"
"#
x0s = [[-0.151, 0.467],
       [  -0.2, 0.791],
       [   0.2,-0.791],
       [ 0.151,-0.467]]
z,g = 0.8,9.81
t = np.linspace(0,0.8,41)
pars = (g,z,lambda t: 0)
# odeint solver
plt.figure(1,) #figsize=(5,5)
for i,x0 in enumerate(x0s):
    sol = odeint(dynLIPM, x0, t, args=(pars,))
    E = (x0[1]**2-g/z*x0[0]**2)/2
    if E<0: 
        xrev,vrev = np.sqrt(-2*z*E/g), np.nan
    else: 
        xrev,vrev = np.nan, np.sqrt(2*E)
    print('Energia: {0:.3f}, vtop: {0:.3f}, xrev: {0:.3f}: '.format(E,vrev,xrev))
    plt.subplot(2,2,i+1),plt.plot(t,sol[:,0],'o-')
    plt.title('Energia: {0:.3f}J'.format(E))

plt.show()
"
"#
x0 = [  -0.2, 0.791]
z,g = 0.8,9.81
t = np.linspace(0,3.2,1601)
zmpFcn = lambda t: 0.4*stepFcn(t,0.8)+0.40*stepFcn(t,1.59)+0.305*stepFcn(t,2.4)
pars = (g,z,zmpFcn)
# odeint solver
sol = odeint(dynLIPM, x0, t, args=(pars,))
E = (x0[1]**2-g/z*x0[0]**2)/2
if E<0: 
    xrev,vrev = np.sqrt(-2*z*E/g), np.nan
else: 
    xrev,vrev = np.nan, np.sqrt(2*E)
print('Energia: {0:.3f}, vtop: {0:.3f}, xrev: {0:.3f}: '.format(E,vrev,xrev))
plt.plot(t,sol[:,0]-zmpFcn(t),'o-'),plt.grid('on')
plt.title('Energia: {0:.3f}J'.format(E))

plt.show()
"
"#
# x0 = [  0.00157, 0.0] 
x0 = [  0.0, 0.00546926689437855903172525] 
z,g = 0.8,9.81
dt,tmax = 0.01,7.5
n = int(tmax/dt)+1
t = np.linspace(0,tmax,n)
zmpFcn = lambda t: 0.3*stepFcn(t,1.5)-0.3*stepFcn(t,3.0)+0.3*stepFcn(t,4.5)-0.3*stepFcn(t,6.0)
pars = (g,z,zmpFcn)
# odeint solver
sol = odeint(dynLIPM, x0, t, args=(pars,))
E = (x0[1]**2-g/z*x0[0]**2)/2
if E<0: 
    xrev,vrev = np.sqrt(-2*z*E/g), np.nan
else: 
    xrev,vrev = np.nan, np.sqrt(2*E)
print('Energia: {0:.3f}, vtop: {0:.3f}, xrev: {0:.3f}: '.format(E,vrev,xrev))
plt.plot(t,sol[:,0],'o-',t,zmpFcn(t),'--'),plt.grid('on')
plt.title('Energia: {0:.3f}J'.format(E))
plt.axis((0,7.5,0.0,0.4))

plt.show()
"
"dt, tmax = 0.01, 3.0
n = int(tmax/dt+1)
t = np.linspace(0,tmax,n)
ai = -z/(g*dt**2)
bi = 2*z/(g*dt**2)+1
ci = ai
A = np.zeros((n,n))
for i in range(0,n):
    if i==0:
        A[0,0:2] = [bi,ci]
    elif i==n-1:
        A[n-1,n-2:n] = [ai,bi]
    else:
        A[i,i-1:i+2] = [ai,bi,ci]
        
zmpFcn = lambda t: 0.3*stepFcn(t,1.5)
print(ai,bi,ci)
# posicion
#p = zmpFcn(t)
#p[0] = p[0]-ai*0.3
#p[n-1] = p[n-1]-ci*0.3
# velocidad
p = zmpFcn(t)
p[0] += +ai*(0.0)*dt
p[n-1] += -ci*(0.0)*dt
A[0,0] += ai
A[n-1,n-1] += ci
x_com = scipy.linalg.solve_triangular(A,p)
plt.plot(t,zmpFcn(t),'--',t,x_com,'o-'),plt.grid('on')#
plt.axis([0,3.0,-0.1,0.4])

print(x_com[-1])"
"zc, g = (0.814,9.81)
xc = -0.0
xppc = xc*g/zc
x0 = np.array([xc,0.0,-xppc])
dt,tmax = 0.01,5
n = int(tmax/dt+1)
t = np.linspace(0,tmax,n)

A,B,a,w = (np.array([[0,1,0],[0,0,1],[0,0,0]]),
           np.array([[0,0,1]]).reshape((3,1)),
           [ 1.5],        # times
           [ 0.3])  # step-amplitud
#           [ 1.8, 2.6, 3.4, 4.2, 5.0],        # times
#           [ 0.1,-0.2, 0.2,-0.2, 0.1])  # step-amplitud

kp,kd = 10,40
yOutFcn = lambda x,t,pars: x[0]-pars[0]/pars[1]*x[2] 
pars = (kp,kd,w,a,zc,g,yOutFcn)
uFcn = lambda x,t,pars: \
    pars[0]*(arrayOfStepFcn(t,(pars[2],pars[3])) - pars[6](x,t,(pars[4],pars[5]))) +\
    pars[1]*(0 - x[1])

# odeint solver
sol = odeint(dynCartTable, x0, t, args=((A,B,uFcn,pars),))
y_zmp = sol[:,0]-zc/g*sol[:,2]
y_d = arrayOfStepFcn(t,(w,a))

plt.plot(t,y_d,t,y_zmp,t,sol[:,0])
#plt.grid('on'),plt.axis([0,tmax,-0.1,0.4])
plt.show()"
"# PI-controller
def dynSys(x,t,params):
    A,B,uFcn,pars = params
    xp = np.dot(A,x.reshape((2,1)))+B*uFcn(x,t,pars)
    return xp.reshape((2,))

def dynSysWithIAction(x,t,params):
    A,B,fun,pars = params
    kp,ki,kd = pars
    xp = np.zeros_like(x)
    xsys = x[0:2]
    e = (stepFcn(t)-xsys[0])*stepFcn(t,10)
    xp[0:2] = dynSys(xsys,t,(A,B,fun,(kp,kd)))+np.array([0,ki*x[2]])
    xp[2] = e
    return xp.reshape((3,))

t = np.linspace(0,20,10001)
x0 = np.array([0,0,0])
A,B = np.array([[0,1],[-1,-0.7]]),np.array([0.,1]).reshape((2,1))

fun = lambda x,t,pars: pars[0]*(stepFcn(t,0)-x[0])+pars[1]*(0-x[1])

kp,ki,kd = 10,10,1
pars = (kp,ki,kd)
# odeint solver
sol = odeint(dynSysWithIAction, x0, t, args=((A,B,fun,pars),))

plt.plot(t,sol[:,0]),plt.grid('on')
plt.show()"
"x = linspace(0, 100)
y = 4 * x + 5
plot(x, y, 'r')"
"x = linspace(0, 100)
y = 4 * x 
plot(x, y, 'r')"
"x = linspace(0, 100)
y = x 
plot(x, y, 'r')"
"x = linspace(0, 10)
y1 = 3 * (x ** 2)
y2 = x + 5
y3 = 2 ** x
plot(x, y1, 'r', label='$3n^2$')
plot(x, y2, 'b', label='$n+5$')
plot(x, y3, 'g', label='$2^n$')
legend()"
"x = linspace(0, 20)
yg = x ** 2
yf = 5 * x + 7
plot(x, yg, 'r', label='g(n)')
plot(x, yf, 'b', label='f(n)')
legend()"
"x = linspace(0, 20)
yg = 6 * (x ** 2)
yf = 5 * x + 7
plot(x, yg, 'r', label='g(n)')
plot(x, yf, 'b', label='f(n)')
legend()"
"x = linspace(1, 100)
x_const = linspace(1, 1)

fig, axes = plt.subplots(3, 4, figsize=(18, 10))

axes[0,0].plot(x, x_const)
axes[0,0].set_title(""$O(1)$"")

axes[0,1].plot(x, log(x))
axes[0,1].set_title(""$O(\log n)$"")

axes[0,2].plot(x, log(x) ** 2)
axes[0,2].set_title(""$O((log n)^c)$"")

axes[0,3].plot(x, x)
axes[0,3].set_title(""$O(n)$"")

axes[1,0].plot(x, x * log(x))
axes[1,0].set_title(""$O(n \log n)$"")

axes[1,1].plot(x, x ** 2)
axes[1,1].set_title(""$O(n^2)$"")

axes[1,2].plot(x, x ** 3)
axes[1,2].set_title(""$O(n^3)$"")

axes[1,3].plot(x, x ** 2)
axes[1,3].set_title(""$O(n^c)$"")

axes[2,0].plot(x, scipy.power(2, x))
axes[2,0].set_title(""$O(c ^ n)$"")

axes[2,1].plot(x, scipy.misc.factorial(x))
axes[2,1].set_title(""$O(n!)$"")

axes[2,2].plot(x, scipy.power(x,x))
axes[2,2].set_title(""$O(n^n)$"")"
"# Plotting

# create figure
fig, axes = plt.subplots(2, 1, sharex=True, figsize=(8, 8))

# plot histogram
ax = axes[0]
ax.hist(y, np.arange(-44, 43, 2))
# decorate
ax.set_title('Newcomb\'s measurements')
ax.set_ylabel('count')
ax.set_xlabel('$\mu$')
plt.setp(axes[0].get_xticklabels(), visible=True)

# plot the posterior of mu
ax = axes[1]
ax.plot(t1, pm_mu)
# plot the posterior of mu in the filtered case
ax.plot(t1, pm_mu_pos)
# Plot the currently accepted true value
ax.axvline(33, color='k', linestyle='--')
ax.legend(
    ('posterior of $\mu$',
     'posterior of $\mu$ given $y > 0$',
     '""true value""'),
    loc='upper left'
)
ax.set_title('Normal model')
ax.set_xlabel('$\mu$')
ax.set_yticks(())
# set bottom to zero
ax.set_ylim((0, ax.set_ylim()[1]))

fig.tight_layout()"
"print('Joint and marginal posterior distributions')

# create figure
fig, axes = plt.subplots(
    2, 2,
    figsize=(9, 9),
    gridspec_kw=dict(
        width_ratios=[2, 1],
        height_ratios=[1, 2]
    )
)

# plot the joint distribution
ax = axes[1, 0]
# plot the samples from the joint posterior
samps = ax.scatter(mu, sigma, 5, color=plot_tools.lighten('C2', 0.3))
# plot the contour plot of the exact posterior (c_levels is used to give
# a vector of linearly spaced values at which levels contours are drawn)
c_levels = np.linspace(1e-5, Z.max(), 6)[:-1]
ax.contour(t1, t2, Z, c_levels, colors='C0')
# decorate
ax.set_xlim(tl1)
ax.set_ylim(tl2)
ax.set_xlabel('$\mu$', fontsize='14')
ax.set_ylabel('$\sigma$', fontsize='14')

# plot the marginal of mu
ax = axes[0, 0]
# exact
ax.plot(
    t1,
    pm_mu,
    color=plot_tools.lighten('C1'),
    linewidth=5
)
# empirical
ax.plot(
    t1,
    pk_mu,
    color='k',
    dashes=(5, 7),
    linewidth=1.5
)
# decorate
ax.set_xlim(tl1)
ax.set_yticks(())
ax.set_xticklabels(())

# plot the marginal of sigma
ax = axes[1, 1]
# exact
exact_line, = ax.plot(
    pm_sigma,
    t2,
    color=plot_tools.lighten('C1'),
    linewidth=5
)
# empirical
empirical_line, = ax.plot(
    pk_sigma,
    t2,
    color='k',
    dashes=(5, 7),
    linewidth=1.5
)
# decorate
ax.set_ylim(tl2)
ax.set_xticks(())
ax.set_yticklabels(())

# hide last ax
ax = axes[0, 1]
ax.axis('off')
# make legend there
ax.legend(
    (
        samps,
        plt.Line2D([], [], color='C0'),
        exact_line,
        empirical_line
    ),
    (
        'samples',
        'exact joint contour',
        'exact marginal',
        'empirical marginal'
    ),
    loc='center',
)

fig.tight_layout()"
"# create figure
fig, axes = plt.subplots(
    1, 2,
    figsize=(9, 6),
    gridspec_kw=dict(width_ratios=[2, 1])
)

# plot the joint distribution
ax = axes[0]
# plot the contour plot of the exact posterior (c_levels is used to give
# a vector of linearly spaced values at which levels contours are drawn)
c_levels = np.linspace(1e-5, Z.max(), 6)[:-1]
ax.contour(t1, t2, Z, c_levels, colors='C0')

# plot the first sample
line1, = ax.plot(tl1, [sigma[0], sigma[0]], 'k')
line2, = ax.plot(
    t1,
    sigma[0] + stats.norm.pdf(t1, my, np.sqrt(sigma2[0]/n))*100,
    color='C1',
    linestyle='dashed',
    linewidth=2
)
scat = ax.scatter(mu[0], sigma[0], 40, color='r')

# decorate
ax.set_xlim(tl1)
ax.set_ylim(tl2)
ax.set_xlabel('$\mu$', fontsize=14)
ax.set_ylabel('$\sigma$', fontsize=14)
ax.set_title('joint posterior')
ax.legend(
    (plt.Line2D([], [], color='C0'), line1, line2, scat),
    ('exact contour plot',
     'sample from the marginal of $\\sigma$',
     'conditional distribution of $\\mu$',
     'sample from joint posterior'),
    loc='upper center'
)

# plot the marginal of sigma
ax = axes[1]
ax.plot(pm_sigma, t2)
# decorate
ax.set_ylim(tl2)
ax.set_title('marginal of $\sigma$')
ax.set_xticks(());
ax.set_yticklabels(())

fig.tight_layout()"
"# calculate conditional pdfs for each sample
condpdfs = stats.norm.pdf(t1, my, np.sqrt(sigma2/n)[:,np.newaxis])

# create figure
fig, axes = plt.subplots(2, 1, figsize=(6, 9), sharex=True)

# plot some of them
ax = axes[0]
ax.plot(t1, condpdfs[:25].T, 'C2', alpha=0.25)
ax.set_xlim(tl1)
ylims_from_0 = ax.set_ylim()  # set same y_lims to the next plot
ax.set_title('conditional distribution of $\\mu$ for first 25 samples')
ax.set_yticks(())

# plot their mean
ax = axes[1]
ax.plot(
    t1,
    np.mean(condpdfs, axis=0),
    color=plot_tools.lighten('C1'),
    linewidth=5,
    label='average of sampled conditionals'
)
ax.plot(
    t1,
    pm_mu,
    color='k',
    dashes=(5, 7),
    linewidth=1.5,
    label='exact marginal of $\\mu$'
)
ax.set_yticks(())
ax.set_xlim(tl1)
ax.set_ylim(ylims_from_0)
ax.legend(loc='upper center')

fig.tight_layout()"
"# calculate predictive pdf for the first given mu and sigma sample
ynewdists = stats.norm.pdf(xynew, mu[0], sigma[0])

# create figure
fig, axes = plt.subplots(3, 1, figsize=(6, 12))

# plot the joint distribution
ax = axes[0]
# plot the samples from the joint posterior
samps = ax.scatter(mu, sigma, 5, color=plot_tools.lighten('C2', 0.3))
# plot the contour plot of the exact posterior (c_levels is used to give
# a vector of linearly spaced values at which levels contours are drawn)
c_levels = np.linspace(1e-5, Z.max(), 6)[:-1]
ax.contour(t1, t2, Z, c_levels, colors='C0')
# decorate
ax.set_xlim(tl1)
ax.set_ylim(tl2)
ax.set_xlabel('$\mu$', fontsize=14)
ax.set_ylabel('$\sigma$', fontsize=14)
ax.legend(
    (plt.Line2D([], [], color='C0'), samps),
    ('exact joint posterior contour', 'joint posterior samples'),
    loc='center left',
    bbox_to_anchor=(1, 0.5)
)
# highlight the first sample
ax.scatter(mu[0], sigma[0], 40, 'r')

# plot first ynew
ax = axes[1]
# plot the distribution and the respective sample
line1, = ax.plot(xynew, ynewdists)
ax1_hs = ax.scatter(ynew[0], 0.02*np.max(ynewdists), 40, 'r')
# decorate
ylims_from_1 = ax.set_ylim()
ax.set_xlim(tlynew)
ax.set_xlabel('$\widetilde{y}$', fontsize=14)
ax.set_yticks(())
ax.legend(
    (line1, ax1_hs),
    ('pred.dist. given the posterior sample',
    'sample from the predictive distribution'),
    loc='center left',
    bbox_to_anchor=(1, 0.5)
)

# plot all ynews
ax = axes[2]
ax.scatter(
    ynew,
    (0.02 + 0.05*rng.rand(*ynew.shape))*np.max(ynewdists),
    10,
    color='C2',
    alpha=0.2,
    label='samples from the predictive distribution'
)
ax.plot(
    xynew,
    p_new,
    linewidth=1.5,
    label='exact predictive distribution'
)
ax.set_ylim(ylims_from_1)
ax.set_xlim(tlynew)
ax.set_xlabel('$\widetilde{y}$', fontsize=14)
ax.set_yticks(())
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

fig.tight_layout()"
"# Plot the probabilities, using 'seats' as the index as a bar chart
pd.Series(aisle_probability, index=seats).plot(kind='bar', # set y to range between 0 and 1
                                                    ylim=[0,1],
                                                    # set the figure size
                                                    figsize=[10,6],
                                                    # set the figure title
                                                    title='Probabilty of being an Aisle Seat in Economy Class')"
"# train['species'] contains the actual species names. Before we can use it,
# we need to convert each species name into a digit. So, in this case there
# are three species, which have been coded as 0, 1, or 2.
y = pd.factorize(train['species'])[0]

# View target
y"
"# Create a random forest Classifier. By convention, clf means 'Classifier'
clf = RandomForestClassifier(n_jobs=2, random_state=0)

# Train the Classifier to take the training features and learn how they relate
# to the training y (the species)
clf.fit(train[features], y)"
"# Apply the Classifier we trained to the test data (which, remember, it has never seen before)
clf.predict(test[features])"
"# View the predicted probabilities of the first 10 observations
clf.predict_proba(test[features])[0:10]"
"# View the PREDICTED species for the first five observations
preds[0:5]"
"seaborn.lmplot('test_1', 'test_2', data=training_data, fit_reg=False,hue=""outcome"", scatter_kws={""marker"": ""D"",""s"": 100})"
"trained_model.score(X, y)"
trained_model.predict_proba(x_test)
"data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"df.drop(['Cochice', 'Pima'])"
df[df.name != 'Tina']
df.drop(df.index[2])
"df.drop(df.index[[2,3]])"
df.drop(df.index[-2])
df[:3] #keep top 3
df[:-3] #drop bottom 3 
"data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [1, 2, 1, 2, 3],
        'coverage': [2, 2, 3, 3, 3]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"df.sort_values(by='reports', ascending=0)"
"df.sort_values(by=['coverage', 'reports'])"
"# Create a figure
plt.figure(figsize=(10,8))

# Create a scatterplot of,
            # attacker size in year 298 as the x axis
plt.scatter(df['attacker_size'][df['year'] == 298], 
            # attacker size in year 298 as the y axis
            df['defender_size'][df['year'] == 298], 
            # the marker as
            marker='x', 
            # the color
            color='b',
            # the alpha
            alpha=0.7,
            # with size
            s = 124,
            # labelled this
            label='Year 298')
            
            # attacker size in year 299 as the x axis
plt.scatter(df['attacker_size'][df['year'] == 299], 
            # defender size in year 299 as the y axis
            df['defender_size'][df['year'] == 299], 
            # the marker as
            marker='o', 
            # the color
            color='r', 
            # the alpha
            alpha=0.7,
            # with size
            s = 124,
            # labelled this
            label='Year 299')

            # attacker size in year 300 as the x axis
plt.scatter(df['attacker_size'][df['year'] == 300], 
            # defender size in year 300 as the y axis
            df['defender_size'][df['year'] == 300], 
            # the marker as
            marker='^', 
            # the color
            color='g', 
            # the alpha
            alpha=0.7, 
            # with size
            s = 124,
            # labelled this
            label='Year 300')

# Chart title
plt.title('Battles Of The War Of The Five Kings')

# y label
plt.ylabel('Defender Size')

# x label
plt.xlabel('Attacker Size')

# and a legend
plt.legend(loc='upper right')

# set the figure boundaries
plt.xlim([min(df['attacker_size'])-1000, max(df['attacker_size'])+1000])
plt.ylim([min(df['defender_size'])-1000, max(df['defender_size'])+1000])

plt.show()"
"data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"# Create a variable
next_year = []

# For each row in df.years,
for row in df['year']:
    # Add 1 to the row and append it to next_year
    next_year.append(row + 1)

# Create df.next_year
df['next_year'] = next_year

# View the dataframe
df"
df
"# Create an example dataframe
data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"# Create a list of colors (from iWantHue)
colors = [""#E13F29"", ""#D69A80"", ""#D63B59"", ""#AE5552"", ""#CB5C3B"", ""#EB8076"", ""#96624E""]

# Create a pie chart
plt.pie(
    # using data total)arrests
    df['total_arrests'],
    # with the labels being officer names
    labels=df['officer_name'],
    # with no shadows
    shadow=False,
    # with colors
    colors=colors,
    # with one slide exploded out
    explode=(0, 0, 0, 0, 0.15),
    # with the start angle at 90%
    startangle=90,
    # with the percent listed as a fraction
    autopct='%1.1f%%',
    )

# View the plot drop above
plt.axis('equal')

# View the plot
plt.tight_layout()
plt.show()"
"plt.scatter(df.preTestScore, df.postTestScore
, s=df.age)"
"plt.scatter(df.preTestScore, df.postTestScore, s=300, c=df.female)"
"pyplot.plot([1.6, 2.7])"
"# Create a list of unique values by turning the
# pandas column into a set
list(set(df.trucks))"
"# Create a figure with a single subplot
f, ax = plt.subplots(1, figsize=(10,5))

# Set bar width at 1
bar_width = 1

# positions of the left bar-boundaries
bar_l = [i for i in range(len(df['pre_score']))] 

# positions of the x-axis ticks (center of the bars as bar labels)
tick_pos = [i+(bar_width/2) for i in bar_l] 

# Create the total score for each participant
totals = [i+j+k for i,j,k in zip(df['pre_score'], df['mid_score'], df['post_score'])]

# Create the percentage of the total score the pre_score value for each participant was
pre_rel = [i / j * 100 for  i,j in zip(df['pre_score'], totals)]

# Create the percentage of the total score the mid_score value for each participant was
mid_rel = [i / j * 100 for  i,j in zip(df['mid_score'], totals)]

# Create the percentage of the total score the post_score value for each participant was
post_rel = [i / j * 100 for  i,j in zip(df['post_score'], totals)]

# Create a bar chart in position bar_1
ax.bar(bar_l, 
       # using pre_rel data
       pre_rel, 
       # labeled 
       label='Pre Score', 
       # with alpha
       alpha=0.9, 
       # with color
       color='#019600',
       # with bar width
       width=bar_width,
       # with border color
       edgecolor='white'
       )

# Create a bar chart in position bar_1
ax.bar(bar_l, 
       # using mid_rel data
       mid_rel, 
       # with pre_rel
       bottom=pre_rel, 
       # labeled 
       label='Mid Score', 
       # with alpha
       alpha=0.9, 
       # with color
       color='#3C5F5A', 
       # with bar width
       width=bar_width,
       # with border color
       edgecolor='white'
       )

# Create a bar chart in position bar_1
ax.bar(bar_l, 
       # using post_rel data
       post_rel, 
       # with pre_rel and mid_rel on bottom
       bottom=[i+j for i,j in zip(pre_rel, mid_rel)], 
       # labeled 
       label='Post Score',
       # with alpha
       alpha=0.9, 
       # with color
       color='#219AD8', 
       # with bar width
       width=bar_width,
       # with border color
       edgecolor='white'
       )

# Set the ticks to be first names
plt.xticks(tick_pos, df['first_name'])
ax.set_ylabel(""Percentage"")
ax.set_xlabel("""")

# Let the borders of the graphic
plt.xlim([min(tick_pos)-bar_width, max(tick_pos)+bar_width])
plt.ylim(-10, 110)

# rotate axis labels
plt.setp(plt.gca().get_xticklabels(), rotation=45, horizontalalignment='right')

# shot plot
plt.show()"
"# Create dataframe
data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3],
        'coverage': [25, 94, 57, 62, 70]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"# Create a new column that is the rank of the value of coverage in ascending order
df['coverageRanked'] = df['coverage'].rank(ascending=1)
df"
"sns.tsplot([df.deaths_regiment_1, df.deaths_regiment_2, df.deaths_regiment_3, df.deaths_regiment_4,
            df.deaths_regiment_5, df.deaths_regiment_6, df.deaths_regiment_7], color=""indianred"")"
"sns.tsplot([df.deaths_regiment_1, df.deaths_regiment_2, df.deaths_regiment_3, df.deaths_regiment_4,
            df.deaths_regiment_5, df.deaths_regiment_6, df.deaths_regiment_7], err_style=""ci_bars"", interpolate=False)"
"# Create the general blog and the ""subplots"" i.e. the bars
f, ax1 = plt.subplots(1, figsize=(10,5))

# Set the bar width
bar_width = 0.75

# positions of the left bar-boundaries
bar_l = [i+1 for i in range(len(df['pre_score']))] 

# positions of the x-axis ticks (center of the bars as bar labels)
tick_pos = [i+(bar_width/2) for i in bar_l] 

# Create a bar plot, in position bar_1
ax1.bar(bar_l, 
        # using the pre_score data
        df['pre_score'], 
        # set the width
        width=bar_width,
        # with the label pre score
        label='Pre Score', 
        # with alpha 0.5
        alpha=0.5, 
        # with color
        color='#F4561D')

# Create a bar plot, in position bar_1
ax1.bar(bar_l, 
        # using the mid_score data
        df['mid_score'], 
        # set the width
        width=bar_width,
        # with pre_score on the bottom
        bottom=df['pre_score'], 
        # with the label mid score
        label='Mid Score', 
        # with alpha 0.5
        alpha=0.5, 
        # with color
        color='#F1911E')

# Create a bar plot, in position bar_1
ax1.bar(bar_l, 
        # using the post_score data
        df['post_score'], 
        # set the width
        width=bar_width,
        # with pre_score and mid_score on the bottom
        bottom=[i+j for i,j in zip(df['pre_score'],df['mid_score'])], 
        # with the label post score
        label='Post Score', 
        # with alpha 0.5
        alpha=0.5, 
        # with color
        color='#F1BD1A')

# set the x ticks with names
plt.xticks(tick_pos, df['first_name'])

# Set the label and legends
ax1.set_ylabel(""Total Score"")
ax1.set_xlabel(""Test Subject"")
plt.legend(loc='upper left')

# Set a buffer around the edge
plt.xlim([min(tick_pos)-bar_width, max(tick_pos)+bar_width])"
df.head()
"sns.lmplot('x', 'y', data=df, fit_reg=False)"
sns.kdeplot(df.y)
"sns.kdeplot(df.y, df.x)"
sns.distplot(df.x)
"plt.hist(df.x, alpha=.3)
sns.rugplot(df.x);"
"sns.boxplot([df.y, df.x])"
"sns.violinplot([df.y, df.x])"
"sns.heatmap([df.y, df.x], annot=True, fmt=""d"")"
sns.clustermap(df)
"# Create an example dataframe
data = {'NAME': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'YEAR': [2012, 2012, 2013, 2014, 2014], 
        'REPORTS': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
df
"# Create an example dataframe
data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"#Grab DataFrame rows where column has certain values
df[df.name.isin(value_list)]"
"#Grab DataFrame rows where column doesn't have certain values
df[~df.name.isin(value_list)]"
df.resample('D').sum().plot()
"# Create a dataframe
data = {'county': ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data)
df"
"# Change the order (the index) of the rows
df.reindex([4, 3, 2, 1, 0])"
"# Print the code to create the dataframe
print('==============================')
print('RUN THE CODE BELOW THIS LINE')
print('==============================')
print('raw_data =', df.to_dict(orient='list'))
print('df = pd.DataFrame(raw_data, columns = ' + str(list(df_original)) + ')')"
"sns.palplot(sns.color_palette(""deep"", 10))"
"sns.palplot(sns.color_palette(""muted"", 10))"
"sns.palplot(sns.color_palette(""bright"", 10))"
"sns.palplot(sns.color_palette(""dark"", 10))"
"sns.palplot(sns.color_palette(""colorblind"", 10))"
"sns.palplot(sns.color_palette(""Paired"", 10))"
"sns.palplot(sns.color_palette(""BuGn"", 10))"
"sns.palplot(sns.color_palette(""GnBu"", 10))"
"sns.palplot(sns.color_palette(""OrRd"", 10))"
"sns.palplot(sns.color_palette(""PuBu"", 10))"
"sns.palplot(sns.color_palette(""YlGn"", 10))"
"sns.palplot(sns.color_palette(""YlGnBu"", 10))"
"sns.palplot(sns.color_palette(""YlOrBr"", 10))"
"sns.palplot(sns.color_palette(""YlOrRd"", 10))"
"sns.palplot(sns.color_palette(""BrBG"", 10))"
"sns.palplot(sns.color_palette(""PiYG"", 10))"
"sns.palplot(sns.color_palette(""PRGn"", 10))"
"sns.palplot(sns.color_palette(""PuOr"", 10))"
"sns.palplot(sns.color_palette(""RdBu"", 10))"
"sns.palplot(sns.color_palette(""RdGy"", 10))"
"sns.palplot(sns.color_palette(""RdYlBu"", 10))"
"sns.palplot(sns.color_palette(""RdYlGn"", 10))"
"sns.palplot(sns.color_palette(""Spectral"", 10))"
"flatui = [""#9b59b6"", ""#3498db"", ""#95a5a6"", ""#e74c3c"", ""#34495e"", ""#2ecc71""]
sns.set_palette(flatui)
sns.palplot(sns.color_palette())"
"sns.tsplot([df.deaths_regiment_1, df.deaths_regiment_2, df.deaths_regiment_3, df.deaths_regiment_4,
            df.deaths_regiment_5, df.deaths_regiment_6, df.deaths_regiment_7], color=""#34495e"")"
"# Setting the positions and width for the bars
pos = list(range(len(df['pre_score']))) 
width = 0.25 
    
# Plotting the bars
fig, ax = plt.subplots(figsize=(10,5))

# Create a bar with pre_score data,
# in position pos,
plt.bar(pos, 
        #using df['pre_score'] data,
        df['pre_score'], 
        # of width
        width, 
        # with alpha 0.5
        alpha=0.5, 
        # with color
        color='#EE3224', 
        # with label the first value in first_name
        label=df['first_name'][0]) 

# Create a bar with mid_score data,
# in position pos + some width buffer,
plt.bar([p + width for p in pos], 
        #using df['mid_score'] data,
        df['mid_score'],
        # of width
        width, 
        # with alpha 0.5
        alpha=0.5, 
        # with color
        color='#F78F1E', 
        # with label the second value in first_name
        label=df['first_name'][1]) 

# Create a bar with post_score data,
# in position pos + some width buffer,
plt.bar([p + width*2 for p in pos], 
        #using df['post_score'] data,
        df['post_score'], 
        # of width
        width, 
        # with alpha 0.5
        alpha=0.5, 
        # with color
        color='#FFC222', 
        # with label the third value in first_name
        label=df['first_name'][2]) 

# Set the y axis label
ax.set_ylabel('Score')

# Set the chart's title
ax.set_title('Test Subject Scores')

# Set the position of the x ticks
ax.set_xticks([p + 1.5 * width for p in pos])

# Set the labels for the x ticks
ax.set_xticklabels(df['first_name'])

# Setting the x-axis and y-axis limits
plt.xlim(min(pos)-width, max(pos)+width*4)
plt.ylim([0, max(df['pre_score'] + df['mid_score'] + df['post_score'])] )

# Adding the legend and showing the plot
plt.legend(['Pre Score', 'Mid Score', 'Post Score'], loc='upper left')
plt.grid()
plt.show()"
"# Create a list of the mean scores for each variable
mean_values = [df['pre_score'].mean(), df['mid_score'].mean(), df['post_score'].mean()]

# Create a list of variances, which are set at .25 above and below the score
variance = [df['pre_score'].mean() * 0.25, df['pre_score'].mean() * 0.25, df['pre_score'].mean() * 0.25]

# Set the bar labels
bar_labels = ['Pre Score', 'Mid Score', 'Post Score']

# Create the x position of the bars
x_pos = list(range(len(bar_labels)))

# Create the plot bars
# In x position
plt.bar(x_pos,
        # using the data from the mean_values
        mean_values, 
        # with a y-error lines set at variance
        yerr=variance, 
        # aligned in the center
        align='center',
        # with color
        color='#FFC222',
        # alpha 0.5
        alpha=0.5)

# add a grid
plt.grid()

# set height of the y-axis
max_y = max(zip(mean_values, variance)) # returns a tuple, here: (3, 5)
plt.ylim([0, (max_y[0] + max_y[1]) * 1.1])

# set axes labels and title
plt.ylabel('Score')
plt.xticks(x_pos, bar_labels)
plt.title('Mean Scores For Each Test')

plt.show()"
"# Let's take a took at the data
df.head()"
"# Group the data by month, and take the mean for each group (i.e. each month)
df.resample('M').mean()"
"# Group the data by month, and take the sum for each group (i.e. each month)
df.resample('M').sum()"
"# View the index
df.index"
"# Summarize the results by regiment
df.sum(level='regiment')"
"# Create a groupby variable that groups preTestScores by regiment
groupby_regiment = df['preTestScore'].groupby(df['regiment'])
groupby_regiment"
df['postTestScore'].groupby(df['categories']).apply(get_stats).unstack()
"# Create a new variable called 'header' from the first row of the dataset
header = df.iloc[0]"
"df = pd.DataFrame()

df['german_army'] = np.random.randint(low=20000, high=30000, size=100)
df['allied_army'] = np.random.randint(low=20000, high=40000, size=100)
df.index = pd.date_range('1/1/2014', periods=100, freq='H')

df.head()"
"df.truncate(before='1/2/2014', after='1/3/2014')"
df.head()
df.shift(1).head()
df.shift(-1).tail()
df.resample('D').sum()
df.resample('D').mean()
df.resample('D').median()
df.resample('D').median()
df.resample('D').first()
df.resample('D').last()
df.resample('D').ohlc()
"matches = df['email'].str.match(pattern, flags=re.IGNORECASE)
matches"
matches.str[1]
"c = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.RdYlGn)"
"c1 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.Blues)"
"c2 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.BrBG)"
"c3 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.Greens)"
"c4 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.RdGy)"
"c5 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.YlOrRd)"
"c6 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.autumn)"
"c7 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.binary)"
"c8 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.gist_earth)"
"c9 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.gist_heat)"
"c10 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.hot)"
"c11 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.spring)"
"c12 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.summer)"
"c12 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.winter)"
"c13 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.bone)"
"c14 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.cool)"
"c15 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.YlGn)"
"c16 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.RdBu)"
"c17 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.PuOr)"
"c18 = plt.scatter(theta, r, c=colors, s=area, cmap=plt.cm.Oranges)"
"data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3],
        'coverage': [25, 94, 57, 62, 70]}
df = pd.DataFrame(data, index = ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'])
df"
"# Drop the string variable so that applymap() can run
df = df.drop('name', axis=1)

# Return the square root of every cell in the dataframe
df.applymap(np.sqrt)"
df.applymap(times100)
"print('year 1 battles:',  year_1[0:3])
print('year 2 battles:', year_2[0:3])
print('year 3 battles:', year_3[0:3])"
centroids
variance
identified
distance
"print(cluster_1[0:3])
print(cluster_2[0:3])
print(cluster_3[0:3])"
"# create a scatter plot there the x-axis is the first column of battles
# the y-axis is the second column of battles, the size is 100, and
# the color of each point is determined by the indentified variable
plt.scatter(battles[:,0], battles[:,1], s=100, c=identified)"
df.take(np.random.permutation(len(df))[:2])
"# Join the dummy variables to the main dataframe
df_new = pd.concat([df, df_sex], axis=1)
df_new"
"# Alterative for joining the new columns
df_new = df.join(df_sex)
df_new"
"# Create an example dataframe
data = {'Platoon': ['A','A','A','A','A','A','B','B','B','B','B','C','C','C','C','C'],
       'Casualties': [1,4,5,7,5,5,6,1,4,5,6,7,4,6,4,6]}
df = pd.DataFrame(data)
df"
"# Group df by df.platoon, then apply a rolling mean lambda function to df.casualties
df.groupby('Platoon')['Casualties'].apply(lambda x:x.rolling(center=False,window=2).mean())"
"data = {'name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
        'age': [42, 52, 36, 24, 73], 
        'preTestScore': [4, 24, 31, 2, 3],
        'postTestScore': [25, 94, 57, 62, 70]}
df = pd.DataFrame(data, columns = ['name', 'age', 'preTestScore', 'postTestScore'])
df"
df['preTestScore'].mean()
df['preTestScore'].var()
df['preTestScore'].skew()
df['preTestScore'].kurt()
df.corr()
df.cov()
"# Create an example dataframe
data = {'name': ['Jason', 'Molly'], 
        'country': [['Syria', 'Lebanon'],['Spain', 'Morocco']]}
df = pd.DataFrame(data)
df"
df[df['country'].map(lambda country: 'Syria' in country)]
"data = {'county': ['Cochice', 'Pima', 'Santa Cruz', 'Maricopa', 'Yuma'], 
        'year': [2012, 2012, 2013, 2014, 2014], 
        'reports': [4, 24, 31, 2, 3]}
df = pd.DataFrame(data)
df"
df
"
df.reset_index()"
"import warnings
warnings.filterwarnings('ignore')
from urllib.request import urlopen

url = 'http://jakevdp.github.com/downloads/notebooks/XKCD_plots.ipynb'
response = urlopen(url).read().decode()
response[0:60] + ' ...'"
print(body[:400] + '...')
"print(""Resources:"", resources.keys())
print(""Metadata:"", resources['metadata'].keys())
print(""Inlining:"", resources['inlining'].keys())
print(""Extension:"", resources['output_extension'])"
"# Import the RST exproter
from nbconvert import RSTExporter
# Instantiate it
rst_exporter = RSTExporter()
# Convert the notebook to RST format
(body, resources) = rst_exporter.from_notebook_node(jake_notebook)

print(body[:970] + '...')
print('[.....]')
print(body[800:1200] + '...')"
"from IPython.display import Image
Image(data=resources['outputs']['output_3_0.png'], format='png')"
"(_, resources)          = html_exporter.from_notebook_node(jake_notebook)
(_, resources_with_fig) = html_exporter_with_figs.from_notebook_node(jake_notebook)

print(""resources without figures:"")
print(sorted(resources.keys()))

print(""\nresources with extracted figures (notice that there's one more field called 'outputs'):"")
print(sorted(resources_with_fig.keys()))

print(""\nthe actual figures are:"")
print(sorted(resources_with_fig['outputs'].keys()))"
"# Create a new config object that configures both the new preprocessor, as well as the exporter
c =  Config()
c.PelicanSubCell.start = 4
c.PelicanSubCell.end = 6
c.RSTExporter.preprocessors = [PelicanSubCell]

# Create our new, customized exporter that uses our custom preprocessor
pelican = RSTExporter(config=c)

# Process the notebook
print(pelican.from_notebook_node(jake_notebook)[0])"
"import warnings
warnings.filterwarnings('ignore')
import time

time.time()"
"import warnings
warnings.filterwarnings('ignore')
%matplotlib inline

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
np.seterr(invalid='ignore') # Workaround"
"female_age_mean = round(df[df.Sex=='female']['Age'].mean())
male_age_mean = round(df[df.Sex=='male']['Age'].mean())

print('女性の平均年齢は{0}歳、男性は{1}歳です。この平均年齢で補間します。'.format(female_age_mean, male_age_mean))"
round(df[df.Sex=='male']['Age'].mean())
"filled_df['Survived'].plot(alpha=0.6, kind='hist', bins=2)
plt.xlabel('Survived')
plt.ylabel('N')"
"fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(8, 4))

for i, sex in enumerate(['male', 'female']):
    filled_df['Survived'][filled_df.Sex==sex].hist(alpha=0.5, bins=2, ax=axes[i])
    axes[i].set_title(sex)

fig.subplots_adjust(hspace=0.3)
fig.tight_layout()"
"plt.hist([filled_df[(filled_df.Survived==0) & (filled_df.Sex=='male')]['Age'], filled_df[(filled_df.Survived==1) & (filled_df.Sex=='male')]['Age']],
          alpha=0.6, range=(1,80), bins=10, stacked=True,
          label=('Died', 'Survived'))
plt.legend()
plt.xlabel('Age')
plt.ylabel('N')
plt.title('male')"
"plt.hist([filled_df[(filled_df.Survived==0) & (filled_df.Sex=='female')]['Age'],
          filled_df[(filled_df.Survived==1) & (filled_df.Sex=='female')]['Age']],
          alpha=0.6, range=(1,80), bins=10, stacked=True,
          label=('Died', 'Survived'))
plt.legend()
plt.xlabel('Age')
plt.ylabel('N')
plt.title('female')"
"fig = plt.figure(figsize=[15, 5])

ax1 = fig.add_subplot(121)

plt.hist([filled_df[(filled_df.Survived==0) & (filled_df.Sex=='female')]['Age'],
          filled_df[(filled_df.Survived==1) & (filled_df.Sex=='female')]['Age']],
          alpha=0.6, range=(1,80), bins=10, stacked=True,
          label=('Died', 'Survived'))

plt.xlabel('Age')
plt.yticks([0, 40, 80, 120])
plt.ylabel('N')
plt.title('female')
plt.legend()

ax2 = fig.add_subplot(122)

plt.hist([filled_df[(filled_df.Survived==0) & (filled_df.Sex=='male')]['Age'],
          filled_df[(filled_df.Survived==1) & (filled_df.Sex=='male')]['Age']],
          alpha=0.6, range=(1,80), bins=10, stacked=True,
          label=('Died', 'Survived'))

plt.xlabel('Age')
plt.yticks([0, 40, 80, 120])
plt.ylabel('N')
plt.title('male')
plt.legend()

plt.show()"
"mean_age = df['Age'].mean()

for pclass in [1, 2, 3]:
    fig, axes = plt.subplots(nrows=2, ncols=2, figsize=[10, 10])

    sex_n=0
    for sex in ['male', 'female']:
        for survived in [0, 1]:
                fig = filled_df[((filled_df.Survived==survived) & (filled_df.Sex==sex) & (filled_df.Pclass==pclass) )].Age.hist(alpha=0.6, bins=10, ax=axes[sex_n][survived])
                fig.set_xlabel(""Age"")    
                fig.set_ylabel('N ('+sex+str(survived)+' )')  
                axes[sex_n][survived].set_ylim(0,70)
                fig.set_title('Pclass = {0} / mean_age = {1}'.format(pclass, round(mean_age)))
                
        sex_n += 1
    plt.subplots_adjust(hspace=0.5)
    plt.show()"
YouTubeVideo('w16iUU6IA5E')
YouTubeVideo('UQhOyZXHkxI')
YouTubeVideo('Pul4cqoPLbE')
"# Calculate pi by calculating area of quarter circle

def estimate_pi(n_attempts = 10000):
    """""" Estimate pi from area of quarter circle """""" 
    count_successes = 0
    for i in range(n_attempts):
        x_rand = np.random.random()
        y_rand = np.random.random()
        dist = math.sqrt( x_rand **2 + y_rand**2 )
        if dist <= 1.:
            count_successes += 1
    return float(count_successes) / n_attempts


print( math.pi / 4. )
print( estimate_pi(10) )"
"print( math.pi / 4. )
print( estimate_pi(100000) )"
"import numpy as np

def prob_of_outcome_tossing_n_dice(sum_dots, n, n_attempts = 1000):
    """""" Probability of the sum of the dots in n dice being sum_dots""""""
    count_successes = 0
    for a in range(n_attempts):
        # Toss dice
        sum_temp = 0
        for i in range(n):
            sum_temp += np.random.randint(6) + 1
        if sum_temp == sum_dots:
            count_successes += 1
    
    return float(count_successes) / n_attempts

print( prob_of_outcome_tossing_n_dice(3, 2, 10) )
print( prob_of_outcome_tossing_n_dice(3, 2, 100) )
print( prob_of_outcome_tossing_n_dice(3, 2) )
print( prob_of_outcome_tossing_n_dice(3, 2, 1000000) )"
"import scipy.stats as stats

othello_entropy = calc_entropy(othellos_dialogue)
iago_entropy = calc_entropy(iagos_dialogue)

stats.ttest_ind([othello_entropy], [iago_entropy] )"
"def synthetic_dialogue_generator(dialogue):
    import random
    new_dialogue = []
    for i in range(len(dialogue)):
        new_dialogue.append( random.choice(dialogue) )
    return new_dialogue

synthetic_dialogue = synthetic_dialogue_generator(othellos_dialogue)
print( len(synthetic_dialogue) )
print(synthetic_dialogue[:10])"
"from IPython.display import Image
Image(filename='bhcurve.png',width=600)"
"from IPython.display import Image
Image(filename='srm.png',width=600)"
"from IPython.display import Image
Image(filename='magnetic.png',width=300)"
"from IPython.display import Image
Image(filename='core.png', width=500, height=500)"
"from IPython.display import Image
Image(filename='skindepthreason.png', width=200, height=200)"
"from IPython.display import Image
Image(filename='skindepth.png', width=200, height=200)
"
"import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
%matplotlib inline

plt.title('axvline/axhline, vlines/hlines, axvspan/axhspan')

# Vertical elements
plt.axvline(x=-0.5, ymin=.25, color='red')
plt.vlines(x=[0.6, 0.8], ymin=-.5, ymax=[0.75, 1.25], colors='blue')
plt.axvspan(xmin=-1.25, xmax=-.75, alpha=.5, color='green')

# Horizontal elements
plt.axhline(y=0.5, xmax=.75, color='orange')
plt.hlines(y=[0.7, 1.1], xmin=[.25, .5], xmax=0.75, color='black')
plt.axhspan(ymin=-1., ymax=0, alpha=.5, color='purple')

plt.ylim(-1.5);"
"fig = plt.figure(figsize=(15,7))
ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],
                     title=""Flow Diagram of two connected, non-circular systems"")
sankey = Sankey(ax=ax, scale=0.01, unit='', format='%G', gap=2,
                radius=0.01, shoulder=0, offset=1, head_angle=160, margin=2.4)

sankey.add(patchlabel=""Flow A"",
           flows=[1000,1525 ,-2025],
           orientations=[-1, 1, 0],
           labels=['A', 'B', ''],
           trunklength=10,
           prior= None,
           connect=(0,0),
           alpha=0.2, lw=4.0)
        
s2 = sankey.add(patchlabel=""Flow B"",
           flows=[2025, -500, -450, -310,
                  -205, -400, -160],
           orientations=[0, 1, 1, 1,
                         1 , 0, -1],
           labels=['', 'B2', 'Housing', 'Food',
                   'Transportation', 'Health Care', 'Other Necessities'],
           trunklength=10,
           pathlengths=[10, 3, 3, 3,
                        3, 3, 5],
           prior= 0,
           connect=(2,0),
           rotation = 0,
           alpha=0.2, lw=4.0, color='r')  # Arguments to matplotlib.patches.PathPatch()

diagrams = sankey.finish()
diagrams[0].texts[2].remove()"
"plt.plot(t, inSignal, label='Input')
plt.plot(tout, outSignal, label='Output')
plt.legend(loc='lower right')
plt.ylim(0, 1.05)
plt.xlabel('Time [sec]')"
"showData(sampleRate, x, 'Cosine wave')

# Clip the data
y = x
y[1:199] = 0
y[400:1001] = 0
showData(sampleRate, y, 'Clipped Signal')

# Window the clipped data
z = y;
window = np.hamming(201)
z[199:400] = z[199:400]*window
showData(sampleRate, z, 'Clipped & Windowed Signal')"
"def findTargetSumWays_1(nums, S):
    """"""
    :type nums: Tuple[int]
    :type S: int
    :rtype: int
    """"""
    if not nums:
        if S == 0:
            return 1
        else:
            return 0
    return findTargetSumWays_1(nums[1:], S+nums[0]) + findTargetSumWays_1(nums[1:], S-nums[0]) 

%time findTargetSumWays_1(small_test_nums, small_test_S)"
"def findTargetSumWays_2(nums, S):
    if not nums:
        return 0
    dic = {nums[0]: 1, -nums[0]: 1} if nums[0] != 0 else {0: 2}
    for i in range(1, len(nums)):
        tdic = {}
        for d in dic:
            tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)
            tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0)
        dic = tdic
    return dic.get(S, 0)

%time findTargetSumWays_2(big_test_nums, big_test_S)"
"@lru_cache(10000000)
def findTargetSumWays_3(nums, S):
    if not nums:
        if S == 0:
            return 1
        else:
            return 0
    return findTargetSumWays_3(nums[1:], S+nums[0]) + findTargetSumWays_3(nums[1:], S-nums[0]) 

%time findTargetSumWays_3(big_test_nums, big_test_S)"
"# load data
f, ferr, r, rerr = np.genfromtxt(""../data/flickers.dat"").T

# fit a line
C = np.diag(ferr)
AT = np.vstack((r, np.ones_like(r)))
ATA = np.dot(AT, AT.T)
m, c = np.linalg.solve(ATA, np.dot(AT, f))
print(m, c)

# plot data
xs = np.linspace(min(r), max(r), 100)
ys = m * xs + c
plt.errorbar(r, f, xerr=rerr, yerr=ferr, fmt=""k."", capsize=0)
plt.plot(xs, ys)
plt.ylabel(""log flicker"")
plt.xlabel(""log rho"")"
"resids = f - (m * r + c)
plt.errorbar(r, resids, xerr=rerr, yerr=ferr, fmt=""k."", capsize=0)"
"# fit a line
C = np.diag(ferr)
AT = np.vstack((l, np.ones_like(l)))
ATA = np.dot(AT, AT.T)
m, c = np.linalg.solve(ATA, np.dot(AT, f))
print(m, c)

# plot data
xs = np.linspace(min(l), max(l), 100)
ys = m * xs + c
plt.errorbar(l, f, xerr=lerr, yerr=ferr, fmt=""k."", capsize=0)
plt.plot(xs, ys)
plt.ylabel(""log flicker"")
plt.xlabel(""log g"")"
"resids = f - (m * l + c)
plt.errorbar(f, resids, xerr=lerr, yerr=ferr, fmt=""k."", capsize=0)"
"plt.hist(resids)
print(np.std(resids))
print(""errorbars underestimated by a factor of"", np.std(resids/ferr))"
"plt.hist(resids)
print(np.std(resids))
print(np.std(resids/ferr))"
"data = pd.DataFrame(np.random.uniform(-1, 1, (len(simulators), len(metrics))), columns=sorted(metrics), index=simulators)

styles = [
    dict(selector=""th"", props=[(""font-size"", ""100%""),
                               (""padding"", ""20px""),
                               (""width"", ""200px""),
                               (""border"", '0px'),
                               (""text-align"", ""center"")]),
    dict(selector=""tr"", props=[(""border"", '0px')]),
    dict(selector=""td"", props=[(""font-size"", ""100%""),
                               (""padding"", ""20px""),
                               (""text-align"", ""center"")]),
]

(data.style
     .set_table_styles(styles)
     .background_gradient(cmap='seismic', low=5.0, high=5.0)
     .set_precision(3))
"
"d = HBox(scales)
d"
"import warnings
warnings.filterwarnings('ignore')
%matplotlib inline

import sys

import numpy as np
import scipy as sp
import pandas as pd
import matplotlib as mpl

from numpy.fft import rfft, rfftfreq
from scipy.signal import spectrogram
import matplotlib.pyplot as plt

print(sys.version)
for module in (np, sp, pd, mpl):
    print('{:.<15}{}'.format(module.__name__, module.__version__))"
"Ns = 128
tt = np.arange(Ns)/Ns
Ac = 2.
fc = 2.
sc = Ac*(np.sin(2.*np.pi*fc*tt)+np.sin(2.*2.*np.pi*fc*tt))
sm = sc
se = sm-sc
FDE = FDEindex(sc, sm)
RMS = rms(se)
print('FDE index={:.2f}, RMS error={:.2f}'.format(FDE, RMS))
fig, ax = plt.subplots(1, 2, figsize=(12,4))
ax[0].plot(tt, sc, label='Computed')
ax[0].plot(tt, sm, label='Measured')
ax[0].legend()
ax[0].grid(b=True)
ax[1].plot(tt, se, label='Error')
ax[1].legend()
ax[1].grid(b=True)"
"sm1 = np.roll(sc, 1)
se1 = sm1-sc
FDE1 = FDEindex(sc, sm1)
RMS1 = rms(se1)
print('FDE index={:.2f}, RMS error={:.2f}'.format(FDE1, RMS1))
fig, ax = plt.subplots(1, 2, figsize=(12,4))
ax[0].plot(tt, sc, label='Computed')
ax[0].plot(tt, sm1, label='Measured')
ax[0].legend()
ax[0].grid(b=True)
ax[1].plot(tt, se1, label='Error')
ax[1].legend()
ax[1].grid(b=True)"
"sm2 = -sc
se2 = sm2-sc
FDE2 = FDEindex(sc, sm2)
RMS2 = rms(se2)
print('FDE index={:.2f}, RMS error={:.2f}'.format(FDE2, RMS2))
fig, ax = plt.subplots(1, 2, figsize=(12,4))
ax[0].plot(tt, sc, label='Computed')
ax[0].plot(tt, sm2, label='Measured')
ax[0].legend()
ax[0].grid(b=True)
ax[1].plot(tt, se2, label='Error')
ax[1].legend()
ax[1].grid(b=True)"
"sm3 = sm+(np.random.random(Ns)-0.5)
se3 = sm3-sc
FDE3 = FDEindex(sc, sm3)
RMS3 = rms(se3)
print('FDE index={:.2f}, RMS error={:.2f}'.format(FDE3, RMS3))
fig, ax = plt.subplots(1, 2, figsize=(12,4))
ax[0].plot(tt, sc, label='Computed')
ax[0].plot(tt, sm3, label='Measured')
ax[0].legend()
ax[0].grid(b=True)
ax[1].plot(tt, se3, label='Error')
ax[1].legend()
ax[1].grid(b=True)"
"data = np.array(((FDE, RMS), (FDE1, RMS1), (FDE2, RMS2), (FDE3, RMS3)))
index = ('Equal', 'Delay 1', 'Times -1', 'Add UWN')
columns = ('FDE index', 'RMS error')
df = pd.DataFrame(data, index, columns)
print(df)"
"ff = rfftfreq(Ns, d=tt[1]-tt[0])
SCOMP = rfft(sc)/Ns
SMEAS = rfft(sm3)/Ns
SERR = SMEAS-SCOMP
fig, ax = plt.subplots(1,2, figsize=(12,4))
ax[0].plot(ff, np.absolute(SCOMP), label='Computed')
ax[0].plot(ff, np.absolute(SMEAS), label='Measured')
ax[0].legend()
ax[0].grid(b=True)
ax[1].plot(ff, np.absolute(SERR), label='Error')
ax[1].legend()
ax[1].grid(b=True)"
"import warnings
warnings.filterwarnings('ignore')
# IPython magic commands
%matplotlib inline

# Python standard library
import sys
import os.path

# 3rd party modules
import numpy as np
import scipy as sp
import matplotlib as mpl

from scipy import signal
import matplotlib.pyplot as plt

print(sys.version)
for module in (np, sp, mpl):
    print('{:.<15}{}'.format(module.__name__, module.__version__))"
"fig, ax = plt.subplots(2, 2, figsize=(18,12))
for order in range(3):
    # digital filter
    b, a = signal.butter(2*(order+1), wc, analog=False)
    w, h = signal.freqz(b, a)
    ax[0][0].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][0].axvline(fc, color='green')
    ax[1][0].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][0].axvline(fc, color='green')
    # analog filter
    b, a = signal.butter(2*(order+1), fc, analog=True)
    w, h = signal.freqs(b, a)
    ax[0][1].semilogx(w, 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][1].axvline(fc, color='green')
    ax[1][1].semilogx(w, np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][1].axvline(fc, color='green')
format_plots(ax, 'Butterworth')"
"fig, ax = plt.subplots(2, 2, figsize=(18,12))
rp = 5 # maximum ripple allowed below unity gain in the passband, specified in decibels as a positive number
for order in range(3):
    # digital filter
    b, a = signal.cheby1(2*(order+1), rp, wc, analog=False)
    w, h = signal.freqz(b, a)
    ax[0][0].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][0].axvline(fc, color='green')
    ax[0][0].axhline(-rp, color='green')
    ax[1][0].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][0].axvline(fc, color='green')
    # analog filter
    b, a = signal.cheby1(2*(order+1), rp, fc, analog=True)
    w, h = signal.freqs(b, a)
    ax[0][1].semilogx(w, 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][1].axvline(fc, color='green')
    ax[0][1].axhline(-rp, color='green')
    ax[1][1].semilogx(w, np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][1].axvline(fc, color='green')
format_plots(ax, f'Chebyshev Type I (rp={rp})')"
"fig, ax = plt.subplots(2, 2, figsize=(18,12))
rs = 40 # minimum attenuation required in the stop band, specified in decibels as a positive number
for order in range(3):
    # digital filter
    b, a = signal.cheby2(2*(order+1), rs, wc, analog=False)
    w, h = signal.freqz(b, a)
    ax[0][0].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][0].axvline(fc, color='green')
    ax[0][0].axhline(-rs, color='green')
    ax[1][0].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][0].axvline(fc, color='green')
    # analog filter
    b, a = signal.cheby2(2*(order+1), rs, fc, analog=True)
    w, h = signal.freqs(b, a)
    ax[0][1].semilogx(w, 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][1].axvline(fc, color='green')
    ax[0][1].axhline(-rs, color='green')
    ax[1][1].semilogx(w, np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][1].axvline(fc, color='green')
format_plots(ax, f'Chebyshev Type II (rs={rs})')"
"fig, ax = plt.subplots(2, 2, figsize=(18,12))
rp = 5 # maximum ripple allowed below unity gain in the passband, specified in decibels as a positive number
rs = 40 # minimum attenuation required in the stop band, specified in decibels as a positive number
for order in range(3):
    # digital filter
    b, a = signal.ellip(2*(order+1), rp, rs, wc, analog=False)
    w, h = signal.freqz(b, a)
    ax[0][0].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][0].axvline(fc, color='green')
    ax[0][0].axhline(-rp, color='green')
    ax[0][0].axhline(-rs, color='green')
    ax[1][0].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][0].axvline(fc, color='green')
    # analog filter
    b, a = signal.ellip(2*(order+1), rp, rs, fc, analog=True)
    w, h = signal.freqs(b, a)
    ax[0][1].semilogx(w, 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][1].axvline(fc, color='green')
    ax[0][1].axhline(-rp, color='green')
    ax[0][1].axhline(-rs, color='green')
    ax[1][1].semilogx(w, np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][1].axvline(fc, color='green')
format_plots(ax, f'Elliptic (rp={rp}, rs={rs})')"
"fig, ax = plt.subplots(2, 2, figsize=(18,12))
for order in range(3):
    # digital filter
    b, a = signal.bessel(2*(order+1), wc, analog=False)
    w, h = signal.freqz(b, a)
    ax[0][0].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][0].axvline(fc, color='green')
    ax[1][0].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][0].axvline(fc, color='green')
    # analog filter
    b, a = signal.bessel(2*(order+1), fc, analog=True)
    w, h = signal.freqs(b, a)
    ax[0][1].semilogx(w, 20 * np.log10(abs(h)), label=f'order={2*(order+1)}')
    ax[0][1].axvline(fc, color='green')
    ax[1][1].semilogx(w, np.unwrap(np.angle(h))*180/np.pi, label=f'order={2*(order+1)}')
    ax[1][1].axvline(fc, color='green')
format_plots(ax, 'Bessel')"
"fig, ax = plt.subplots(2, 2, figsize=(18,12))
for Q in range(3): # quality factor
    # Notch filter
    b, a = signal.iirnotch(wc, 10*(Q+1))
    w, h = signal.freqz(b, a)
    ax[0][0].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'Q={10*(Q+1)}')
    ax[0][0].axvline(fc, color='green')
    ax[1][0].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'Q={10*(Q+1)}')
    ax[1][0].axvline(fc, color='green')
    # Peak filter
    b, a = signal.iirpeak(wc, 10*(Q+1))
    w, h = signal.freqz(b, a)
    ax[0][1].plot(w*fs/(2*np.pi), 20 * np.log10(abs(h)), label=f'Q={10*(Q+1)}')
    ax[0][1].axvline(fc, color='green')
    ax[1][1].plot(w*fs/(2*np.pi), np.unwrap(np.angle(h))*180/np.pi, label=f'Q={10*(Q+1)}')
    ax[1][1].axvline(fc, color='green')
format_plots(ax, 'Digital', column_name=('notch', 'peak'))"
"print('System: {}'.format(sys.version))
for package in (np, sp, mpl, pd):
    print('Package: {} {}'.format(package.__name__, package.__version__))"
"x = np.linspace(rv.ppf(0.001), rv.ppf(0.999), 1000)
fig, ax = plt.subplots(1, 1)
ax.plot(x, rv.pdf(x), label='frozen pdf')
ax.plot(x, rv.cdf(x), lw=2, label='frozen cdf')
ax.axhline(0.5, ls=':')
ax.axhline(1.0, ls=':')
ax.axvline(mean, ls='-.', label='mean')
ax.legend(loc='best', frameon=False)
plt.show()"
"Nsamples = [u*d for d in (10,100,1000) for u in (1,2,5)]
ysamples = []
fig, ax = plt.subplots(3, 3, sharex=True, sharey=True, figsize=(8,6))
for row in range(3):
    for col in range(3):
        N = Nsamples[3*row+col]
        ax[row,col].plot(x, rv.pdf(x), 'k-', lw=2)
        y = rv.rvs(size=N)
        b = int(math.sqrt(N))
        ysamples.append(y)
        ax[row,col].hist(y, bins=b, normed=True, histtype='stepfilled', alpha=0.2)
        ax[row,col].set_title('{} samples, {} bins'.format(N, b))
plt.show()"
"fig, ax = plt.subplots(3, 3, sharex=True, sharey=True, figsize=(8,6))
for row in range(3):
    for col in range(3):
        N = Nsamples[3*row+col]
        y = ysamples[3*row+col]
        ax[row,col].plot(x, rv.cdf(x), 'k-', lw=2)
        yn = np.sort(y)
        xn = np.linspace(0., 1., num=N)
        ax[row,col].plot(yn, xn, 'o', alpha=0.2)
        ax[row,col].axhline(0.5, ls=':')
        ax[row,col].axvline(mean, ls=':')
        ax[row,col].set_title('{} samples'.format(N))
plt.show()"
"Dsamples = []
psamples = []
for N,y in zip(Nsamples, ysamples):
    D, pvalue = stats.kstest(y, 'norm', args=(mean, std))
    Dsamples.append(D)
    psamples.append(pvalue)
    print('{:4d} samples: D={}, pvalue={}'.format(N, D, pvalue))"
"fig, ax = plt.subplots(1, 1)
ax.scatter(psamples, Dsamples, s=Nsamples, alpha=0.2)
for p,D,N in zip(psamples, Dsamples, Nsamples):
    ax.text(p, D, str(N), ha='center', va='center')
ax.set_xlabel('p-value')
ax.set_ylabel('D')
ax.set_title('K-S test results')
plt.show()"
"for N,y in zip(Nsamples, ysamples):
    A2, critical_values, significance_level = stats.anderson(y)
    print('{:4d} samples: A2={}'.format(N, A2), critical_values, significance_level)"
"Wsamples = []
psamples = []
for N,y in zip(Nsamples, ysamples):
    W, pvalue = stats.shapiro(y)
    Wsamples.append(W)
    psamples.append(pvalue)
    print('{:4d} samples: W={}, pvalue={}'.format(N, W, pvalue))"
"fig, ax = plt.subplots(1, 1)
ax.scatter(psamples, Wsamples, s=Nsamples, alpha=0.2)
for p,W,N in zip(psamples, Wsamples, Nsamples):
    ax.text(p, W, str(N), ha='center', va='center')
ax.set_xlabel('p-value')
ax.set_ylabel('W')
ax.set_title('S-W test results')
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import sys
import numpy as np
import scipy as sp
import matplotlib as mpl

print('System: {}'.format(sys.version))
print('numpy version: {}'.format(np.__version__))
print('scipy version: {}'.format(sp.__version__))
print('matplotlib version: {}'.format(mpl.__version__))"
"MM = np.matrix(np.diag([1., 2.]))
print(MM)"
"C2 = np.matrix([[0.1, 0.2], [0.2, 0.2]])
print(C2)"
"W2, F1 = LA.eig(LA.solve(MM,KK)) # eigenanalysis
ix = np.argsort(np.absolute(W2)) # sort eigenvalues in ascending order
W2 = W2[ix] # sorted eigenvalues
F1 = F1[:,ix] # sorted eigenvectors
print(np.round_(W2, 4))
print(np.round_(F1, 4))"
print(np.sqrt(W2))
"print(LA.norm(F1, axis=0))"
"fig, ax = plt.subplots(1, 2, subplot_kw=dict(polar=True))
for mode in range(2):
    ax[mode].set_title('Mode #{}'.format(mode+1))
    for dof in range(2):
        r = np.array([0, np.absolute(F1[dof,mode])])
        t = np.array([0, np.angle(F1[dof,mode])])
        ax[mode].plot(t, r, 'o-', label='DOF #{}'.format(dof+1))
plt.legend(loc='lower left', bbox_to_anchor=(1., 0.))
plt.show()"
"print(np.round_(F1.T*C1*F1, 4))"
"w1, v1 = LA.eig(LA.solve(A,B))
ix = np.argsort(np.absolute(w1))
w1 = w1[ix]
v1 = v1[:,ix]
print(np.round_(w1, 4))
print(np.round_(v1, 4))"
"zw = -w1.real # damping coefficient time angular frequency
wD = w1.imag # damped angular frequency
zn = 1./np.sqrt(1.+(wD/-zw)**2) # the minus sign is formally correct!
wn = zw/zn # undamped angular frequency
print('Angular frequency: {}'.format(wn[[0,2]]))
print('Damping coefficient: {}'.format(zn[[0,2]]))"
"print(LA.norm(v1[:,::2], axis=0))"
"AA = v1[:2,[0,2]]
AB = AA.conjugate()
BA = np.multiply(AA,w1[[0,2]])
BB = BA.conjugate()
v1_new = np.bmat([[AA, AB], [BA, BB]])
print(np.round_(v1_new[:,[0,2,1,3]], 4))"
"fig, ax = plt.subplots(1, 2, subplot_kw=dict(polar=True))
for mode in range(2):
    ax[mode].set_title('Mode #{}'.format(mode+1))
    for dof in range(2):
        r = np.array([0, np.absolute(v1[dof,2*mode])])
        t = np.array([0, np.angle(v1[dof,2*mode])])
        ax[mode].plot(t, r, 'o-', label='DOF #{}'.format(dof+1))
plt.legend(loc='lower left', bbox_to_anchor=(1., 0.))
plt.show()"
"print(np.round_(F1.T*C2*F1, 4))"
"A = np.bmat([[np.zeros_like(MM), MM], [MM, C2]])
print(A)"
"w2, v2 = LA.eig(LA.solve(A,B))
ix = np.argsort(np.absolute(w2))
w2 = w2[ix]
v2 = v2[:,ix]
print(np.round_(w2, 4))
print(np.round_(v2, 4))"
"zw = -w2.real # damping coefficient times angular frequency
wD = w2.imag # damped angular frequency
zn = 1./np.sqrt(1.+(wD/-zw)**2) # the minus sign is formally correct!
wn = zw/zn # undamped angular frequency
print('Angular frequency: {}'.format(wn[[0,2]]))
print('Damping coefficient: {}'.format(zn[[0,2]]))"
"print(LA.norm(v2[:,[0,2]], axis=0))"
"AA = v2[:2,[0,2]]
AB = AA.conjugate()
BA = np.multiply(AA,w2[[0,2]])
BB = BA.conjugate()
v2_new = np.bmat([[AA, AB], [BA, BB]])
print(np.round_(v2_new[:,[0,2,1,3]], 4))"
"fig, ax = plt.subplots(1, 2, subplot_kw=dict(polar=True))
for mode in range(2):
    ax[mode].set_title('Mode #{}'.format(mode+1))
    for dof in range(2):
        r = np.array([0, np.absolute(v2[dof,2*mode])])
        t = np.array([0, np.angle(v2[dof,2*mode])])
        ax[mode].plot(t, r, 'o-', label='DOF #{}'.format(dof+1))
plt.legend(loc='lower left', bbox_to_anchor=(1., 0.))
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import sys
import numpy as np
import scipy as sp
import matplotlib as mpl

print('System: {}'.format(sys.version))
print('numpy version: {}'.format(np.__version__))
print('scipy version: {}'.format(sp.__version__))
print('matplotlib version: {}'.format(mpl.__version__))"
"W2, F1 = LA.eig(LA.solve(MM,KK)) # eigenanalysis
ix = np.argsort(np.absolute(W2)) # sort eigenvalues in ascending order
W2 = W2[ix] # sorted eigenvalues
F1 = F1[:,ix] # sorted eigenvectors
print(np.round_(W2, 4))
print(np.round_(F1, 4))"
print(np.sqrt(W2))
"print(LA.norm(F1, axis=0))"
"A = np.bmat([[np.zeros_like(MM), np.identity(MM.shape[0])], [LA.solve(-MM,KK), LA.solve(-MM,C0)]])
print(A)"
"w0, v0 = LA.eig(A)
ix = np.argsort(np.absolute(w0))
w0 = w0[ix]
v0 = v0[:,ix]
print(np.round_(w0, 4))
print(np.round_(v0, 4))"
"print(w0[[0,2]].imag)"
"print(LA.norm(v0[:,[0,2]], axis=0))"
"AA = v0[:2,[0,2]]
AB = AA.conjugate()
BA = np.multiply(AA,w0[[0,2]])
BB = BA.conjugate()
v0_new = np.bmat([[AA, AB], [BA, BB]])
print(np.round_(v0_new[:,[0,2,1,3]], 4))"
"fig, ax = plt.subplots(1, 2, subplot_kw=dict(polar=True))
for mode in range(2):
    ax[mode].set_title('Mode #{}'.format(mode+1))
    for dof in range(2):
        r = np.array([0, np.absolute(v0[dof,2*mode])])
        t = np.array([0, np.angle(v0[dof,2*mode])])
        ax[mode].plot(t, r, 'o-', label='DOF #{}'.format(dof+1))
plt.legend(loc='lower left', bbox_to_anchor=(1., 0.))
plt.show()"
"print(np.round_(F1.T*C1*F1, 4))"
"w1, v1 = LA.eig(A)
ix = np.argsort(np.absolute(w1))
w1 = w1[ix]
v1 = v1[:,ix]
print(np.round_(w1, 4))
print(np.round_(v1, 4))"
"print(np.round_(w1[[0,2]], 4))"
"zw = -w1.real # damping coefficient time angular frequency
wD = w1.imag # damped angular frequency
zn = 1./np.sqrt(1.+(wD/-zw)**2) # the minus sign is formally correct!
wn = zw/zn # undamped angular frequency
print('Angular frequency: {}'.format(wn[[0,2]]))
print('Damping coefficient: {}'.format(zn[[0,2]]))"
"print(LA.norm(v1[:,[0,2]], axis=0))"
"fig, ax = plt.subplots(1, 2, subplot_kw=dict(polar=True))
for mode in range(2):
    ax[mode].set_title('Mode #{}'.format(mode+1))
    for dof in range(2):
        r = np.array([0, np.absolute(v1[dof,2*mode])])
        t = np.array([0, np.angle(v1[dof,2*mode])])
        ax[mode].plot(t, r, 'o-', label='DOF #{}'.format(dof+1))
plt.legend(loc='lower left', bbox_to_anchor=(1., 0.))
plt.show()"
"print(np.round_(F1.T*C2*F1, 4))"
"w2, v2 = LA.eig(A)
ix = np.argsort(np.absolute(w2))
w2 = w2[ix]
v2 = v2[:,ix]
print(np.round_(w2, 4))
print(np.round_(v2, 4))"
"zw = -w2.real # damping coefficient time angular frequency
wD = w2.imag # damped angular frequency
zn = 1./np.sqrt(1.+(wD/-zw)**2) # the minus sign is formally correct!
wn = zw/zn # undamped angular frequency
print('Angular frequency: {}'.format(wn[[0,2]]))
print('Damping coefficient: {}'.format(zn[[0,2]]))"
"print(LA.norm(v2[:,[0,2]], axis=0))"
"AA = v2[:2,[0,2]]
AB = AA.conjugate()
BA = np.multiply(AA,w2[[0,2]])
BB = BA.conjugate()
v2_new = np.bmat([[AA, AB], [BA, BB]])
print(np.round_(v2_new[:,[0,2,1,3]], 4))"
"fig, ax = plt.subplots(1, 2, subplot_kw=dict(polar=True))
for mode in range(2):
    ax[mode].set_title('Mode #{}'.format(mode+1))
    for dof in range(2):
        r = np.array([0, np.absolute(v2[dof,2*mode])])
        t = np.array([0, np.angle(v2[dof,2*mode])])
        ax[mode].plot(t, r, 'o-', label='DOF #{}'.format(dof+1))
plt.legend(loc='lower left', bbox_to_anchor=(1., 0.))
plt.show()"
"import warnings
warnings.filterwarnings('ignore')
import sys
import math
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
%matplotlib inline
print('System: {}'.format(sys.version))
for package in (np, mpl):
    print('Package: {} {}'.format(package.__name__, package.__version__))"
"MM = np.matrix(np.diag([1.,2.,3.]))
KK = np.matrix([[2,-1,0],[-1,2,-1],[0,-1,1]])*1000.
print(MM)
print(KK)"
"W2, F1 = np.linalg.eig(KK.I@MM)
print(W2)
print(F1)"
"ix = np.argsort(W2)[::-1]
W2 = 1./W2[ix]
F1 = F1[:,ix]
Wn = np.sqrt(W2)
print(W2)
print(Wn)
print(F1)"
"Mn = np.diag(Fn.T@MM@Fn)
Kn = np.diag(Fn.T@KK@Fn)
print(Mn)
print(Kn)"
"sp = np.matrix([[0.], [1.], [0.]])
wp = 2.*np.pi*4.
print(sp)
print(wp)"
"tt = np.arange(1000)*0.005
pt = np.sin(wp*tt)
plt.figure()
plt.plot(tt, pt)
plt.xlabel('Tempo (s)')
plt.ylabel('Força (kN)')
plt.show()"
"qn_t = []
plt.figure()
for n in range(3):
    an = Gn[n]/Kn[n]
    bn = wp/Wn[n]
    q = qn(an[0,0], wp, bn, 0.05, tt)
    qn_t.append(q)
    plt.plot(tt, q, label='an={:.2e},bn={:.2f}'.format(an[0,0], bn))
plt.legend()
plt.xlabel('Tempo (s)')
plt.ylabel('Deslocamento modal (m)')
plt.show()"
"plt.figure()
u_t = Fn@qn_t
for n in range(3):
    plt.plot(tt, u_t[n].T, label='{:.2e}'.format(np.max(u_t[n])))
plt.legend()
plt.xlabel('Tempo (s)')
plt.ylabel('Deslocamento (m)')
plt.show()"
"ust = KK.I@sp
print(ust)"
"qn_st_t = []
plt.figure()
for n in range(3):
    an = Fn.T[n]@MM@ust/Mn[n]
    bn = wp/Wn[n]
    qst = qn(an[0,0], wp, bn, 0.05, tt)
    qn_st_t.append(qst)
    plt.plot(tt, qst, label='an={:.2e},bn={:.2f}'.format(an[0,0], bn))
plt.legend()
plt.xlabel('Tempo (s)')
plt.ylabel('Deslocamento modal (m)')
plt.show()"
"plt.figure()
u_t = Fn@qn_st_t
for n in range(3):
    plt.plot(tt, u_t[n].T, label='{:.2e}'.format(np.max(u_t[n])))
plt.legend()
plt.xlabel('Tempo (s)')
plt.ylabel('Deslocamento (m)')
plt.show()"
"f = (y2-y)/(y2-y1)*(Q11*(x2-x)/(x2-x1)+Q21*(x-x1)/(x2-x1))+(y-y1)/(y2-y1)*(Q12*(x2-x)/(x2-x1)+Q22*(x-x1)/(x2-x1))
f"
"sympy.simplify(sympy.diff(f,x))"
"sympy.simplify(sympy.diff(f,y))"
"f1 = (1-eta)/2*(Q11*(1-csi)/2+Q21*(csi+1)/2)+(eta+1)/2*(Q12*(1-csi)/2+Q22*(csi+1)/2)
f1"
"sympy.simplify(sympy.diff(f1,csi))"
"sympy.simplify(sympy.diff(f1,eta))"
"# Likelihood function of a Bernoulli trial (coin toss)
p_list = linspace(0,1,500)
l_list = [L(1,10,p) for p in p_list]
plt.figure(figsize=(4,2))
plt.rcParams['font.size']=15
plt.plot(p_list,l_list)
plt.xlabel('$p$')
plt.ylabel('$L(p|k)$')
plt.yticks([0,0.1,0.2,0.3,0.4]);"
"plt.figure(figsize=(5,4))
plt.subplot(211)
plt.plot(p_list,gradient(l_list))
plt.plot(p_list, zeros_like(p_list), 'k--')
for i in range(len(candidate_idx)):
    plt.plot(p_list[candidate_idx[i]], 
             gradient(l_list)[candidate_idx[i]], 'ro')
#plt.plot(p_list)
plt.ylim([-0.01,0.01])
plt.yticks([-0.01, 0, 0.01])
plt.ylabel('$\dot{L}$')

plt.subplot(212)
plt.plot(p_list,gradient(gradient(l_list)))
for i in range(len(candidate_idx)):
    plt.plot(p_list[candidate_idx[i]], 
             gradient(gradient(l_list))[candidate_idx[i]], 'ro')

plt.ylim([-0.001, 0.001])
plt.yticks([-0.001, 0, 0.001])
plt.ylabel('$\ddot{L}$')
plt.xlabel('$p$')
plt.tight_layout()"
"n = 10
k = 1
plt.figure(figsize=(4,4))
plt.subplot(211)
plt.plot(p_list, k*log(p_list)+(n-k)*log(1.-p_list) )
plt.ylim([-20,0])
plt.ylabel('$L(p\,|\,k)$')
plt.xlabel('$p$')

plt.subplot(212)
phi_list = log(p_list/(1+p_list))
plt.plot(phi_list, k*phi_list + n*log(1./(1.+exp(phi_list))))
plt.yticks([-3,-4,-5, -6])
#plt.xticks([-5,-4,-3,-2,-1])
plt.ylabel('$L(\\phi\,|\,k)$')
plt.xlabel('$\\phi$')
plt.tight_layout()"
"n = 10
k = 1
ll_phi = lambda phi: k*phi + n*log(1./(1.+exp(phi)))
soln = fsolve(ll_phi, -1)
print(soln)
soln_phi = exp(soln)/(1.+exp(soln))
print(soln_phi)"
"def f(x): return 2*np.exp(x) - (x+0.5)**2
def df(x): return 2*np.exp(x) - 2*(x+0.5)
def d2f(x): return 2*np.exp(x) - 2

# Mediante prueba y error, llegamos a este intervalo donde f cambia
# el signo pero f'>0 y 
a,b = -2, 0 
print(""[a,b] = [%f,%f]"" % (a,b))

x = np.linspace(a, b,100)
plt.plot(x, f(x), c=""red"", linewidth=4)
plt.plot(x, df(x), c=""gray"", lw=2)
plt.plot(x, d2f(x), c=""orange"")

plt.grid()
plt.axhline(c='k');
plt.legend([r""$f(x)$"",r""$f'(x)$"",r""$f''(x)$""])"
"x0 = -2 # Inicialización sugerida por la regla de Fourier
x, niter = newton(f,df,x0)
print(""Aproximación por el m. de Newton:"", x)
print(""Número de iteraciones:"", niter) 
print(""Resíduo: |f(x)| = %1.16f"" % abs(f(x)))"
"import warnings
warnings.filterwarnings('ignore')
%pylab inline"
"f = lambda x: x-3*np.arctan(x)+1
x = linspace(-6,4,num=300)
plot(x,f(x), lw=2)
axhline(c='k'); axvline(c='k')
grid()"
"df = lambda x: 1-3/(1+x**2)
df(0)
lista_x = newton(f,df,x0=2)
print(""Lista de aproximaciones:"", lista_x)
print(""Número de iteraciones: %d "" % len(lista_x))
print(""Última aproximación: %1.6f"" % lista_x[-1])"
"a,b=2,4
x=linspace(2,4)

subplot(2,1,1)
plot(x,df(x),label=""f'(x)"")
legend()
grid()

subplot(2,1,2)
d2f = lambda x: 6*x/(1+x**2)**2
plot(x,d2f(x), label=""f''(x)"")
legend()
grid()"
"g = lambda x: 1.0/(2+x)

x = np.linspace(0,1)
plt.plot(x, x, ""--"", color=""black"", linewidth=2, label=""$y=x$"")
plt.plot(x, g(x), color=""red"", linewidth=4, label=""$y=g(x)=(2+x)^{-1}$"")
plt.legend()
plt.grid()
plt.show()"
"y = 2*sin(x)*cos(x);
plot(x,y);
grid()"
arr
arr
"np.linspace( 0, 2, 9 )   # 0 到 2 总共 9 位等距间隔"
"A = np.random.randn(500)
hist(A)"
np.std(A)    # 方差
np.mean(A)   # 均值
"N = 1000
x = rnd.randn(N)
a = 0.2

y = [x[0]]
for n in range(N - 1):
    y.append(a*y[-1] + x[n])

plt.figure()
plt.plot(y, '.-', alpha=0.5)
plt.plot(x, '.-', color='r', alpha=0.5)
plt.xlabel('Time index n')"
"# Auto-Correlation function
R = []
sigsq_x = 1
for el in range(N):
    R.append(sigsq_x*(a**el)/(1 - a**2))
plt.figure()
plt.plot(R, '.-')
"
"from IPython.display import YouTubeVideo
YouTubeVideo('phnEFFL5K_A')"
